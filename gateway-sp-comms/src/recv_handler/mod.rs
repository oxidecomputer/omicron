// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2022 Oxide Computer Company

use crate::management_switch::ManagementSwitch;
use crate::management_switch::ManagementSwitchDiscovery;
use crate::management_switch::SwitchPort;
use gateway_messages::version;
use gateway_messages::ResponseError;
use gateway_messages::ResponseKind;
use gateway_messages::SerialConsole;
use gateway_messages::SpComponent;
use gateway_messages::SpMessage;
use gateway_messages::SpMessageKind;
use slog::debug;
use slog::error;
use slog::trace;
use slog::Logger;
use std::collections::HashMap;
use std::convert::TryInto;
use std::sync::Arc;
use std::sync::Mutex;

mod request_response_map;
mod serial_console_history;

pub use self::serial_console_history::SerialConsoleChunk;
pub use self::serial_console_history::SerialConsoleContents;

use self::request_response_map::RequestResponseMap;
use self::request_response_map::ResponseIngestResult;
use self::serial_console_history::SerialConsoleHistory;

/// Handler for incoming packets received on management switch ports.
///
/// When [`RecvHandler::new()`] is created, it starts an indefinite tokio task
/// that calls [`RecvHandler::handle_incoming_packet()`] for each UDP packet
/// received. Those packets come in two flavors: responses to requests that we
/// sent to an SP, and unprompted messages generated by an SP. The flow for
/// request / response is:
///
/// 1. [`RecvHandler::register_request_id()`] is called with the 32-bit request
///    ID associated with the request. This returns a future that will be
///    fulfilled with the response once it arrives. This method should be called
///    after determining the request ID but before actually sending the request
///    to avoid a race window where the response could be received before the
///    receive handler task knows to expect it. Internally, this future holds
///    the receiving half of a [`tokio::oneshot`] channel.
/// 2. The request packet is sent to the SP.
/// 3. The requester `.await`s the future returned by `register_request_id()`.
/// 4. If the future is dropped before a response is received (e.g., due to a
///    timeout), dropping the future will unregister the request ID provided in
///    step 1 (see [`RequestResponseMap::wait_for_response()`] for details).
/// 5. Assuming the future has not been dropped when the response arrives,
///    [`RecvHandler::handle_incoming_packet()`] will look up the request ID and
///    send the response on the sending half of the [`tokio::oneshot`] channel
///    corresponding to the future returned in step 1, fulfilling it.
#[derive(Debug)]
pub(crate) struct RecvHandler {
    sp_state: HashMap<SwitchPort, SingleSpState>,
    log: Logger,
}

impl RecvHandler {
    /// Create a new `RecvHandler` that is aware of all ports described by
    /// `switch`.
    pub(crate) fn new(
        switch_discovery: ManagementSwitchDiscovery,
        log: Logger,
    ) -> (ManagementSwitch, Arc<Self>) {
        // prime `sp_state` with all known ports of the switch
        let all_ports = switch_discovery.all_ports();
        let mut sp_state = HashMap::with_capacity(all_ports.len());
        for port in all_ports {
            sp_state.insert(port, SingleSpState::default());
        }

        // configure a `ManagementSwitch` that notifies us of every incoming
        // packet
        let handler = Arc::new(Self { sp_state, log });
        let switch = {
            let handler = Arc::clone(&handler);
            switch_discovery.start_recv_task(move |port, buf| {
                handler.handle_incoming_packet(port, buf)
            })
        };

        (switch, handler)
    }

    // SwitchPort instances can only be created by `ManagementSwitch`, so we
    // should never be able to instantiate a port that we don't have in
    // `self.sp_state` (which we initialize with all ports declared by the
    // switch we were given).
    fn sp_state(&self, port: SwitchPort) -> &SingleSpState {
        self.sp_state.get(&port).expect("invalid switch port")
    }

    /// Get our current serial console contents for the given SP component.
    pub(crate) fn serial_console_contents(
        &self,
        port: SwitchPort,
        component: &SpComponent,
    ) -> Option<SerialConsoleContents> {
        self.sp_state(port).serial_console.lock().unwrap().contents(component)
    }

    /// Returns a future that will complete when we receive a response on the
    /// given `port` with the corresponding `request_id`.
    ///
    /// Panics if `port` is not one of the ports defined by the `switch` given
    /// to this `RecvHandler` when it was constructed.
    pub(crate) async fn register_request_id(
        &self,
        port: SwitchPort,
        request_id: u32,
    ) -> Result<ResponseKind, ResponseError> {
        self.sp_state(port).requests.wait_for_response(request_id).await
    }

    fn handle_incoming_packet(&self, port: SwitchPort, buf: &[u8]) {
        trace!(&self.log, "received {} bytes from {:?}", buf.len(), port);

        // the first four bytes of packets we expect is always a version number;
        // check for that first
        //
        // TODO? We're (ab)using our knowledge of our packet wire format here -
        // knowledge contained in another crate - both in expecting that the
        // first four bytes are the version (perfectly reasonable) and that
        // they're stored in little endian (a bit less reasonable, but still
        // probably okay). We could consider moving this check into
        // `gateway_messages` itself?
        let version_raw = match buf.get(0..4) {
            Some(bytes) => u32::from_le_bytes(bytes.try_into().unwrap()),
            None => {
                error!(&self.log, "discarding too-short packet");
                return;
            }
        };
        match version_raw {
            version::V1 => (),
            _ => {
                error!(
                    &self.log,
                    "discarding message with unsupported version {}",
                    version_raw
                );
                return;
            }
        }

        // parse into an `SpMessage`
        let sp_msg = match gateway_messages::deserialize::<SpMessage>(buf) {
            Ok((msg, _extra)) => {
                // TODO should we check that `extra` is empty? if the
                // response is maximal size any extra data is silently
                // discarded anyway, so probably not?
                msg
            }
            Err(err) => {
                error!(&self.log, "discarding malformed message ({})", err);
                return;
            }
        };
        debug!(&self.log, "received {:?} from {:?}", sp_msg, port);

        // decide whether this is a response to an outstanding request or an
        // unprompted message
        match sp_msg.kind {
            SpMessageKind::Response { request_id, result } => {
                self.handle_response(port, request_id, result);
            }
            SpMessageKind::SerialConsole(serial_console) => {
                self.handle_serial_console(port, serial_console);
            }
        }
    }

    fn handle_response(
        &self,
        port: SwitchPort,
        request_id: u32,
        result: Result<ResponseKind, ResponseError>,
    ) {
        probes::recv_response!(|| (&port, request_id, &result));
        match self.sp_state(port).requests.ingest_response(&request_id, result)
        {
            ResponseIngestResult::Ok => (),
            ResponseIngestResult::UnknownRequestId => {
                error!(
                    &self.log,
                    "discarding unexpected response {} from {:?} (possibly past timeout?)",
                    request_id,
                    port,
                );
            }
        }
    }

    fn handle_serial_console(&self, port: SwitchPort, packet: SerialConsole) {
        probes::recv_serial_console!(|| (
            &port,
            &packet.component,
            packet.offset,
            packet.data.as_ptr() as usize as u64,
            u64::from(packet.len)
        ));
        debug!(
            &self.log,
            "received serial console data from {:?}: {:?}", port, packet
        );
        self.sp_state(port)
            .serial_console
            .lock()
            .unwrap()
            .push(packet, &self.log);
    }
}

#[derive(Debug, Default)]
struct SingleSpState {
    requests: RequestResponseMap<u32, Result<ResponseKind, ResponseError>>,
    serial_console: Mutex<SerialConsoleHistory>,
}

#[usdt::provider(provider = "gateway_sp_comms")]
mod probes {
    fn recv_response(
        _port: &SwitchPort,
        _request_id: u32,
        _result: &Result<ResponseKind, ResponseError>,
    ) {
    }

    fn recv_serial_console(
        _port: &SwitchPort,
        _component: &SpComponent,
        _offset: u64,
        _data: u64, // TODO actually a `*const u8`, but that isn't allowed by usdt
        _len: u64,
    ) {
    }
}
