// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Tools for managing LLDP during development

use std::net::{IpAddr, Ipv6Addr, SocketAddr};
use std::path::{Path, PathBuf};
use std::process::Stdio;
use std::time::Duration;

use anyhow::Context;
use tempfile::TempDir;
use tokio::{
    fs::File,
    io::{AsyncBufReadExt, BufReader},
    time::{Instant, sleep},
};

/// Specifies the amount of time we will wait for `lldpd` to launch,
/// which is currently confirmed by watching `lldpd`'s log output
/// for a message specifying the address and port `lldpd` is listening on.
pub const LLDPD_TIMEOUT: Duration = Duration::new(5, 0);

pub struct LldpdInstance {
    /// Port number the mgd instance is listening on. This can be provided
    /// manually, or dynamically determined if a value of 0 is provided.
    pub port: u16,
    /// Arguments provided to the `lldpd` cli command.
    pub args: Vec<String>,
    /// Child process spawned by running `lldpd`
    pub child: Option<tokio::process::Child>,
    /// Temporary directory where logging output and other files generated by
    /// `lldpd` are stored.
    pub data_dir: Option<PathBuf>,
}

impl LldpdInstance {
    pub async fn start(
        mut port: u16,
        dpd_port: u16,
        mgs_address: Option<SocketAddr>,
    ) -> Result<Self, anyhow::Error> {
        let temp_dir = TempDir::new()?;
        let listen_addr =
            SocketAddr::new(IpAddr::V6(Ipv6Addr::LOCALHOST), port);

        let mut args = vec![
            "run".to_string(),
            "--listen-addr".into(),
            listen_addr.to_string(),
            "--port".to_string(),
            dpd_port.to_string(),
        ];

        if let Some(socket_addr) = mgs_address {
            args.push("--mgs-addr".to_string());
            args.push(socket_addr.to_string());
        }

        let child = tokio::process::Command::new("lldpd")
            .args(&args)
            .stdin(Stdio::null())
            .stdout(Stdio::from(redirect_file(
                temp_dir.path(),
                "lldpd_stdout",
            )?))
            .stderr(Stdio::from(redirect_file(
                temp_dir.path(),
                "lldpd_stderr",
            )?))
            .spawn()
            .with_context(|| {
                format!("failed to spawn `lldpd` (with args: {:?})", &args)
            })?;

        let child = Some(child);

        let temp_dir = temp_dir.keep();
        if port == 0 {
            port = discover_port(
                temp_dir.join("lldpd_stdout").display().to_string(),
            )
            .await
            .with_context(|| {
                format!(
                    "failed to discover lldpd port from files in {}",
                    temp_dir.display()
                )
            })?;
        }

        Ok(Self { port, args, child, data_dir: Some(temp_dir) })
    }

    pub async fn cleanup(&mut self) -> Result<(), anyhow::Error> {
        if let Some(mut child) = self.child.take() {
            child.start_kill().context("Sending SIGKILL to child")?;
            child.wait().await.context("waiting for child")?;
        }
        if let Some(dir) = self.data_dir.take() {
            std::fs::remove_dir_all(&dir).with_context(|| {
                format!("cleaning up temporary directory {}", dir.display())
            })?;
        }
        Ok(())
    }
}

impl Drop for LldpdInstance {
    fn drop(&mut self) {
        if self.child.is_some() || self.data_dir.is_some() {
            eprintln!(
                "WARN: dropped LldpdInstance without cleaning it up first \
                (there may still be a child process running and a \
                temporary directory leaked)"
            );
            if let Some(child) = self.child.as_mut() {
                let _ = child.start_kill();
            }
            if let Some(path) = self.data_dir.take() {
                eprintln!(
                    "WARN: lldpd temporary directory leaked: {}",
                    path.display()
                );
            }
        }
    }
}

fn redirect_file(
    temp_dir_path: &Path,
    label: &str,
) -> Result<std::fs::File, anyhow::Error> {
    let out_path = temp_dir_path.join(label);
    std::fs::OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(&out_path)
        .with_context(|| format!("open \"{}\"", out_path.display()))
}

async fn discover_port(logfile: String) -> Result<u16, anyhow::Error> {
    let timeout = Instant::now() + LLDPD_TIMEOUT;
    tokio::time::timeout_at(timeout, find_lldpd_port_in_log(logfile))
        .await
        .context("time out while discovering lldpd port number")?
}

async fn find_lldpd_port_in_log(logfile: String) -> Result<u16, anyhow::Error> {
    let re = regex::Regex::new(r#""local_addr":"\[::1?\]:([0-9]+)""#).unwrap();
    let mut reader = BufReader::new(File::open(&logfile).await?);
    let mut lines = reader.lines();
    loop {
        match lines.next_line().await? {
            Some(line) => {
                if let Some(cap) = re.captures(&line) {
                    // unwrap on get(1) should be ok, since captures() returns
                    // `None` if there are no matches found
                    let port = cap.get(1).unwrap();
                    let result = port.as_str().parse::<u16>()?;
                    return Ok(result);
                }
            }
            None => {
                sleep(Duration::from_millis(10)).await;

                // We might have gotten a partial line; close the file, reopen
                // it, and start reading again from the beginning.
                reader = BufReader::new(File::open(&logfile).await?);
                lines = reader.lines();
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::find_lldpd_port_in_log;
    use std::io::Write;
    use std::process::Stdio;
    use tempfile::NamedTempFile;

    const EXPECTED_PORT: u16 = 12230;

    #[tokio::test]
    async fn test_lldpd_in_path() {
        // With no arguments, we expect to see the default help message.
        tokio::process::Command::new("lldpd")
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .spawn()
            .expect("Cannot find 'lldpd' on PATH. Refer to README.md for installation instructions");
    }

    #[tokio::test]
    async fn test_discover_local_listening_port() {
        // Write some data to a fake log file
        // This line is representative of the kind of output that lldpd currently logs
        let line = r#"{"msg":"listening","v":0,"name":"lldpd","level":30,"time":"2025-12-23T00:07:09.226947807Z","hostname":"sled03","pid":10187,"local_addr":"[::]:12230","server_id":
"1","unit":"api-server"}"#;
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "A garbage line").unwrap();
        writeln!(file, "{}", line).unwrap();
        writeln!(file, "Another garbage line").unwrap();
        file.flush().unwrap();

        assert_eq!(
            find_lldpd_port_in_log(file.path().display().to_string())
                .await
                .unwrap(),
            EXPECTED_PORT
        );
    }
}
