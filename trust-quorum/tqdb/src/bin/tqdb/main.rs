// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! The Trust Quorum Debugger
//!
//! Capable of executing and stepping through event streams generated by
//! trust quorum proptests.

use anyhow::{Context, bail};
use camino::Utf8PathBuf;
use clap::{Args, Parser, Subcommand};
use daft::Diffable;
use omicron_repl_utils::run_repl_on_stdin_customized;
use reconfigurator_cli::LogCapture;
use reedline::{
    ColumnarMenu, DefaultCompleter, DefaultPrompt, DefaultPromptSegment, Emacs,
    FileBackedHistory, KeyCode, KeyModifiers, MenuBuilder, Reedline,
    ReedlineEvent, default_emacs_keybindings,
};
use slog::{Logger, o};
use std::collections::{BTreeMap, BTreeSet};
use std::fmt::Write;
use std::fs;
use std::io::IsTerminal;
use tabled::Tabled;
use trust_quorum_protocol::BaseboardId;
use trust_quorum_test_utils::{Event, TqState};

fn main() -> Result<(), anyhow::Error> {
    let repl = TqdbRepl {};
    repl.exec()
}

/// Internal debugger state
pub struct Tqdb {
    event_log_path: Option<Utf8PathBuf>,

    events: Vec<Event>,

    // Current state of the trust-quorum
    current_state: TqState,

    // Index of the next event to be applied
    next_event: usize,

    // All set breakpoints at log event index
    breakpoints: BTreeSet<usize>,

    // All snapshots ever taken.
    //
    // Snapshots are taken automatically when a breakpoint is hit.
    snapshots: BTreeMap<usize, TqState>,

    // Snapshot requests for events that haven't yet been applied
    pending_snapshots: BTreeSet<usize>,
}

impl Tqdb {
    pub fn new(log: &Logger) -> Self {
        let log = log.new(o!("component" => "tqdb"));
        Tqdb {
            event_log_path: None,
            events: vec![],
            current_state: TqState::new(log),
            next_event: 0,
            breakpoints: BTreeSet::new(),
            snapshots: BTreeMap::new(),
            pending_snapshots: BTreeSet::new(),
        }
    }

    pub fn reset_state(&mut self) {
        let Tqdb {
            event_log_path,
            events,
            current_state,
            next_event,
            breakpoints,
            snapshots,
            pending_snapshots,
        } = self;
        let log = current_state.log.clone();

        *event_log_path = None;
        *events = vec![];
        *current_state = TqState::new(log);
        *next_event = 0;
        *breakpoints = BTreeSet::new();
        *snapshots = BTreeMap::new();
        *pending_snapshots = BTreeSet::new();
    }

    pub fn toggle_breakpoint(&mut self, index: usize) -> anyhow::Result<bool> {
        if index >= self.events.len() {
            bail!(
                "Invalid event index: {index}. Only {} total events.",
                self.events.len()
            );
        }
        if !self.breakpoints.remove(&index) {
            let _ = self.breakpoints.insert(index);
            Ok(true)
        } else {
            Ok(false)
        }
    }

    // Reset the state to the beginning of time
    //
    // Don't remove any breakpoints, snapshots, or pending snapshots
    pub fn rewind(&mut self) {
        let Tqdb {
            event_log_path: _,
            events: _,
            current_state,
            next_event,
            breakpoints: _,
            snapshots: _,
            pending_snapshots: _,
        } = self;

        *current_state = TqState::new(current_state.log.clone());
        *next_event = 0;
    }

    pub fn breakpoints(&self) -> &BTreeSet<usize> {
        &self.breakpoints
    }

    pub fn maybe_snapshot(&mut self) {
        if self.next_event == 0 {
            return;
        }
        let curr_event = self.next_event - 1;
        if self.pending_snapshots.remove(&curr_event) {
            self.snapshots.insert(curr_event, self.current_state.clone());
        }
    }
}

/// Interactive REPL for our trust quorum debugger
pub struct TqdbRepl {}

impl TqdbRepl {
    /// Execute the command.
    pub fn exec(self) -> anyhow::Result<()> {
        let (log_capture, log) =
            LogCapture::new(std::io::stdout().is_terminal());

        let mut tqdb = Tqdb::new(&log);

        let mut completer = Box::new(DefaultCompleter::with_inclusions(&['-']));
        completer.insert(Self::commands());
        let completion_menu =
            Box::new(ColumnarMenu::default().with_name("commands"));
        let mut keybindings = default_emacs_keybindings();
        keybindings.add_binding(
            KeyModifiers::NONE,
            KeyCode::Tab,
            ReedlineEvent::UntilFound(vec![
                ReedlineEvent::Menu("commands".to_string()),
                ReedlineEvent::MenuNext,
            ]),
        );
        let edit_mode = Box::new(Emacs::new(keybindings));

        let history = Box::new(
            FileBackedHistory::with_file(
                10000,
                "/tmp/.tqdb-history.txt".into(),
            )
            .expect("Error configuring history with file"),
        );

        let ed = Reedline::create()
            .with_history(history)
            .with_completer(completer)
            .with_menu(reedline::ReedlineMenu::EngineCompleter(completion_menu))
            .with_edit_mode(edit_mode);

        let prompt = DefaultPrompt::new(
            DefaultPromptSegment::Basic("tqdb".into()),
            DefaultPromptSegment::Empty,
        );

        run_repl_on_stdin_customized(ed, &prompt, &mut |cmd: TopLevelArgs| {
            process_command(&mut tqdb, cmd, &log_capture)
        })
    }

    // Update this with each new subcommand
    fn commands() -> Vec<String> {
        // This assignment and match exists soley to ensure we update our list
        // when we add or remove a command.
        let c = Commands::Run;
        match c {
            Commands::Open { .. }
            | Commands::Run
            | Commands::Step { .. }
            | Commands::BreakpointToggle { .. }
            | Commands::BreakpointList
            | Commands::Snapshot { .. }
            | Commands::SnapshotList
            | Commands::SnapshotListPending
            | Commands::SnapshotShow { .. }
            | Commands::Diff { .. }
            | Commands::NodeShow { .. }
            | Commands::Rewind
            | Commands::Events(_)
            | Commands::Show
            | Commands::Summary => {}
        }

        [
            "open",
            "run",
            "step",
            "breakpoint-toggle",
            "breakpoint-list",
            "snapshot",
            "snapshot-list",
            "snapshot-list-pending",
            "snapshot-show",
            "diff",
            "node-show",
            "rewind",
            "events",
            "show",
            "summary",
        ]
        .into_iter()
        .map(Into::into)
        .collect()
    }
}

/// Arguments for our debugger REPL
#[derive(Parser, Debug)]
struct TopLevelArgs {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Subcommand)]
enum Commands {
    // open event log file
    #[clap(alias = "o")]
    Open {
        /// path to the event log file
        path: Utf8PathBuf,
    },
    // apply all events until completion or a breakpoint
    #[clap(alias = "r")]
    Run,
    /// step over n events by applying them
    ///
    /// This command steps over breakpoints. Use `run` if you want to stop at
    /// breakpoints.
    #[clap(alias = "s")]
    Step {
        /// number of events to apply, 1 if not given
        num_events: Option<usize>,
    },

    /// toggle a breakpoint at a given event
    #[clap(alias = "b")]
    BreakpointToggle {
        /// index of the event in the log to apply the breakpoint to
        index: usize,
    },
    /// display all existing breakpoints
    BreakpointList,

    /// take a snapshot of the current state, or at the given event when reached
    Snapshot {
        /// index of the event to take snapshot
        index: Option<usize>,
    },
    /// display all existing snapshots
    SnapshotList,
    /// show a snapshot for the given event
    SnapshotShow {
        /// index of the event where the snapshot was taken
        index: usize,
    },
    /// list all pending snapshots
    SnapshotListPending,

    /// show the difference between the current state and the snapshot
    /// or two snapshots if two indexes are given
    #[clap(alias = "d")]
    Diff {
        /// The event log index of where the snapshot was taken
        snapshot1: usize,

        /// An optional second snapshot index
        snapshot2: Option<usize>,
    },

    /// display the current state of a SUT node and its context
    NodeShow {
        /// The serial number of the node  to print.
        /// Print all state if not present.
        serial: usize,
    },

    /// Reset the state to the beginning of the trace
    ///
    /// This does not remove breakpoints or pending snapshots
    Rewind,

    /// show the full state of the system
    Show,

    /// print an overview of the current state of the system
    Summary,

    /// display log entries - next entry by default
    Events(EventsArgs),
}

#[derive(Debug, Args)]
struct EventsArgs {
    #[clap(subcommand)]
    command: Option<EventsCommand>,
}

#[derive(Debug, Subcommand)]
pub enum EventsCommand {
    All,
    Next { num_events: usize },
    Range { start: usize, end: usize },
}

/// Processes one "line" of user input.
fn process_command(
    tqdb: &mut Tqdb,
    cmd: TopLevelArgs,
    logs: &LogCapture,
) -> anyhow::Result<Option<String>> {
    let TopLevelArgs { command } = cmd;
    let cmd_result = match command {
        Commands::Open { path } => cmd_open(tqdb, path),
        Commands::Run {} => cmd_run(tqdb),
        Commands::Step { num_events } => cmd_step(tqdb, num_events),
        Commands::BreakpointToggle { index } => {
            cmd_toggle_breakpoint(tqdb, index)
        }
        Commands::BreakpointList {} => cmd_breakpoint_list(tqdb),
        Commands::Diff { snapshot1, snapshot2 } => {
            cmd_diff(tqdb, snapshot1, snapshot2)
        }
        Commands::Snapshot { index } => cmd_snapshot(tqdb, index),
        Commands::SnapshotList {} => cmd_snapshot_list(tqdb),
        Commands::SnapshotListPending => cmd_snapshot_list_pending(tqdb),
        Commands::SnapshotShow { index } => cmd_snapshot_show(tqdb, index),
        Commands::NodeShow { serial } => cmd_node_show(tqdb, serial),
        Commands::Rewind => cmd_rewind(tqdb),
        Commands::Show => cmd_show(tqdb),
        Commands::Events(args) => cmd_log_show(tqdb, args),
        Commands::Summary {} => cmd_summary(tqdb),
    };

    for line in logs.take_log_lines() {
        println!("{line}");
    }

    cmd_result
}

/// Open an event log file for debugging
fn cmd_open(
    tqdb: &mut Tqdb,
    path: Utf8PathBuf,
) -> anyhow::Result<Option<String>> {
    tqdb.reset_state();
    let json = fs::read_to_string(&path).context(path.clone())?;
    let events: Vec<Event> = serde_json::from_str(&json)
        .context("failed to deserialize event log")?;
    tqdb.event_log_path = Some(path.clone());
    tqdb.events = events;
    Ok(Some(format!("loaded event log: {path}\n{} events.", tqdb.events.len())))
}

/// Apply all events until completion or a breakpoint
fn cmd_run(tqdb: &mut Tqdb) -> anyhow::Result<Option<String>> {
    if tqdb.event_log_path.is_none() {
        bail!("please open an event log file");
    }

    let mut num_events = 0;
    if tqdb.next_event < tqdb.events.len() {
        let end = tqdb
            .breakpoints
            .iter()
            .cloned()
            .find(|&i| i > tqdb.next_event)
            .unwrap_or(tqdb.events.len());
        let events: Vec<_> = tqdb.events[tqdb.next_event..end].to_vec();
        for event in events {
            tqdb.current_state.apply_event(event);
            num_events += 1;
            tqdb.next_event += 1;
            tqdb.maybe_snapshot();
        }
    }

    let output = if tqdb.next_event == tqdb.events.len() {
        format!("done: applied {} events", num_events)
    } else {
        format!(
            "stopped at breakpoint {} after applying {} events",
            tqdb.next_event, num_events
        )
    };
    Ok(Some(output))
}

// Step through each event by applying them
fn cmd_step(
    tqdb: &mut Tqdb,
    num_events: Option<usize>,
) -> anyhow::Result<Option<String>> {
    if tqdb.event_log_path.is_none() {
        bail!("please open an event log file");
    }

    let num_events = num_events.unwrap_or(1);

    let end = tqdb.next_event + num_events;
    if end > tqdb.events.len() {
        bail!("Number of events to step exceeds remaining events");
    }

    let mut s = String::new();
    let mut applied_events = 0;
    let events: Vec<_> = tqdb.events[tqdb.next_event..end].to_vec();
    for event in events {
        writeln!(&mut s, "{}  {event:#?}", tqdb.next_event)?;
        tqdb.current_state.apply_event(event.clone());
        applied_events += 1;
        tqdb.next_event += 1;
        tqdb.maybe_snapshot();
    }
    writeln!(&mut s, "done: applied {} events", applied_events)?;
    Ok(Some(s))
}

fn cmd_toggle_breakpoint(
    tqdb: &mut Tqdb,
    index: usize,
) -> anyhow::Result<Option<String>> {
    let output = if tqdb.toggle_breakpoint(index)? {
        format!("breakpoint set at event {index}")
    } else {
        format!("breakpoint removed at event {index}")
    };
    Ok(Some(output))
}

fn cmd_breakpoint_list(tqdb: &mut Tqdb) -> anyhow::Result<Option<String>> {
    #[derive(Tabled)]
    #[tabled(rename_all = "SCREAMING_SNAKE_CASE")]
    struct Breakpoint {
        index: usize,
        event: String,
    }

    let rows = tqdb.breakpoints.iter().map(|i| Breakpoint {
        index: *i,
        event: format!("{:#?}", tqdb.events[*i]),
    });

    let table = tabled::Table::new(rows)
        .with(tabled::settings::Style::empty())
        .with(tabled::settings::Padding::new(0, 1, 0, 0))
        .to_string();
    Ok(Some(table))
}

fn cmd_snapshot_list(tqdb: &mut Tqdb) -> anyhow::Result<Option<String>> {
    let output = if tqdb.snapshots.is_empty() {
        "no snapshots present".to_string()
    } else {
        let mut s = String::new();
        writeln!(&mut s, "Snapshot indexes: ")?;
        for i in tqdb.snapshots.keys() {
            writeln!(&mut s, "{i}  ")?;
        }
        s
    };
    Ok(Some(output))
}

fn cmd_snapshot_list_pending(
    tqdb: &mut Tqdb,
) -> anyhow::Result<Option<String>> {
    let output = if tqdb.pending_snapshots.is_empty() {
        "no snapshots pending".to_string()
    } else {
        let mut s = String::new();
        writeln!(&mut s, "pending snapshot indexes: ")?;
        for i in &tqdb.pending_snapshots {
            writeln!(&mut s, "{i}  ")?;
        }
        s
    };
    Ok(Some(output))
}

fn cmd_snapshot(
    tqdb: &mut Tqdb,
    index: Option<usize>,
) -> anyhow::Result<Option<String>> {
    if tqdb.event_log_path.is_none() {
        bail!("please open an event log file");
    }

    if tqdb.next_event == 0 && index.is_none() {
        bail!("please apply an event to generate a useful state");
    }

    let output = if let Some(index) = index {
        if index < tqdb.next_event {
            tqdb.pending_snapshots.insert(index);
            "Setting pending snapshot.\n
                Already applied event however.
                Use 'rewind' to start over."
                .to_string()
        } else if index > tqdb.events.len() {
            bail!(
                "index out of bounds. Only {} total events.",
                tqdb.events.len()
            );
        } else {
            tqdb.pending_snapshots.insert(index);
            "Setting pending snapshot".to_string()
        }
    } else {
        tqdb.snapshots.insert(
            tqdb.next_event.checked_sub(1).unwrap(),
            tqdb.current_state.clone(),
        );
        "Taking snapshot at current state".to_string()
    };

    Ok(Some(output))
}

fn cmd_snapshot_show(
    tqdb: &mut Tqdb,
    index: usize,
) -> anyhow::Result<Option<String>> {
    match tqdb.snapshots.get(&index) {
        Some(s) => Ok(Some(format!("{s:#?}"))),
        None => bail!("no such snapshot"),
    }
}

fn cmd_diff(
    tqdb: &mut Tqdb,
    snapshot1: usize,
    snapshot2: Option<usize>,
) -> anyhow::Result<Option<String>> {
    if tqdb.event_log_path.is_none() {
        bail!("please open an event log file");
    }

    if snapshot2.is_none() && tqdb.next_event == 0 {
        bail!("please apply an event to get a useful state to diff with");
    }

    let Some(s1) = tqdb.snapshots.get(&snapshot1) else {
        bail!("snapshot at {snapshot1} doesn't exist");
    };
    let diff = match snapshot2 {
        Some(snapshot2) => {
            let Some(s2) = tqdb.snapshots.get(&snapshot2) else {
                bail!("snapshot at {snapshot2} doesn't exist");
            };
            if snapshot1 < snapshot2 { s1.diff(s2) } else { s2.diff(s1) }
        }
        None => {
            if snapshot1 < tqdb.next_event {
                s1.diff(&tqdb.current_state)
            } else {
                tqdb.current_state.diff(&s1)
            }
        }
    };
    Ok(Some(format!("{diff}")))
}

fn cmd_show(tqdb: &Tqdb) -> anyhow::Result<Option<String>> {
    if tqdb.event_log_path.is_none() {
        bail!("please open an event log file");
    }
    Ok(Some(format!("{:#?}", tqdb.current_state)))
}

fn cmd_node_show(
    tqdb: &mut Tqdb,
    serial: usize,
) -> anyhow::Result<Option<String>> {
    let id = BaseboardId {
        part_number: "test".into(),
        serial_number: serial.to_string(),
    };
    let Some((node, ctx)) = tqdb.current_state.sut.nodes.get(&id) else {
        bail!("failed to load node: {id}");
    };

    Ok(Some(format!("{node:#?}\n{ctx:#?}")))
}

fn cmd_rewind(tqdb: &mut Tqdb) -> anyhow::Result<Option<String>> {
    tqdb.rewind();

    let mut s = String::new();
    writeln!(&mut s, "Re-initialized state and set next-event to 0")?;
    writeln!(&mut s, "Breakpoints, Snapshots, and pending snapshots remain")?;

    Ok(Some(s))
}

fn cmd_log_show(
    tqdb: &Tqdb,
    args: EventsArgs,
) -> anyhow::Result<Option<String>> {
    if tqdb.events.is_empty() {
        bail!("no events loaded. Please call 'open' on a valid file");
    }

    // Find the possible start and end range of events
    let (start, end) = match args.command {
        Some(EventsCommand::All) => (0, tqdb.events.len()),
        Some(EventsCommand::Next { num_events }) => {
            (tqdb.next_event, tqdb.next_event + num_events)
        }
        Some(EventsCommand::Range { start, end }) => (start, end),
        None => (tqdb.next_event, tqdb.next_event + 1),
    };

    let mut s = String::new();
    if start == tqdb.events.len() {
        writeln!(&mut s, "finished applying events")?;
    } else {
        let end = usize::min(end, tqdb.events.len());
        for i in start..end {
            writeln!(&mut s, "{i}  {:#?}", tqdb.events[i])?;
        }
    }

    Ok(Some(s))
}

fn cmd_summary(tqdb: &mut Tqdb) -> anyhow::Result<Option<String>> {
    let mut s = String::new();
    if let Some(path) = &tqdb.event_log_path {
        writeln!(&mut s, "event log path: {:?}", path)?;
        writeln!(&mut s, "total events in log: {}", tqdb.events.len())?;
    } else {
        bail!("no event log loaded: Please call 'open'");
    }
    if tqdb.next_event != tqdb.events.len() {
        writeln!(&mut s, "next event to apply: {}", tqdb.next_event)?;
        writeln!(&mut s, "    {:#?}", tqdb.events[tqdb.next_event])?;
    } else {
        writeln!(&mut s, "finished applying events")?;
    }

    writeln!(
        &mut s,
        "total nodes under test: {}",
        tqdb.current_state.sut.nodes.len()
    )?;
    let total_bootstrap_msgs = tqdb
        .current_state
        .bootstrap_network
        .iter()
        .fold(0, |acc, (_, e)| acc + e.len());
    writeln!(
        &mut s,
        "bootstrap network messages in flight: {}",
        total_bootstrap_msgs
    )?;

    if tqdb.next_event > 0 {
        let latest_config = tqdb.current_state.nexus.latest_config();
        writeln!(&mut s, "nexus config: ")?;
        writeln!(&mut s, "    epoch: {}", latest_config.epoch)?;
        writeln!(&mut s, "    op: {:?}", latest_config.op)?;
        writeln!(
            &mut s,
            "    coordinator: {}",
            latest_config.coordinator.serial_number
        )?;
        writeln!(&mut s, "    total members: {}", latest_config.members.len())?;
        writeln!(
            &mut s,
            "    prepared members: {}",
            latest_config.prepared_members.len()
        )?;
        writeln!(
            &mut s,
            "    committed members: {}",
            latest_config.committed_members.len()
        )?;
        writeln!(&mut s, "    threshold: {}", latest_config.threshold.0)?;
        writeln!(
            &mut s,
            "    commit crash tolerance: {}",
            latest_config.commit_crash_tolerance
        )?;
    }

    Ok(Some(s))
}
