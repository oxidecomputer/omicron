// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2023 Oxide Computer Company

//! Progress, success and failure events generated by the update engine.
//!
//! Events are serializable and implement `JsonSchema`, so that they can be
//! transmitted over the wire.

use std::{borrow::Cow, time::Duration};

use derive_where::derive_where;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_with::rust::deserialize_ignore_any;

use crate::StepSpec;

#[derive_where(Debug)]
pub enum Event<S: StepSpec> {
    Step(StepEvent<S>),
    Progress(ProgressEvent<S>),
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
pub struct StepEvent<S: StepSpec> {
    /// Total time elapsed since the start of execution.
    pub total_elapsed: Duration,

    /// The kind of event this is.
    #[serde(rename = "data")]
    pub kind: StepEventKind<S>,
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
pub enum StepEventKind<S: StepSpec> {
    /// No steps were defined, and the executor exited without doing anything.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    NoStepsDefined,

    /// Execution was started.
    ///
    /// This is an initial event -- it is always expected to be the first event
    /// received from the event stream.
    ExecutionStarted {
        /// The list of steps that will be executed.
        steps: Vec<StepInfo<S>>,

        /// A list of components, along with the number of items each component has.
        components: Vec<StepComponentSummary<S>>,

        /// Information about the first step.
        first_step: StepInfoWithMetadata<S>,
    },

    /// Progress was reset along an attempt, and this attempt is going down a
    /// different path.
    ProgressReset {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The current attempt number.
        attempt: usize,

        /// Progress-related metadata associated with this attempt.
        metadata: S::ProgressMetadata,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The amount of time this attempt has taken so far.
        attempt_elapsed: Duration,

        /// A message assocaited with the reset.
        message: Cow<'static, str>,
    },

    /// An attempt failed and this step is being retried.
    AttemptRetry {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number for the next attempt.
        next_attempt: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The amount of time the previous attempt took.
        attempt_elapsed: Duration,

        /// A message associated with the retry.
        message: Cow<'static, str>,
    },

    /// A step is complete and the next step has been started.
    StepCompleted {
        /// Information about the step that just completed.
        step: StepInfoWithMetadata<S>,

        /// The attempt number that completed.
        attempt: usize,

        /// The outcome of the step.
        outcome: StepOutcome<S>,

        /// The next step that is being started.
        next_step: StepInfoWithMetadata<S>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Execution is complete.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionCompleted {
        /// Information about the last step that completed.
        last_step: StepInfoWithMetadata<S>,

        /// The attempt number that completed.
        last_attempt: usize,

        /// The outcome of the last step.
        last_outcome: StepOutcome<S>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Execution failed.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionFailed {
        /// Information about the step that failed.
        failed_step: StepInfoWithMetadata<S>,

        /// The total number of attempts that were performed before the step failed.
        total_attempts: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,

        /// A message associated with the failure.
        message: String,

        /// A chain of causes associated with the failure.
        causes: Vec<String>,
    },

    /// Future variants that might be unknown.
    #[serde(other, deserialize_with = "deserialize_ignore_any")]
    Unknown,
}

impl<S: StepSpec> StepEventKind<S> {
    /// Returns the priority of the event.
    ///
    /// For more about this, see [`StepEventPriority`].
    pub fn priority(&self) -> StepEventPriority {
        match self {
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionStarted { .. }
            | StepEventKind::StepCompleted { .. }
            | StepEventKind::ExecutionCompleted { .. }
            | StepEventKind::ExecutionFailed { .. } => StepEventPriority::High,
            StepEventKind::ProgressReset { .. }
            | StepEventKind::AttemptRetry { .. }
            | StepEventKind::Unknown => StepEventPriority::Low,
        }
    }
}

/// The priority of a [`StepEvent`].
///
/// Returned by [`StepEventKind::priority`].
///
/// Some [`StepEvent`]s have a higher priority than others. For example, events
/// related to step successes and failures must be delivered, while events
/// related to retries can be trimmed down since they are overall less
/// important.
#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord)]
pub enum StepEventPriority {
    /// A low-priority event.
    ///
    /// Includes retry, reset, and unknown events.
    Low,

    /// A high-priority event.
    ///
    /// Includes successes, failures, and terminal events.
    High,
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
pub enum StepOutcome<S: StepSpec> {
    /// The step completed successfully.
    Success {
        /// Completion metadata associated with the step.
        metadata: S::CompletionMetadata,
    },

    /// The step completed with a warning.
    Warning {
        /// Completion metadata associated with the step.
        metadata: S::CompletionMetadata,

        /// A warning message.
        message: Cow<'static, str>,
    },

    /// The step was skipped with a message.
    Skipped {
        /// Skipped metadata associated with the step.
        metadata: S::SkippedMetadata,

        /// Metadata associated with the step.
        message: Cow<'static, str>,
    },
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
pub struct ProgressEvent<S: StepSpec> {
    /// Total time elapsed since the start of execution.
    pub total_elapsed: Duration,

    /// The kind of event this is.
    #[serde(rename = "data")]
    pub kind: ProgressEventKind<S>,
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
pub enum ProgressEventKind<S: StepSpec> {
    Progress {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// Metadata that was returned with progress.
        metadata: S::ProgressMetadata,

        /// Current progress.
        progress: Option<ProgressCounter>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// Total time elapsed since the start of the attempt.
        attempt_elapsed: Duration,
    },

    /// Future variants that might be unknown.
    #[serde(other, deserialize_with = "deserialize_ignore_any")]
    Unknown,
}

/// Serializable information about a step.
#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
pub struct StepInfo<S: StepSpec> {
    /// An identifier for this step.
    pub id: S::StepId,

    /// The component that this step is part of.
    pub component: S::Component,

    /// The description for this step.
    pub description: Cow<'static, str>,

    /// The index of the step within all steps to be executed.
    pub index: usize,

    /// The index of the step within the component.
    pub component_index: usize,

    /// The total number of steps in this component.
    pub total_component_steps: usize,
}

impl<S: StepSpec> StepInfo<S> {
    /// Returns true if this is the last step in this component.
    pub fn is_last_step_in_component(&self) -> bool {
        self.component_index + 1 == self.total_component_steps
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
pub struct StepComponentSummary<S: StepSpec> {
    /// The component.
    pub component: S::Component,

    /// The number of steps present in this component.
    pub total_component_steps: usize,
}

/// Serializable information about a step.
#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
pub struct StepInfoWithMetadata<S: StepSpec> {
    /// Information about this step.
    pub info: StepInfo<S>,

    /// Additional metadata associated with this step.
    pub metadata: Option<S::StepMetadata>,
}

/// Current progress.
///
/// Both `current` and `total` are abstract counters. These counters are often a
/// number of bytes. There is no guarantee that the counter won't go back in
/// subsequent events; that can happen e.g. if a fetch happens from multiple
/// peers within a single attempt.
#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ProgressCounter {
    pub current: u64,
    pub total: Option<u64>,
}

impl ProgressCounter {
    /// Creates a new `ProgressCounter` with current and total values.
    #[inline]
    pub fn new(current: u64, total: u64) -> Self {
        Self { current, total: Some(total) }
    }

    /// Creates a new `ProgressCounter` with just a current value.
    #[inline]
    pub fn current(current: u64) -> Self {
        Self { current, total: None }
    }
}

#[derive_where(Clone, Debug, Eq, PartialEq)]
pub enum StepProgress<S: StepSpec> {
    /// A step has progressed.
    Progress {
        /// Current progress.
        progress: Option<ProgressCounter>,

        /// Metadata associated with progress.
        metadata: S::ProgressMetadata,
    },

    /// Progress was reset: typically, the step failed along one path, and the
    /// step is now trying a different path.
    ///
    /// For example, downloading from one peer failed and we've moved to the
    /// next peer.
    Reset {
        /// Metadata associated with the reset.
        metadata: S::ProgressMetadata,

        /// A message associated with the reset.
        message: Cow<'static, str>,
    },

    /// The step is being retried from the beginning.
    Retry {
        /// An optional message associated with the retry.
        message: Cow<'static, str>,
    },
}

impl<S: StepSpec> StepProgress<S> {
    /// Creates a new progress message with current and total values.
    pub fn with_current_and_total(
        current: u64,
        total: u64,
        metadata: S::ProgressMetadata,
    ) -> Self {
        Self::Progress {
            progress: Some(ProgressCounter { current, total: Some(total) }),
            metadata,
        }
    }

    /// Creates a new progress message with a current value.
    pub fn with_current(current: u64, metadata: S::ProgressMetadata) -> Self {
        Self::Progress {
            progress: Some(ProgressCounter { current, total: None }),
            metadata,
        }
    }

    /// Creates a new progress message without either current or total values.
    pub fn progress(metadata: S::ProgressMetadata) -> Self {
        Self::Progress { progress: None, metadata }
    }

    /// Creats a new reset message.
    pub fn reset(
        metadata: S::ProgressMetadata,
        message: impl Into<Cow<'static, str>>,
    ) -> Self {
        Self::Reset { metadata, message: message.into() }
    }

    /// Creates a new retry message.
    pub fn retry(message: impl Into<Cow<'static, str>>) -> Self {
        Self::Retry { message: message.into() }
    }
}

#[cfg(test)]
mod tests {
    use omicron_test_utils::dev::test_setup_log;

    use crate::test_utils::TestSpec;

    use super::*;

    #[test]
    fn step_event_parse_unknown() {
        let logctx = test_setup_log("step_event_parse_unknown");
        let tests = [
            (
                r#"
                  {
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "unknown_variant",
                      "last_step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "last_attempt": 1,
                      "last_outcome": {
                        "kind": "success",
                        "metadata": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      }
                    }
                  }
                "#,
                StepEvent {
                    total_elapsed: Duration::ZERO,
                    kind: StepEventKind::Unknown,
                },
            ),
            (
                r#"
                  {
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "execution_completed",
                      "last_step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "last_attempt": 1,
                      "last_outcome": {
                        "kind": "success",
                        "metadata": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "unknown_field": 123
                    }
                  }
                "#,
                StepEvent::<TestSpec> {
                    total_elapsed: Duration::ZERO,
                    kind: StepEventKind::ExecutionCompleted {
                        last_step: StepInfoWithMetadata {
                            info: StepInfo {
                                id: 0,
                                component: "foo".to_owned(),
                                description: "Description".into(),
                                index: 0,
                                component_index: 0,
                                total_component_steps: 1,
                            },
                            metadata: None,
                        },
                        last_attempt: 1,
                        last_outcome: StepOutcome::Success {
                            metadata: serde_json::Value::Null,
                        },
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                },
            ),
        ];

        for (index, (input, expected)) in tests.into_iter().enumerate() {
            let serialized = serde_json::to_string_pretty(&expected).unwrap();
            slog::info!(
                logctx.log,
                "for index {index}, serialized: {serialized}"
            );

            let actual: StepEvent<TestSpec> = serde_json::from_str(input)
                .unwrap_or_else(|error| {
                    panic!("index {index}: unknown variant deserialized correctly: {error}")
                });
            assert_eq!(expected, actual, "input matches actual output");
        }

        logctx.cleanup_successful();
    }

    #[test]
    fn progress_event_parse_unknown() {
        let logctx = test_setup_log("progress_event_parse_unknown");
        let tests = [
            (
                r#"
                  {
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "unknown_variant",
                      "step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "attempt": 1,
                      "metadata": null,
                      "progress": {
                        "current": 123,
                        "total": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      }
                    }
                  }
                "#,
                ProgressEvent {
                    total_elapsed: Duration::ZERO,
                    kind: ProgressEventKind::Unknown,
                },
            ),
            (
                r#"
                  {
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "progress",
                      "step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "attempt": 1,
                      "metadata": null,
                      "progress": {
                        "current": 123,
                        "total": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "unknown_field": 123
                    }
                  }
                "#,
                ProgressEvent::<TestSpec> {
                    total_elapsed: Duration::ZERO,
                    kind: ProgressEventKind::Progress {
                        step: StepInfoWithMetadata {
                            info: StepInfo {
                                id: 0,
                                component: "foo".to_owned(),
                                description: "Description".into(),
                                index: 0,
                                component_index: 0,
                                total_component_steps: 1,
                            },
                            metadata: None,
                        },
                        attempt: 1,
                        metadata: serde_json::Value::Null,
                        progress: Some(ProgressCounter::current(123)),
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                },
            ),
        ];

        for (index, (input, expected)) in tests.into_iter().enumerate() {
            let serialized = serde_json::to_string_pretty(&expected).unwrap();
            slog::info!(
                logctx.log,
                "for index {index}, serialized: {serialized}"
            );

            let actual: ProgressEvent<TestSpec> = serde_json::from_str(input)
                .unwrap_or_else(|error| {
                    panic!("index {index}: unknown variant deserialized correctly: {error}")
                });
            assert_eq!(expected, actual, "input matches actual output");
        }

        logctx.cleanup_successful();
    }
}
