// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2023 Oxide Computer Company

//! Progress, success and failure events generated by the update engine.
//!
//! Events are serializable and implement `JsonSchema`, so that they can be
//! transmitted over the wire.

use std::{borrow::Cow, fmt, time::Duration};

use derive_where::derive_where;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_with::rust::deserialize_ignore_any;

use crate::{
    errors::ConvertGenericError, AsError, ExecutionId, GenericSpec, NestedSpec,
    StepSpec,
};

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Event<S: StepSpec> {
    Step(StepEvent<S>),
    Progress(ProgressEvent<S>),
}

impl<S: StepSpec> Event<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: Event<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            Event::Step(event) => Event::Step(StepEvent::from_generic(event)?),
            Event::Progress(event) => {
                Event::Progress(ProgressEvent::from_generic(event)?)
            }
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> Event<GenericSpec<E>> {
        match self {
            Event::Step(event) => Event::Step(event.into_generic()),
            Event::Progress(event) => Event::Progress(event.into_generic()),
        }
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepEventFor{S}")]
pub struct StepEvent<S: StepSpec> {
    /// The specification that this event belongs to.
    ///
    /// This is typically the name of the type `S` for which `StepSpec` is
    /// implemented.
    ///
    /// This can be used along with `Self::from_generic` to identify which
    /// specification to deserialize generic metadata against. For example:
    ///
    /// ```rust,ignore
    /// if event.spec == "MySpec" {
    ///     // event is likely generated from a MySpec engine.
    ///     let event = Event::<MySpec>::from_generic(event)?;
    ///     // ...
    /// }
    /// ```
    pub spec: String,

    /// The execution ID.
    pub execution_id: ExecutionId,

    /// A monotonically increasing index for this `StepEvent`.
    pub event_index: usize,

    /// Total time elapsed since the start of execution.
    pub total_elapsed: Duration,

    /// The kind of event this is.
    #[serde(rename = "data")]
    pub kind: StepEventKind<S>,
}

impl<S: StepSpec> StepEvent<S> {
    /// Returns a progress event associated with this step event, if any.
    ///
    /// Some step events have an implicit progress event of kind
    /// [`ProgressEventKind::WaitingForProgress`] associated with them. This
    /// causes those step events to generate progress events.
    pub fn progress_event(&self) -> Option<ProgressEvent<S>> {
        match &self.kind {
            StepEventKind::ExecutionStarted { first_step, .. } => {
                Some(ProgressEvent {
                    spec: self.spec.clone(),
                    execution_id: self.execution_id,
                    total_elapsed: self.total_elapsed,
                    kind: ProgressEventKind::WaitingForProgress {
                        step: first_step.clone(),
                        attempt: 1,
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                })
            }
            StepEventKind::ProgressReset {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
                ..
            } => Some(ProgressEvent {
                spec: self.spec.clone(),
                execution_id: self.execution_id,
                total_elapsed: self.total_elapsed,
                kind: ProgressEventKind::WaitingForProgress {
                    step: step.clone(),
                    attempt: *attempt,
                    step_elapsed: *step_elapsed,
                    attempt_elapsed: *attempt_elapsed,
                },
            }),
            StepEventKind::AttemptRetry {
                step,
                next_attempt,
                step_elapsed,
                ..
            } => Some(ProgressEvent {
                spec: self.spec.clone(),
                execution_id: self.execution_id,
                total_elapsed: self.total_elapsed,
                kind: ProgressEventKind::WaitingForProgress {
                    step: step.clone(),
                    attempt: *next_attempt,
                    step_elapsed: *step_elapsed,
                    // For this attempt, zero time has passed so far.
                    attempt_elapsed: Duration::ZERO,
                },
            }),
            StepEventKind::StepCompleted { next_step, .. } => {
                Some(ProgressEvent {
                    spec: self.spec.clone(),
                    execution_id: self.execution_id,
                    total_elapsed: self.total_elapsed,
                    kind: ProgressEventKind::WaitingForProgress {
                        step: next_step.clone(),
                        attempt: 1,
                        // For this next step, zero time has passed so far.
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                })
            }
            StepEventKind::Nested {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
                event,
                ..
            } => event.progress_event().map(|progress_event| ProgressEvent {
                spec: self.spec.clone(),
                execution_id: self.execution_id,
                total_elapsed: self.total_elapsed,
                kind: ProgressEventKind::Nested {
                    step: step.clone(),
                    attempt: *attempt,
                    event: Box::new(progress_event),
                    step_elapsed: *step_elapsed,
                    attempt_elapsed: *attempt_elapsed,
                },
            }),
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionCompleted { .. }
            | StepEventKind::ExecutionFailed { .. }
            | StepEventKind::ExecutionAborted { .. }
            | StepEventKind::Unknown => None,
        }
    }

    /// Returns the execution ID for the leaf event, recursing into nested
    /// events if necessary.
    pub fn leaf_execution_id(&self) -> ExecutionId {
        match &self.kind {
            StepEventKind::Nested { event, .. } => event.leaf_execution_id(),
            _ => self.execution_id,
        }
    }

    /// Returns the event index for the leaf event, recursing into nested events
    /// if necessary.
    pub fn leaf_event_index(&self) -> usize {
        match &self.kind {
            StepEventKind::Nested { event, .. } => event.leaf_event_index(),
            _ => self.event_index,
        }
    }

    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepEvent<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(StepEvent {
            spec: value.spec,
            execution_id: value.execution_id,
            event_index: value.event_index,
            total_elapsed: value.total_elapsed,
            kind: StepEventKind::from_generic(value.kind)
                .map_err(|error| error.parent("kind"))?,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> StepEvent<GenericSpec<E>> {
        StepEvent {
            spec: self.spec,
            execution_id: self.execution_id,
            event_index: self.event_index,
            total_elapsed: self.total_elapsed,
            kind: self.kind.into_generic(),
        }
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
#[schemars(rename = "StepEventKindFor{S}")]
pub enum StepEventKind<S: StepSpec> {
    /// No steps were defined, and the executor exited without doing anything.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    NoStepsDefined,

    /// Execution was started.
    ///
    /// This is an initial event -- it is always expected to be the first event
    /// received from the event stream.
    ExecutionStarted {
        /// The list of steps that will be executed.
        steps: Vec<StepInfo<S>>,

        /// A list of components, along with the number of items each component has.
        components: Vec<StepComponentSummary<S>>,

        /// Information about the first step.
        first_step: StepInfoWithMetadata<S>,
    },

    /// Progress was reset along an attempt, and this attempt is going down a
    /// different path.
    ProgressReset {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The current attempt number.
        attempt: usize,

        /// Progress-related metadata associated with this attempt.
        metadata: S::ProgressMetadata,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The amount of time this attempt has taken so far.
        attempt_elapsed: Duration,

        /// A message assocaited with the reset.
        message: Cow<'static, str>,
    },

    /// An attempt failed and this step is being retried.
    AttemptRetry {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number for the next attempt.
        next_attempt: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The amount of time the previous attempt took.
        attempt_elapsed: Duration,

        /// A message associated with the retry.
        message: Cow<'static, str>,
    },

    /// A step is complete and the next step has been started.
    StepCompleted {
        /// Information about the step that just completed.
        step: StepInfoWithMetadata<S>,

        /// The attempt number that completed.
        attempt: usize,

        /// The outcome of the step.
        outcome: StepOutcome<S>,

        /// The next step that is being started.
        next_step: StepInfoWithMetadata<S>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Execution is complete.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionCompleted {
        /// Information about the last step that completed.
        last_step: StepInfoWithMetadata<S>,

        /// The attempt number that completed.
        last_attempt: usize,

        /// The outcome of the last step.
        last_outcome: StepOutcome<S>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Execution failed.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionFailed {
        /// Information about the step that failed.
        failed_step: StepInfoWithMetadata<S>,

        /// The total number of attempts that were performed before the step failed.
        total_attempts: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,

        /// A message associated with the failure.
        message: String,

        /// A chain of causes associated with the failure.
        causes: Vec<String>,
    },

    /// Execution aborted by an external user.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionAborted {
        /// Information about the step that was running at the time execution
        /// was aborted.
        aborted_step: StepInfoWithMetadata<S>,

        /// The attempt that was running at the time the step was aborted.
        attempt: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,

        /// A message associated with the abort.
        message: String,
    },

    /// A nested step event occurred.
    Nested {
        /// Information about the step that's occurring.
        step: StepInfoWithMetadata<S>,

        /// The current attempt number.
        attempt: usize,

        /// The event that occurred.
        event: Box<StepEvent<NestedSpec>>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Future variants that might be unknown.
    #[serde(other, deserialize_with = "deserialize_ignore_any")]
    Unknown,
}

impl<S: StepSpec> StepEventKind<S> {
    /// Returns whether this is a terminal step event.
    ///
    /// Terminal events guarantee that there are no further events coming from
    /// this update engine.
    ///
    /// This does not recurse into nested events; those are always non-terminal.
    pub fn is_terminal(&self) -> StepEventIsTerminal {
        match self {
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionCompleted { .. } => {
                StepEventIsTerminal::Terminal { success: true }
            }
            StepEventKind::ExecutionFailed { .. }
            | StepEventKind::ExecutionAborted { .. } => {
                StepEventIsTerminal::Terminal { success: false }
            }
            StepEventKind::ExecutionStarted { .. }
            | StepEventKind::ProgressReset { .. }
            | StepEventKind::AttemptRetry { .. }
            | StepEventKind::StepCompleted { .. }
            | StepEventKind::Nested { .. }
            | StepEventKind::Unknown => StepEventIsTerminal::NonTerminal,
        }
    }

    /// Returns the priority of the event.
    ///
    /// For more about this, see [`StepEventPriority`].
    pub fn priority(&self) -> StepEventPriority {
        match self {
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionStarted { .. }
            | StepEventKind::StepCompleted { .. }
            | StepEventKind::ExecutionCompleted { .. }
            | StepEventKind::ExecutionFailed { .. }
            | StepEventKind::ExecutionAborted { .. } => StepEventPriority::High,
            StepEventKind::ProgressReset { .. }
            | StepEventKind::AttemptRetry { .. }
            | StepEventKind::Unknown => StepEventPriority::Low,
            StepEventKind::Nested { event, .. } => event.kind.priority(),
        }
    }

    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepEventKind<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            StepEventKind::NoStepsDefined => StepEventKind::NoStepsDefined,
            StepEventKind::ExecutionStarted {
                steps,
                components,
                first_step,
            } => StepEventKind::ExecutionStarted {
                steps: steps
                    .into_iter()
                    .enumerate()
                    .map(|(index, step)| {
                        StepInfo::from_generic(step)
                            .map_err(|error| error.parent_array("steps", index))
                    })
                    .collect::<Result<Vec<_>, _>>()?,
                components: components
                    .into_iter()
                    .enumerate()
                    .map(|(index, component)| {
                        StepComponentSummary::from_generic(component).map_err(
                            |error| error.parent_array("components", index),
                        )
                    })
                    .collect::<Result<Vec<_>, _>>()?,
                first_step: StepInfoWithMetadata::from_generic(first_step)
                    .map_err(|error| error.parent("first_step"))?,
            },
            StepEventKind::ProgressReset {
                step,
                attempt,
                metadata,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::ProgressReset {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                metadata: serde_json::from_value(metadata).map_err(
                    |error| ConvertGenericError::new("metadata", error),
                )?,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::AttemptRetry {
                step,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::AttemptRetry {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::StepCompleted {
                step,
                attempt,
                outcome,
                next_step,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::StepCompleted {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                outcome: StepOutcome::from_generic(outcome)
                    .map_err(|error| error.parent("outcome"))?,
                next_step: StepInfoWithMetadata::from_generic(next_step)
                    .map_err(|error| error.parent("next_step"))?,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionCompleted {
                last_step,
                last_attempt,
                last_outcome,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::ExecutionCompleted {
                last_step: StepInfoWithMetadata::from_generic(last_step)
                    .map_err(|error| error.parent("last_step"))?,
                last_attempt,
                last_outcome: StepOutcome::from_generic(last_outcome)
                    .map_err(|error| error.parent("last_outcome"))?,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionFailed {
                failed_step,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            } => StepEventKind::ExecutionFailed {
                failed_step: StepInfoWithMetadata::from_generic(failed_step)
                    .map_err(|error| error.parent("failed_step"))?,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            },
            StepEventKind::ExecutionAborted {
                aborted_step,
                attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::ExecutionAborted {
                aborted_step: StepInfoWithMetadata::from_generic(aborted_step)
                    .map_err(|error| error.parent("aborted_step"))?,
                attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::Nested {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::Unknown => StepEventKind::Unknown,
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> StepEventKind<GenericSpec<E>> {
        match self {
            StepEventKind::NoStepsDefined => StepEventKind::NoStepsDefined,
            StepEventKind::ExecutionStarted {
                steps,
                components,
                first_step,
            } => StepEventKind::ExecutionStarted {
                steps: steps
                    .into_iter()
                    .map(|step| step.into_generic())
                    .collect(),
                components: components
                    .into_iter()
                    .map(|component| component.into_generic())
                    .collect(),
                first_step: first_step.into_generic(),
            },
            StepEventKind::ProgressReset {
                step,
                attempt,
                metadata,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::ProgressReset {
                step: step.into_generic(),
                attempt,
                metadata: serde_json::to_value(metadata)
                    .unwrap_or_else(|_| serde_json::Value::Null),
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::AttemptRetry {
                step,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::AttemptRetry {
                step: step.into_generic(),
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::StepCompleted {
                step,
                attempt,
                outcome,
                next_step,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::StepCompleted {
                step: step.into_generic(),
                attempt,
                outcome: outcome.into_generic(),
                next_step: next_step.into_generic(),
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionCompleted {
                last_step,
                last_attempt,
                last_outcome,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::ExecutionCompleted {
                last_step: last_step.into_generic(),
                last_attempt,
                last_outcome: last_outcome.into_generic(),
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionFailed {
                failed_step,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            } => StepEventKind::ExecutionFailed {
                failed_step: failed_step.into_generic(),
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            },
            StepEventKind::ExecutionAborted {
                aborted_step,
                attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::ExecutionAborted {
                aborted_step: aborted_step.into_generic(),
                attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::Nested {
                step: step.into_generic(),
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::Unknown => StepEventKind::Unknown,
        }
    }

    /// If this represents a successfully-completed step, returns the outcome.
    ///
    /// This does not recurse into nested events.
    pub fn step_outcome(&self) -> Option<&StepOutcome<S>> {
        match self {
            StepEventKind::StepCompleted { outcome, .. }
            | StepEventKind::ExecutionCompleted {
                last_outcome: outcome, ..
            } => Some(outcome),
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionStarted { .. }
            | StepEventKind::ProgressReset { .. }
            | StepEventKind::AttemptRetry { .. }
            | StepEventKind::ExecutionFailed { .. }
            | StepEventKind::ExecutionAborted { .. }
            | StepEventKind::Nested { .. }
            | StepEventKind::Unknown => None,
        }
    }
}

/// Whether a [`StepEvent`] is a terminal event.
///
/// Returned by [`StepEventKind::is_terminal`].
///
/// The update engine guarantees that after a terminal event is seen, no further
/// events are seen.
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum StepEventIsTerminal {
    /// This is not a terminal event.
    NonTerminal,

    /// This is a terminal event.
    Terminal {
        /// True if execution completed successfully.
        success: bool,
    },
}

/// The priority of a [`StepEvent`].
///
/// Returned by [`StepEventKind::priority`].
///
/// Some [`StepEvent`]s have a higher priority than others. For example, events
/// related to step successes and failures must be delivered, while events
/// related to retries can be trimmed down since they are overall less
/// important.
///
/// More precisely, a high-priority event is an event which cannot be dropped if
/// an [`EventBuffer`](crate::EventBuffer) is to work correctly. Low-priority
/// events can be dropped.
#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord)]
pub enum StepEventPriority {
    /// A low-priority event.
    ///
    /// Includes retry, reset, and unknown events.
    Low,

    /// A high-priority event.
    ///
    /// Includes successes, failures, and terminal events.
    High,
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
#[schemars(rename = "StepOutcomeFor{S}")]
pub enum StepOutcome<S: StepSpec> {
    /// The step completed successfully.
    Success {
        /// An optional message associated with this step.
        message: Option<Cow<'static, str>>,

        /// Optional completion metadata associated with the step.
        metadata: Option<S::CompletionMetadata>,
    },

    /// The step completed with a warning.
    Warning {
        /// A warning message.
        message: Cow<'static, str>,

        /// Optional completion metadata associated with the step.
        metadata: Option<S::CompletionMetadata>,
    },

    /// The step was skipped with a message.
    Skipped {
        /// Message associated with the skip.
        message: Cow<'static, str>,

        /// Optional metadata associated with the skip.
        metadata: Option<S::SkippedMetadata>,
    },
}

impl<S: StepSpec> StepOutcome<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepOutcome<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            StepOutcome::Success { message, metadata } => {
                StepOutcome::Success {
                    message,
                    metadata: metadata
                        .map(|metadata| {
                            serde_json::from_value(metadata).map_err(|error| {
                                ConvertGenericError::new("metadata", error)
                            })
                        })
                        .transpose()?,
                }
            }
            StepOutcome::Warning { message, metadata } => {
                StepOutcome::Warning {
                    message,
                    metadata: metadata
                        .map(|metadata| {
                            serde_json::from_value(metadata).map_err(|error| {
                                ConvertGenericError::new("metadata", error)
                            })
                        })
                        .transpose()?,
                }
            }
            StepOutcome::Skipped { message, metadata } => {
                StepOutcome::Skipped {
                    message,
                    metadata: metadata
                        .map(|metadata| {
                            serde_json::from_value(metadata).map_err(|error| {
                                ConvertGenericError::new("metadata", error)
                            })
                        })
                        .transpose()?,
                }
            }
        };
        Ok(ret)
    }

    /// If this outcome represents completion, returns the metadata associated
    /// with this event.
    ///
    /// Returns `None` if this outcome represents "skipped".
    pub fn completion_metadata(&self) -> Option<&S::CompletionMetadata> {
        match self {
            StepOutcome::Success { metadata, .. }
            | StepOutcome::Warning { metadata, .. } => metadata.as_ref(),
            StepOutcome::Skipped { .. } => None,
        }
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> StepOutcome<GenericSpec<E>> {
        match self {
            StepOutcome::Success { message, metadata } => {
                StepOutcome::Success {
                    message,
                    metadata: metadata.map(|metadata| {
                        serde_json::to_value(metadata)
                            .unwrap_or_else(|_| serde_json::Value::Null)
                    }),
                }
            }
            StepOutcome::Warning { metadata, message } => {
                StepOutcome::Warning {
                    message,
                    metadata: metadata.map(|metadata| {
                        serde_json::to_value(metadata)
                            .unwrap_or_else(|_| serde_json::Value::Null)
                    }),
                }
            }
            StepOutcome::Skipped { metadata, message } => {
                StepOutcome::Skipped {
                    message,
                    metadata: metadata.map(|metadata| {
                        serde_json::to_value(metadata)
                            .unwrap_or_else(|_| serde_json::Value::Null)
                    }),
                }
            }
        }
    }

    /// Returns true if the step was successful, including success with
    /// warning.
    pub fn is_success_or_warning(&self) -> bool {
        match self {
            Self::Success { .. } | Self::Warning { .. } => true,
            Self::Skipped { .. } => false,
        }
    }

    /// Returns true if the step was skipped.
    pub fn is_skipped(&self) -> bool {
        match self {
            Self::Skipped { .. } => true,
            Self::Success { .. } | Self::Warning { .. } => false,
        }
    }

    /// Returns the message associated with this outcome, if one exists.
    pub fn message(&self) -> Option<&Cow<'static, str>> {
        match self {
            StepOutcome::Success { message, .. } => message.as_ref(),
            StepOutcome::Warning { message, .. }
            | StepOutcome::Skipped { message, .. } => Some(message),
        }
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "ProgressEventFor{S}")]
pub struct ProgressEvent<S: StepSpec> {
    /// The specification that this event belongs to.
    ///
    /// This is typically the name of the type `S` for which `StepSpec` is
    /// implemented.
    ///
    /// This can be used with `Self::from_generic` to deserialize generic
    /// metadata.
    pub spec: String,

    /// The execution ID.
    pub execution_id: ExecutionId,

    /// Total time elapsed since the start of execution.
    pub total_elapsed: Duration,

    /// The kind of event this is.
    #[serde(rename = "data")]
    pub kind: ProgressEventKind<S>,
}

impl<S: StepSpec> ProgressEvent<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: ProgressEvent<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            spec: value.spec,
            execution_id: value.execution_id,
            total_elapsed: value.total_elapsed,
            kind: ProgressEventKind::from_generic(value.kind)
                .map_err(|error| error.parent("kind"))?,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> ProgressEvent<GenericSpec<E>> {
        ProgressEvent {
            spec: self.spec,
            execution_id: self.execution_id,
            total_elapsed: self.total_elapsed,
            kind: self.kind.into_generic(),
        }
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
#[schemars(rename = "ProgressEventKindFor{S}")]
pub enum ProgressEventKind<S: StepSpec> {
    /// The update engine is waiting for a progress message.
    ///
    /// The update engine sends this message immediately after a [`StepEvent`]
    /// corresponding to a new step.
    WaitingForProgress {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// Total time elapsed since the start of the attempt.
        attempt_elapsed: Duration,
    },

    Progress {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// Metadata that was returned with progress.
        metadata: S::ProgressMetadata,

        /// Current progress.
        progress: Option<ProgressCounter>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// Total time elapsed since the start of the attempt.
        attempt_elapsed: Duration,
    },

    Nested {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// The event that occurred.
        event: Box<ProgressEvent<NestedSpec>>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Future variants that might be unknown.
    #[serde(other, deserialize_with = "deserialize_ignore_any")]
    Unknown,
}

impl<S: StepSpec> ProgressEventKind<S> {
    /// Returns the progress counter for this event, if available.
    pub fn progress_counter(&self) -> Option<&ProgressCounter> {
        match self {
            ProgressEventKind::Progress { progress, .. } => progress.as_ref(),
            ProgressEventKind::Nested { event, .. } => {
                event.kind.progress_counter()
            }
            ProgressEventKind::WaitingForProgress { .. }
            | ProgressEventKind::Unknown => None,
        }
    }

    /// Returns `attempt` for the leaf event, recursing into nested events as
    /// necessary.
    ///
    /// Returns None for unknown events.
    pub fn leaf_attempt(&self) -> Option<usize> {
        match self {
            ProgressEventKind::WaitingForProgress { attempt, .. }
            | ProgressEventKind::Progress { attempt, .. } => Some(*attempt),
            ProgressEventKind::Nested { event, .. } => {
                event.kind.leaf_attempt()
            }
            ProgressEventKind::Unknown => None,
        }
    }

    /// Returns `step_elapsed` for the leaf event, recursing into nested events
    /// as necessary.
    ///
    /// Returns None for unknown events.
    pub fn leaf_step_elapsed(&self) -> Option<Duration> {
        match self {
            ProgressEventKind::WaitingForProgress { step_elapsed, .. }
            | ProgressEventKind::Progress { step_elapsed, .. } => {
                Some(*step_elapsed)
            }
            ProgressEventKind::Nested { event, .. } => {
                event.kind.leaf_step_elapsed()
            }
            ProgressEventKind::Unknown => None,
        }
    }

    /// Returns `attempt_elapsed` for the leaf event, recursing into nested
    /// events as necessary.
    ///
    /// Returns None for unknown events.
    pub fn leaf_attempt_elapsed(&self) -> Option<Duration> {
        match self {
            ProgressEventKind::WaitingForProgress {
                attempt_elapsed, ..
            }
            | ProgressEventKind::Progress { attempt_elapsed, .. } => {
                Some(*attempt_elapsed)
            }
            ProgressEventKind::Nested { event, .. } => {
                event.kind.leaf_attempt_elapsed()
            }
            ProgressEventKind::Unknown => None,
        }
    }

    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: ProgressEventKind<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            ProgressEventKind::WaitingForProgress {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::WaitingForProgress {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Progress {
                step,
                attempt,
                metadata,
                progress,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Progress {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                metadata: serde_json::from_value(metadata).map_err(
                    |error| ConvertGenericError::new("metadata", error),
                )?,
                progress,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Nested {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Unknown => todo!(),
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> ProgressEventKind<GenericSpec<E>> {
        match self {
            ProgressEventKind::WaitingForProgress {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::WaitingForProgress {
                step: step.into_generic(),
                attempt,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Progress {
                step,
                attempt,
                metadata,
                progress,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Progress {
                step: step.into_generic(),
                attempt,
                metadata: serde_json::to_value(metadata)
                    .unwrap_or_else(|_| serde_json::Value::Null),
                progress,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Nested {
                step: step.into_generic(),
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Unknown => todo!(),
        }
    }
}

/// Serializable information about a step.
#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepInfoFor{S}")]
pub struct StepInfo<S: StepSpec> {
    /// An identifier for this step.
    pub id: S::StepId,

    /// The component that this step is part of.
    pub component: S::Component,

    /// The description for this step.
    pub description: Cow<'static, str>,

    /// The index of the step within all steps to be executed.
    pub index: usize,

    /// The index of the step within the component.
    pub component_index: usize,

    /// The total number of steps in this component.
    pub total_component_steps: usize,
}

impl<S: StepSpec> StepInfo<S> {
    /// Returns true if this is the last step in this component.
    pub fn is_last_step_in_component(&self) -> bool {
        self.component_index + 1 == self.total_component_steps
    }

    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepInfo<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            id: serde_json::from_value(value.id)
                .map_err(|error| ConvertGenericError::new("id", error))?,
            component: serde_json::from_value(value.component).map_err(
                |error| ConvertGenericError::new("component", error),
            )?,
            description: value.description,
            index: value.index,
            component_index: value.component_index,
            total_component_steps: value.total_component_steps,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> StepInfo<GenericSpec<E>> {
        StepInfo {
            id: serde_json::to_value(self.id)
                .unwrap_or_else(|_| serde_json::Value::Null),
            component: serde_json::to_value(self.component)
                .unwrap_or_else(|_| serde_json::Value::Null),
            description: self.description,
            index: self.index,
            component_index: self.component_index,
            total_component_steps: self.total_component_steps,
        }
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepComponentSummaryFor{S}")]
pub struct StepComponentSummary<S: StepSpec> {
    /// The component.
    pub component: S::Component,

    /// The number of steps present in this component.
    pub total_component_steps: usize,
}

impl<S: StepSpec> StepComponentSummary<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepComponentSummary<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            component: serde_json::from_value(value.component).map_err(
                |error| ConvertGenericError::new("component", error),
            )?,
            total_component_steps: value.total_component_steps,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(
        self,
    ) -> StepComponentSummary<GenericSpec<E>> {
        StepComponentSummary {
            component: serde_json::to_value(self.component)
                .unwrap_or_else(|_| serde_json::Value::Null),
            total_component_steps: self.total_component_steps,
        }
    }
}

/// Serializable information about a step.
#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepInfoWithMetadataFor{S}")]
pub struct StepInfoWithMetadata<S: StepSpec> {
    /// Information about this step.
    pub info: StepInfo<S>,

    /// Additional metadata associated with this step.
    pub metadata: Option<S::StepMetadata>,
}

impl<S: StepSpec> StepInfoWithMetadata<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepInfoWithMetadata<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            info: StepInfo::from_generic(value.info)
                .map_err(|error| error.parent("info"))?,
            metadata: value
                .metadata
                .map(|metadata| {
                    serde_json::from_value(metadata).map_err(|error| {
                        ConvertGenericError::new("metadata", error)
                    })
                })
                .transpose()?,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(
        self,
    ) -> StepInfoWithMetadata<GenericSpec<E>> {
        StepInfoWithMetadata {
            info: self.info.into_generic(),
            metadata: self.metadata.map(|metadata| {
                serde_json::to_value(metadata)
                    .unwrap_or_else(|_| serde_json::Value::Null)
            }),
        }
    }
}

/// Current progress.
///
/// Both `current` and `total` are abstract counters. These counters are often a
/// number of bytes. There is no guarantee that the counter won't go back in
/// subsequent events; that can happen e.g. if a fetch happens from multiple
/// peers within a single attempt.
#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ProgressCounter {
    /// The current progress.
    pub current: u64,

    /// The total progress.
    pub total: Option<u64>,

    /// Progress units.
    pub units: ProgressUnits,
}

impl ProgressCounter {
    /// Creates a new `ProgressCounter` with current and total values.
    #[inline]
    pub fn new(
        current: u64,
        total: u64,
        units: impl Into<ProgressUnits>,
    ) -> Self {
        Self { current, total: Some(total), units: units.into() }
    }

    /// Creates a new `ProgressCounter` with just a current value.
    #[inline]
    pub fn current(current: u64, units: impl Into<ProgressUnits>) -> Self {
        Self { current, total: None, units: units.into() }
    }
}

#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize, JsonSchema)]
#[serde(transparent)]
pub struct ProgressUnits(pub Cow<'static, str>);

impl ProgressUnits {
    /// Creates a new `ProgressUnits`.
    pub fn new(s: impl Into<Cow<'static, str>>) -> Self {
        Self(s.into())
    }

    /// Creates a new `ProgressUnits` from a static string.
    pub const fn new_const(s: &'static str) -> Self {
        Self(Cow::Borrowed(s))
    }

    /// Units in terms of bytes.
    ///
    /// Some displayers might display bytes in terms of KiB, MiB etc.
    pub const BYTES: Self = Self::new_const("bytes");
}

impl AsRef<str> for ProgressUnits {
    fn as_ref(&self) -> &str {
        self.0.as_ref()
    }
}

impl fmt::Display for ProgressUnits {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_ref())
    }
}

impl<T> From<T> for ProgressUnits
where
    T: Into<Cow<'static, str>>,
{
    fn from(value: T) -> Self {
        Self(value.into())
    }
}

#[derive_where(Clone, Debug, Eq, PartialEq)]
pub enum StepProgress<S: StepSpec> {
    /// A step has progressed.
    Progress {
        /// Current progress.
        progress: Option<ProgressCounter>,

        /// Metadata associated with progress.
        metadata: S::ProgressMetadata,
    },

    /// Progress was reset: typically, the step failed along one path, and the
    /// step is now trying a different path.
    ///
    /// For example, downloading from one peer failed and we've moved to the
    /// next peer.
    Reset {
        /// Metadata associated with the reset.
        metadata: S::ProgressMetadata,

        /// A message associated with the reset.
        message: Cow<'static, str>,
    },

    /// The step is being retried from the beginning.
    Retry {
        /// An optional message associated with the retry.
        message: Cow<'static, str>,
    },
}

impl<S: StepSpec> StepProgress<S> {
    /// Creates a new progress message with current and total values.
    pub fn with_current_and_total(
        current: u64,
        total: u64,
        units: impl Into<ProgressUnits>,
        metadata: S::ProgressMetadata,
    ) -> Self {
        Self::Progress {
            progress: Some(ProgressCounter {
                current,
                total: Some(total),
                units: units.into(),
            }),
            metadata,
        }
    }

    /// Creates a new progress message with a current value.
    pub fn with_current(
        current: u64,
        units: impl Into<ProgressUnits>,
        metadata: S::ProgressMetadata,
    ) -> Self {
        Self::Progress {
            progress: Some(ProgressCounter {
                current,
                total: None,
                units: units.into(),
            }),
            metadata,
        }
    }

    /// Creates a new progress message without either current or total values.
    pub fn progress(metadata: S::ProgressMetadata) -> Self {
        Self::Progress { progress: None, metadata }
    }

    /// Creats a new reset message.
    pub fn reset(
        metadata: S::ProgressMetadata,
        message: impl Into<Cow<'static, str>>,
    ) -> Self {
        Self::Reset { metadata, message: message.into() }
    }

    /// Creates a new retry message.
    pub fn retry(message: impl Into<Cow<'static, str>>) -> Self {
        Self::Retry { message: message.into() }
    }
}

/// A report produced from an [`EventBuffer`](crate::EventBuffer).
///
/// Remote reports can be passed into a [`StepContext`](crate::StepContext),
/// in which case they show up as nested events.
#[derive_where(Clone, Debug, Default, Eq, PartialEq)]
#[derive(Deserialize, Serialize, JsonSchema)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "EventReportFor{S}")]
pub struct EventReport<S: StepSpec> {
    /// A list of step events.
    ///
    /// Step events include success and failure events.
    pub step_events: Vec<StepEvent<S>>,

    /// A list of progress events, or whether we're currently waiting for a
    /// progress event.
    ///
    /// Currently, this produces one progress event for each top-level and
    /// nested event in progress.
    pub progress_events: Vec<ProgressEvent<S>>,

    /// The root execution ID for this report.
    ///
    /// Each report has a root execution ID, which ties together all step and
    /// progress events. This is always filled out if the list of step events is
    /// non-empty.
    pub root_execution_id: Option<ExecutionId>,

    /// The last event seen.
    ///
    /// `last_seen` can be used to retrieve deltas of events.
    pub last_seen: Option<usize>,
}

impl<S: StepSpec> EventReport<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: EventReport<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            step_events: value
                .step_events
                .into_iter()
                .enumerate()
                .map(|(index, event)| {
                    StepEvent::from_generic(event).map_err(|error| {
                        error.parent_array("step_events", index)
                    })
                })
                .collect::<Result<Vec<_>, _>>()?,
            progress_events: value
                .progress_events
                .into_iter()
                .enumerate()
                .map(|(index, event)| {
                    ProgressEvent::from_generic(event).map_err(|error| {
                        error.parent_array("progress_events", index)
                    })
                })
                .collect::<Result<Vec<_>, _>>()?,
            root_execution_id: value.root_execution_id,
            last_seen: value.last_seen,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of
    /// engines.
    ///
    /// If any of the data in self fails to serialize to a
    /// [`serde_json::Value`], it will be replaced with
    /// [`serde_json::Value::Null`]. Since `serde_json::Value` represents
    /// an arbitrary JSON value, such data would have failed to serialize
    /// anyway.
    pub fn into_generic<E: AsError>(self) -> EventReport<GenericSpec<E>> {
        EventReport {
            step_events: self
                .step_events
                .into_iter()
                .map(|event| event.into_generic())
                .collect(),
            progress_events: self
                .progress_events
                .into_iter()
                .map(|event| event.into_generic())
                .collect(),
            root_execution_id: self.root_execution_id,
            last_seen: self.last_seen,
        }
    }
}

#[cfg(test)]
mod tests {
    use omicron_test_utils::dev::test_setup_log;

    use crate::test_utils::*;

    use super::*;

    #[test]
    fn step_event_parse_unknown() {
        let logctx = test_setup_log("step_event_parse_unknown");
        let execution_id = test_execution_id();
        let tests = [
            (
                r#"
                  {
                    "spec": "TestSpec",
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "event_index": 0,
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "unknown_variant",
                      "last_step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "last_attempt": 1,
                      "last_outcome": {
                        "kind": "success",
                        "metadata": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      }
                    }
                  }
                "#,
                StepEvent {
                    spec: TestSpec::schema_name(),
                    execution_id,
                    event_index: 0,
                    total_elapsed: Duration::ZERO,
                    kind: StepEventKind::Unknown,
                },
            ),
            (
                r#"
                  {
                    "spec": "TestSpec",
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "event_index": 1,
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "execution_completed",
                      "last_step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "last_attempt": 1,
                      "last_outcome": {
                        "kind": "success",
                        "message": null,
                        "metadata": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "unknown_field": 123
                    }
                  }
                "#,
                StepEvent::<TestSpec> {
                    spec: TestSpec::schema_name(),
                    execution_id,
                    event_index: 1,
                    total_elapsed: Duration::ZERO,
                    kind: StepEventKind::ExecutionCompleted {
                        last_step: StepInfoWithMetadata {
                            info: StepInfo {
                                id: 0,
                                component: "foo".to_owned(),
                                description: "Description".into(),
                                index: 0,
                                component_index: 0,
                                total_component_steps: 1,
                            },
                            metadata: None,
                        },
                        last_attempt: 1,
                        last_outcome: StepOutcome::Success {
                            message: None,
                            metadata: None,
                        },
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                },
            ),
        ];

        for (index, (input, expected)) in tests.into_iter().enumerate() {
            let serialized = serde_json::to_string_pretty(&expected).unwrap();
            slog::info!(
                logctx.log,
                "for index {index}, serialized: {serialized}"
            );

            let actual: StepEvent<TestSpec> = serde_json::from_str(input)
                .unwrap_or_else(|error| {
                    panic!("index {index}: unknown variant deserialized correctly: {error}")
                });
            assert_eq!(expected, actual, "input matches actual output");
        }

        logctx.cleanup_successful();
    }

    #[test]
    fn progress_event_parse_unknown() {
        let logctx = test_setup_log("progress_event_parse_unknown");
        let execution_id = test_execution_id();

        let tests = [
            (
                r#"
                  {
                    "spec": "TestSpec",
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "unknown_variant",
                      "step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "attempt": 1,
                      "metadata": null,
                      "progress": {
                        "current": 123,
                        "total": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      }
                    }
                  }
                "#,
                ProgressEvent {
                    spec: TestSpec::schema_name(),
                    execution_id,
                    total_elapsed: Duration::ZERO,
                    kind: ProgressEventKind::Unknown,
                },
            ),
            (
                r#"
                  {
                    "spec": "TestSpec",
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "progress",
                      "step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "attempt": 1,
                      "metadata": null,
                      "progress": {
                        "current": 123,
                        "total": null,
                        "units": "bytes"
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "unknown_field": 123
                    }
                  }
                "#,
                ProgressEvent::<TestSpec> {
                    spec: TestSpec::schema_name(),
                    execution_id,
                    total_elapsed: Duration::ZERO,
                    kind: ProgressEventKind::Progress {
                        step: StepInfoWithMetadata {
                            info: StepInfo {
                                id: 0,
                                component: "foo".to_owned(),
                                description: "Description".into(),
                                index: 0,
                                component_index: 0,
                                total_component_steps: 1,
                            },
                            metadata: None,
                        },
                        attempt: 1,
                        metadata: serde_json::Value::Null,
                        progress: Some(ProgressCounter::current(
                            123,
                            ProgressUnits::BYTES,
                        )),
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                },
            ),
        ];

        for (index, (input, expected)) in tests.into_iter().enumerate() {
            let serialized = serde_json::to_string_pretty(&expected).unwrap();
            slog::info!(
                logctx.log,
                "for index {index}, serialized: {serialized}"
            );

            let actual: ProgressEvent<TestSpec> = serde_json::from_str(input)
                .unwrap_or_else(|error| {
                    panic!("index {index}: unknown variant deserialized correctly: {error}")
                });
            assert_eq!(expected, actual, "input matches actual output");
        }

        logctx.cleanup_successful();
    }
}
