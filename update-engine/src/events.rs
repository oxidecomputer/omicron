// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Copyright 2023 Oxide Computer Company

//! Progress, success and failure events generated by the update engine.
//!
//! Events are serializable and implement `JsonSchema`, so that they can be
//! transmitted over the wire.

use std::{borrow::Cow, time::Duration};

use derive_where::derive_where;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_with::rust::deserialize_ignore_any;

use crate::{
    errors::ConvertGenericError, AsError, ExecutionId, GenericSpec, NestedSpec,
    StepSpec,
};

#[derive_where(Debug)]
pub enum Event<S: StepSpec> {
    Step(StepEvent<S>),
    Progress(ProgressEvent<S>),
}

impl<S: StepSpec> Event<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: Event<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            Event::Step(event) => Event::Step(StepEvent::from_generic(event)?),
            Event::Progress(event) => {
                Event::Progress(ProgressEvent::from_generic(event)?)
            }
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<Event<GenericSpec<E>>, ConvertGenericError> {
        let ret = match self {
            Event::Step(event) => Event::Step(event.into_generic()?),
            Event::Progress(event) => Event::Progress(event.into_generic()?),
        };
        Ok(ret)
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepEventFor{S}")]
pub struct StepEvent<S: StepSpec> {
    /// The execution ID.
    pub execution_id: ExecutionId,

    /// A monotonically increasing index for this `StepEvent`.
    pub event_index: usize,

    /// Total time elapsed since the start of execution.
    pub total_elapsed: Duration,

    /// The kind of event this is.
    #[serde(rename = "data")]
    pub kind: StepEventKind<S>,
}

impl<S: StepSpec> StepEvent<S> {
    /// Returns a progress event associated with this step event, if any.
    ///
    /// Some step events have an implicit progress event of kind
    /// [`ProgressEventKind::WaitingForProgress`] associated with them. This
    /// causes those step events to generate progress events.
    pub fn progress_event(&self) -> Option<ProgressEvent<S>> {
        match &self.kind {
            StepEventKind::ExecutionStarted { first_step, .. } => {
                Some(ProgressEvent {
                    execution_id: self.execution_id,
                    total_elapsed: self.total_elapsed,
                    kind: ProgressEventKind::WaitingForProgress {
                        step: first_step.clone(),
                        attempt: 1,
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                })
            }
            StepEventKind::ProgressReset {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
                ..
            } => Some(ProgressEvent {
                execution_id: self.execution_id,
                total_elapsed: self.total_elapsed,
                kind: ProgressEventKind::WaitingForProgress {
                    step: step.clone(),
                    attempt: *attempt,
                    step_elapsed: *step_elapsed,
                    attempt_elapsed: *attempt_elapsed,
                },
            }),
            StepEventKind::AttemptRetry {
                step,
                next_attempt,
                step_elapsed,
                ..
            } => Some(ProgressEvent {
                execution_id: self.execution_id,
                total_elapsed: self.total_elapsed,
                kind: ProgressEventKind::WaitingForProgress {
                    step: step.clone(),
                    attempt: *next_attempt,
                    step_elapsed: *step_elapsed,
                    // For this attempt, zero time has passed so far.
                    attempt_elapsed: Duration::ZERO,
                },
            }),
            StepEventKind::StepCompleted { next_step, .. } => {
                Some(ProgressEvent {
                    execution_id: self.execution_id,
                    total_elapsed: self.total_elapsed,
                    kind: ProgressEventKind::WaitingForProgress {
                        step: next_step.clone(),
                        attempt: 1,
                        // For this next step, zero time has passed so far.
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                })
            }
            StepEventKind::Nested {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
                event,
                ..
            } => event.progress_event().map(|progress_event| ProgressEvent {
                execution_id: self.execution_id,
                total_elapsed: self.total_elapsed,
                kind: ProgressEventKind::Nested {
                    step: step.clone(),
                    attempt: *attempt,
                    event: Box::new(progress_event),
                    step_elapsed: *step_elapsed,
                    attempt_elapsed: *attempt_elapsed,
                },
            }),
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionCompleted { .. }
            | StepEventKind::ExecutionFailed { .. }
            | StepEventKind::Unknown => None,
        }
    }
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepEvent<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(StepEvent {
            execution_id: value.execution_id,
            event_index: value.event_index,
            total_elapsed: value.total_elapsed,
            kind: StepEventKind::from_generic(value.kind)
                .map_err(|error| error.parent("kind"))?,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<StepEvent<GenericSpec<E>>, ConvertGenericError> {
        Ok(StepEvent {
            execution_id: self.execution_id,
            event_index: self.event_index,
            total_elapsed: self.total_elapsed,
            kind: self
                .kind
                .into_generic()
                .map_err(|error| error.parent("kind"))?,
        })
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
#[schemars(rename = "StepEventKindFor{S}")]
pub enum StepEventKind<S: StepSpec> {
    /// No steps were defined, and the executor exited without doing anything.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    NoStepsDefined,

    /// Execution was started.
    ///
    /// This is an initial event -- it is always expected to be the first event
    /// received from the event stream.
    ExecutionStarted {
        /// The list of steps that will be executed.
        steps: Vec<StepInfo<S>>,

        /// A list of components, along with the number of items each component has.
        components: Vec<StepComponentSummary<S>>,

        /// Information about the first step.
        first_step: StepInfoWithMetadata<S>,
    },

    /// Progress was reset along an attempt, and this attempt is going down a
    /// different path.
    ProgressReset {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The current attempt number.
        attempt: usize,

        /// Progress-related metadata associated with this attempt.
        metadata: S::ProgressMetadata,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The amount of time this attempt has taken so far.
        attempt_elapsed: Duration,

        /// A message assocaited with the reset.
        message: Cow<'static, str>,
    },

    /// An attempt failed and this step is being retried.
    AttemptRetry {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number for the next attempt.
        next_attempt: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The amount of time the previous attempt took.
        attempt_elapsed: Duration,

        /// A message associated with the retry.
        message: Cow<'static, str>,
    },

    /// A step is complete and the next step has been started.
    StepCompleted {
        /// Information about the step that just completed.
        step: StepInfoWithMetadata<S>,

        /// The attempt number that completed.
        attempt: usize,

        /// The outcome of the step.
        outcome: StepOutcome<S>,

        /// The next step that is being started.
        next_step: StepInfoWithMetadata<S>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Execution is complete.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionCompleted {
        /// Information about the last step that completed.
        last_step: StepInfoWithMetadata<S>,

        /// The attempt number that completed.
        last_attempt: usize,

        /// The outcome of the last step.
        last_outcome: StepOutcome<S>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Execution failed.
    ///
    /// This is a terminal event: it is guaranteed that no more events will be
    /// seen after this one.
    ExecutionFailed {
        /// Information about the step that failed.
        failed_step: StepInfoWithMetadata<S>,

        /// The total number of attempts that were performed before the step failed.
        total_attempts: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,

        /// A message associated with the failure.
        message: String,

        /// A chain of causes associated with the failure.
        causes: Vec<String>,
    },

    /// A nested step event occurred.
    Nested {
        /// Information about the step that's occurring.
        step: StepInfoWithMetadata<S>,

        /// The current attempt number.
        attempt: usize,

        /// The event that occurred.
        event: Box<StepEvent<NestedSpec>>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Future variants that might be unknown.
    #[serde(other, deserialize_with = "deserialize_ignore_any")]
    Unknown,
}

impl<S: StepSpec> StepEventKind<S> {
    /// Returns the priority of the event.
    ///
    /// For more about this, see [`StepEventPriority`].
    pub fn priority(&self) -> StepEventPriority {
        match self {
            StepEventKind::NoStepsDefined
            | StepEventKind::ExecutionStarted { .. }
            | StepEventKind::StepCompleted { .. }
            | StepEventKind::ExecutionCompleted { .. }
            | StepEventKind::ExecutionFailed { .. } => StepEventPriority::High,
            StepEventKind::ProgressReset { .. }
            | StepEventKind::AttemptRetry { .. }
            | StepEventKind::Unknown => StepEventPriority::Low,
            StepEventKind::Nested { event, .. } => event.kind.priority(),
        }
    }

    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepEventKind<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            StepEventKind::NoStepsDefined => StepEventKind::NoStepsDefined,
            StepEventKind::ExecutionStarted {
                steps,
                components,
                first_step,
            } => StepEventKind::ExecutionStarted {
                steps: steps
                    .into_iter()
                    .enumerate()
                    .map(|(index, step)| {
                        StepInfo::from_generic(step)
                            .map_err(|error| error.parent_array("steps", index))
                    })
                    .collect::<Result<Vec<_>, _>>()?,
                components: components
                    .into_iter()
                    .enumerate()
                    .map(|(index, component)| {
                        StepComponentSummary::from_generic(component).map_err(
                            |error| error.parent_array("components", index),
                        )
                    })
                    .collect::<Result<Vec<_>, _>>()?,
                first_step: StepInfoWithMetadata::from_generic(first_step)
                    .map_err(|error| error.parent("first_step"))?,
            },
            StepEventKind::ProgressReset {
                step,
                attempt,
                metadata,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::ProgressReset {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                metadata: serde_json::from_value(metadata).map_err(
                    |error| ConvertGenericError::new("metadata", error),
                )?,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::AttemptRetry {
                step,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::AttemptRetry {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::StepCompleted {
                step,
                attempt,
                outcome,
                next_step,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::StepCompleted {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                outcome: StepOutcome::from_generic(outcome)
                    .map_err(|error| error.parent("outcome"))?,
                next_step: StepInfoWithMetadata::from_generic(next_step)
                    .map_err(|error| error.parent("next_step"))?,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionCompleted {
                last_step,
                last_attempt,
                last_outcome,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::ExecutionCompleted {
                last_step: StepInfoWithMetadata::from_generic(last_step)
                    .map_err(|error| error.parent("last_step"))?,
                last_attempt,
                last_outcome: StepOutcome::from_generic(last_outcome)
                    .map_err(|error| error.parent("last_outcome"))?,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionFailed {
                failed_step,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            } => StepEventKind::ExecutionFailed {
                failed_step: StepInfoWithMetadata::from_generic(failed_step)
                    .map_err(|error| error.parent("failed_step"))?,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            },
            StepEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::Nested {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::Unknown => StepEventKind::Unknown,
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<StepEventKind<GenericSpec<E>>, ConvertGenericError> {
        let ret = match self {
            StepEventKind::NoStepsDefined => StepEventKind::NoStepsDefined,
            StepEventKind::ExecutionStarted {
                steps,
                components,
                first_step,
            } => StepEventKind::ExecutionStarted {
                steps: steps
                    .into_iter()
                    .enumerate()
                    .map(|(index, step)| {
                        step.into_generic()
                            .map_err(|error| error.parent_array("steps", index))
                    })
                    .collect::<Result<Vec<_>, _>>()?,
                components: components
                    .into_iter()
                    .enumerate()
                    .map(|(index, component)| {
                        component.into_generic().map_err(|error| {
                            error.parent_array("components", index)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()?,
                first_step: first_step
                    .into_generic()
                    .map_err(|error| error.parent("first_step"))?,
            },
            StepEventKind::ProgressReset {
                step,
                attempt,
                metadata,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::ProgressReset {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                attempt,
                metadata: serde_json::to_value(metadata).map_err(|error| {
                    ConvertGenericError::new("metadata", error)
                })?,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::AttemptRetry {
                step,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            } => StepEventKind::AttemptRetry {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                next_attempt,
                step_elapsed,
                attempt_elapsed,
                message,
            },
            StepEventKind::StepCompleted {
                step,
                attempt,
                outcome,
                next_step,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::StepCompleted {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                attempt,
                outcome: outcome
                    .into_generic()
                    .map_err(|error| error.parent("outcome"))?,
                next_step: next_step
                    .into_generic()
                    .map_err(|error| error.parent("next_step"))?,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionCompleted {
                last_step,
                last_attempt,
                last_outcome,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::ExecutionCompleted {
                last_step: last_step
                    .into_generic()
                    .map_err(|error| error.parent("last_step"))?,
                last_attempt,
                last_outcome: last_outcome
                    .into_generic()
                    .map_err(|error| error.parent("last_outcome"))?,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::ExecutionFailed {
                failed_step,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            } => StepEventKind::ExecutionFailed {
                failed_step: failed_step
                    .into_generic()
                    .map_err(|error| error.parent("failed_step"))?,
                total_attempts,
                step_elapsed,
                attempt_elapsed,
                message,
                causes,
            },
            StepEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => StepEventKind::Nested {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            StepEventKind::Unknown => StepEventKind::Unknown,
        };
        Ok(ret)
    }
}

/// The priority of a [`StepEvent`].
///
/// Returned by [`StepEventKind::priority`].
///
/// Some [`StepEvent`]s have a higher priority than others. For example, events
/// related to step successes and failures must be delivered, while events
/// related to retries can be trimmed down since they are overall less
/// important.
#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord)]
pub enum StepEventPriority {
    /// A low-priority event.
    ///
    /// Includes retry, reset, and unknown events.
    Low,

    /// A high-priority event.
    ///
    /// Includes successes, failures, and terminal events.
    High,
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
#[schemars(rename = "StepOutcomeFor{S}")]
pub enum StepOutcome<S: StepSpec> {
    /// The step completed successfully.
    Success {
        /// Completion metadata associated with the step.
        metadata: S::CompletionMetadata,
    },

    /// The step completed with a warning.
    Warning {
        /// Completion metadata associated with the step.
        metadata: S::CompletionMetadata,

        /// A warning message.
        message: Cow<'static, str>,
    },

    /// The step was skipped with a message.
    Skipped {
        /// Skipped metadata associated with the step.
        metadata: S::SkippedMetadata,

        /// Metadata associated with the step.
        message: Cow<'static, str>,
    },
}

impl<S: StepSpec> StepOutcome<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepOutcome<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            StepOutcome::Success { metadata } => StepOutcome::Success {
                metadata: serde_json::from_value(metadata).map_err(
                    |error| ConvertGenericError::new("metadata", error),
                )?,
            },
            StepOutcome::Warning { metadata, message } => {
                StepOutcome::Warning {
                    metadata: serde_json::from_value(metadata).map_err(
                        |error| ConvertGenericError::new("metadata", error),
                    )?,
                    message,
                }
            }
            StepOutcome::Skipped { metadata, message } => {
                StepOutcome::Skipped {
                    metadata: serde_json::from_value(metadata).map_err(
                        |error| ConvertGenericError::new("metadata", error),
                    )?,
                    message,
                }
            }
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<StepOutcome<GenericSpec<E>>, ConvertGenericError> {
        let ret = match self {
            StepOutcome::Success { metadata } => StepOutcome::Success {
                metadata: serde_json::to_value(metadata).map_err(|error| {
                    ConvertGenericError::new("metadata", error)
                })?,
            },
            StepOutcome::Warning { metadata, message } => {
                StepOutcome::Warning {
                    metadata: serde_json::to_value(metadata).map_err(
                        |error| ConvertGenericError::new("metadata", error),
                    )?,
                    message,
                }
            }
            StepOutcome::Skipped { metadata, message } => {
                StepOutcome::Skipped {
                    metadata: serde_json::to_value(metadata).map_err(
                        |error| ConvertGenericError::new("metadata", error),
                    )?,
                    message,
                }
            }
        };
        Ok(ret)
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "ProgressEventFor{S}")]
pub struct ProgressEvent<S: StepSpec> {
    /// The execution ID.
    pub execution_id: ExecutionId,

    /// Total time elapsed since the start of execution.
    pub total_elapsed: Duration,

    /// The kind of event this is.
    #[serde(rename = "data")]
    pub kind: ProgressEventKind<S>,
}

impl<S: StepSpec> ProgressEvent<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: ProgressEvent<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            execution_id: value.execution_id,
            total_elapsed: value.total_elapsed,
            kind: ProgressEventKind::from_generic(value.kind)
                .map_err(|error| error.parent("kind"))?,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<ProgressEvent<GenericSpec<E>>, ConvertGenericError> {
        Ok(ProgressEvent {
            execution_id: self.execution_id,
            total_elapsed: self.total_elapsed,
            kind: self
                .kind
                .into_generic()
                .map_err(|error| error.parent("kind"))?,
        })
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case", tag = "kind")]
#[schemars(rename = "ProgressEventKindFor{S}")]
pub enum ProgressEventKind<S: StepSpec> {
    /// The update engine is waiting for a progress message.
    ///
    /// The update engine sends this message immediately after a [`StepEvent`]
    /// corresponding to a new step.
    WaitingForProgress {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// Total time elapsed since the start of the attempt.
        attempt_elapsed: Duration,
    },

    Progress {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// Metadata that was returned with progress.
        metadata: S::ProgressMetadata,

        /// Current progress.
        progress: Option<ProgressCounter>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// Total time elapsed since the start of the attempt.
        attempt_elapsed: Duration,
    },

    Nested {
        /// Information about the step.
        step: StepInfoWithMetadata<S>,

        /// The attempt number currently being executed.
        attempt: usize,

        /// The event that occurred.
        event: Box<ProgressEvent<NestedSpec>>,

        /// Total time elapsed since the start of the step. Includes prior
        /// attempts.
        step_elapsed: Duration,

        /// The time it took for this attempt to complete.
        attempt_elapsed: Duration,
    },

    /// Future variants that might be unknown.
    #[serde(other, deserialize_with = "deserialize_ignore_any")]
    Unknown,
}

impl<S: StepSpec> ProgressEventKind<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: ProgressEventKind<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        let ret = match value {
            ProgressEventKind::WaitingForProgress {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::WaitingForProgress {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Progress {
                step,
                attempt,
                metadata,
                progress,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Progress {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                metadata: serde_json::from_value(metadata).map_err(
                    |error| ConvertGenericError::new("metadata", error),
                )?,
                progress,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Nested {
                step: StepInfoWithMetadata::from_generic(step)
                    .map_err(|error| error.parent("step"))?,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Unknown => todo!(),
        };
        Ok(ret)
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<ProgressEventKind<GenericSpec<E>>, ConvertGenericError> {
        let ret = match self {
            ProgressEventKind::WaitingForProgress {
                step,
                attempt,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::WaitingForProgress {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                attempt,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Progress {
                step,
                attempt,
                metadata,
                progress,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Progress {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                attempt,
                metadata: serde_json::to_value(metadata).map_err(|error| {
                    ConvertGenericError::new("metadata", error)
                })?,
                progress,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Nested {
                step,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            } => ProgressEventKind::Nested {
                step: step
                    .into_generic()
                    .map_err(|error| error.parent("step"))?,
                attempt,
                event,
                step_elapsed,
                attempt_elapsed,
            },
            ProgressEventKind::Unknown => todo!(),
        };
        Ok(ret)
    }
}

/// Serializable information about a step.
#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepInfoFor{S}")]
pub struct StepInfo<S: StepSpec> {
    /// An identifier for this step.
    pub id: S::StepId,

    /// The component that this step is part of.
    pub component: S::Component,

    /// The description for this step.
    pub description: Cow<'static, str>,

    /// The index of the step within all steps to be executed.
    pub index: usize,

    /// The index of the step within the component.
    pub component_index: usize,

    /// The total number of steps in this component.
    pub total_component_steps: usize,
}

impl<S: StepSpec> StepInfo<S> {
    /// Returns true if this is the last step in this component.
    pub fn is_last_step_in_component(&self) -> bool {
        self.component_index + 1 == self.total_component_steps
    }

    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepInfo<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            id: serde_json::from_value(value.id)
                .map_err(|error| ConvertGenericError::new("id", error))?,
            component: serde_json::from_value(value.component).map_err(
                |error| ConvertGenericError::new("component", error),
            )?,
            description: value.description,
            index: value.index,
            component_index: value.component_index,
            total_component_steps: value.total_component_steps,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<StepInfo<GenericSpec<E>>, ConvertGenericError> {
        Ok(StepInfo {
            id: serde_json::to_value(self.id)
                .map_err(|error| ConvertGenericError::new("id", error))?,
            component: serde_json::to_value(self.component).map_err(
                |error| ConvertGenericError::new("component", error),
            )?,
            description: self.description,
            index: self.index,
            component_index: self.component_index,
            total_component_steps: self.total_component_steps,
        })
    }
}

#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepComponentSummaryFor{S}")]
pub struct StepComponentSummary<S: StepSpec> {
    /// The component.
    pub component: S::Component,

    /// The number of steps present in this component.
    pub total_component_steps: usize,
}

impl<S: StepSpec> StepComponentSummary<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepComponentSummary<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            component: serde_json::from_value(value.component).map_err(
                |error| ConvertGenericError::new("component", error),
            )?,
            total_component_steps: value.total_component_steps,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<StepComponentSummary<GenericSpec<E>>, ConvertGenericError> {
        Ok(StepComponentSummary {
            component: serde_json::to_value(self.component).map_err(
                |error| ConvertGenericError::new("component", error),
            )?,
            total_component_steps: self.total_component_steps,
        })
    }
}

/// Serializable information about a step.
#[derive(Deserialize, Serialize, JsonSchema)]
#[derive_where(Clone, Debug, Eq, PartialEq)]
#[serde(bound = "", rename_all = "snake_case")]
#[schemars(rename = "StepInfoWithMetadataFor{S}")]
pub struct StepInfoWithMetadata<S: StepSpec> {
    /// Information about this step.
    pub info: StepInfo<S>,

    /// Additional metadata associated with this step.
    pub metadata: Option<S::StepMetadata>,
}

impl<S: StepSpec> StepInfoWithMetadata<S> {
    /// Converts a generic version into self.
    ///
    /// This version can be used to convert a generic type into a more concrete
    /// form.
    pub fn from_generic<E: AsError>(
        value: StepInfoWithMetadata<GenericSpec<E>>,
    ) -> Result<Self, ConvertGenericError> {
        Ok(Self {
            info: StepInfo::from_generic(value.info)
                .map_err(|error| error.parent("info"))?,
            metadata: value
                .metadata
                .map(|metadata| {
                    serde_json::from_value(metadata).map_err(|error| {
                        ConvertGenericError::new("metadata", error)
                    })
                })
                .transpose()?,
        })
    }

    /// Converts self into its generic version.
    ///
    /// This version can be used to share data across different kinds of engines.
    pub fn into_generic<E: AsError>(
        self,
    ) -> Result<StepInfoWithMetadata<GenericSpec<E>>, ConvertGenericError> {
        Ok(StepInfoWithMetadata {
            info: StepInfo::into_generic(self.info)
                .map_err(|error| error.parent("info"))?,
            metadata: self
                .metadata
                .map(|metadata| {
                    serde_json::to_value(metadata).map_err(|error| {
                        ConvertGenericError::new("metadata", error)
                    })
                })
                .transpose()?,
        })
    }
}

/// Current progress.
///
/// Both `current` and `total` are abstract counters. These counters are often a
/// number of bytes. There is no guarantee that the counter won't go back in
/// subsequent events; that can happen e.g. if a fetch happens from multiple
/// peers within a single attempt.
#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ProgressCounter {
    pub current: u64,
    pub total: Option<u64>,
}

impl ProgressCounter {
    /// Creates a new `ProgressCounter` with current and total values.
    #[inline]
    pub fn new(current: u64, total: u64) -> Self {
        Self { current, total: Some(total) }
    }

    /// Creates a new `ProgressCounter` with just a current value.
    #[inline]
    pub fn current(current: u64) -> Self {
        Self { current, total: None }
    }
}

#[derive_where(Clone, Debug, Eq, PartialEq)]
pub enum StepProgress<S: StepSpec> {
    /// A step has progressed.
    Progress {
        /// Current progress.
        progress: Option<ProgressCounter>,

        /// Metadata associated with progress.
        metadata: S::ProgressMetadata,
    },

    /// Progress was reset: typically, the step failed along one path, and the
    /// step is now trying a different path.
    ///
    /// For example, downloading from one peer failed and we've moved to the
    /// next peer.
    Reset {
        /// Metadata associated with the reset.
        metadata: S::ProgressMetadata,

        /// A message associated with the reset.
        message: Cow<'static, str>,
    },

    /// The step is being retried from the beginning.
    Retry {
        /// An optional message associated with the retry.
        message: Cow<'static, str>,
    },
}

impl<S: StepSpec> StepProgress<S> {
    /// Creates a new progress message with current and total values.
    pub fn with_current_and_total(
        current: u64,
        total: u64,
        metadata: S::ProgressMetadata,
    ) -> Self {
        Self::Progress {
            progress: Some(ProgressCounter { current, total: Some(total) }),
            metadata,
        }
    }

    /// Creates a new progress message with a current value.
    pub fn with_current(current: u64, metadata: S::ProgressMetadata) -> Self {
        Self::Progress {
            progress: Some(ProgressCounter { current, total: None }),
            metadata,
        }
    }

    /// Creates a new progress message without either current or total values.
    pub fn progress(metadata: S::ProgressMetadata) -> Self {
        Self::Progress { progress: None, metadata }
    }

    /// Creats a new reset message.
    pub fn reset(
        metadata: S::ProgressMetadata,
        message: impl Into<Cow<'static, str>>,
    ) -> Self {
        Self::Reset { metadata, message: message.into() }
    }

    /// Creates a new retry message.
    pub fn retry(message: impl Into<Cow<'static, str>>) -> Self {
        Self::Retry { message: message.into() }
    }
}

#[cfg(test)]
mod tests {
    use omicron_test_utils::dev::test_setup_log;

    use crate::test_utils::*;

    use super::*;

    #[test]
    fn step_event_parse_unknown() {
        let logctx = test_setup_log("step_event_parse_unknown");
        let execution_id = test_execution_id();
        let tests = [
            (
                r#"
                  {
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "event_index": 0,
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "unknown_variant",
                      "last_step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "last_attempt": 1,
                      "last_outcome": {
                        "kind": "success",
                        "metadata": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      }
                    }
                  }
                "#,
                StepEvent {
                    execution_id,
                    event_index: 0,
                    total_elapsed: Duration::ZERO,
                    kind: StepEventKind::Unknown,
                },
            ),
            (
                r#"
                  {
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "event_index": 1,
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "execution_completed",
                      "last_step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "last_attempt": 1,
                      "last_outcome": {
                        "kind": "success",
                        "metadata": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "unknown_field": 123
                    }
                  }
                "#,
                StepEvent::<TestSpec> {
                    execution_id,
                    event_index: 1,
                    total_elapsed: Duration::ZERO,
                    kind: StepEventKind::ExecutionCompleted {
                        last_step: StepInfoWithMetadata {
                            info: StepInfo {
                                id: 0,
                                component: "foo".to_owned(),
                                description: "Description".into(),
                                index: 0,
                                component_index: 0,
                                total_component_steps: 1,
                            },
                            metadata: None,
                        },
                        last_attempt: 1,
                        last_outcome: StepOutcome::Success {
                            metadata: serde_json::Value::Null,
                        },
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                },
            ),
        ];

        for (index, (input, expected)) in tests.into_iter().enumerate() {
            let serialized = serde_json::to_string_pretty(&expected).unwrap();
            slog::info!(
                logctx.log,
                "for index {index}, serialized: {serialized}"
            );

            let actual: StepEvent<TestSpec> = serde_json::from_str(input)
                .unwrap_or_else(|error| {
                    panic!("index {index}: unknown variant deserialized correctly: {error}")
                });
            assert_eq!(expected, actual, "input matches actual output");
        }

        logctx.cleanup_successful();
    }

    #[test]
    fn progress_event_parse_unknown() {
        let logctx = test_setup_log("progress_event_parse_unknown");
        let execution_id = test_execution_id();

        let tests = [
            (
                r#"
                  {
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "unknown_variant",
                      "step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "attempt": 1,
                      "metadata": null,
                      "progress": {
                        "current": 123,
                        "total": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      }
                    }
                  }
                "#,
                ProgressEvent {
                    execution_id,
                    total_elapsed: Duration::ZERO,
                    kind: ProgressEventKind::Unknown,
                },
            ),
            (
                r#"
                  {
                    "execution_id": "2cc08a14-5e96-4917-bc70-e98293a3b703",
                    "total_elapsed": {
                      "secs": 0,
                      "nanos": 0
                    },
                    "data": {
                      "kind": "progress",
                      "step": {
                        "info": {
                          "id": 0,
                          "component": "foo",
                          "description": "Description",
                          "index": 0,
                          "component_index": 0,
                          "total_component_steps": 1
                        },
                        "metadata": null
                      },
                      "attempt": 1,
                      "metadata": null,
                      "progress": {
                        "current": 123,
                        "total": null
                      },
                      "step_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "attempt_elapsed": {
                        "secs": 0,
                        "nanos": 0
                      },
                      "unknown_field": 123
                    }
                  }
                "#,
                ProgressEvent::<TestSpec> {
                    execution_id,
                    total_elapsed: Duration::ZERO,
                    kind: ProgressEventKind::Progress {
                        step: StepInfoWithMetadata {
                            info: StepInfo {
                                id: 0,
                                component: "foo".to_owned(),
                                description: "Description".into(),
                                index: 0,
                                component_index: 0,
                                total_component_steps: 1,
                            },
                            metadata: None,
                        },
                        attempt: 1,
                        metadata: serde_json::Value::Null,
                        progress: Some(ProgressCounter::current(123)),
                        step_elapsed: Duration::ZERO,
                        attempt_elapsed: Duration::ZERO,
                    },
                },
            ),
        ];

        for (index, (input, expected)) in tests.into_iter().enumerate() {
            let serialized = serde_json::to_string_pretty(&expected).unwrap();
            slog::info!(
                logctx.log,
                "for index {index}, serialized: {serialized}"
            );

            let actual: ProgressEvent<TestSpec> = serde_json::from_str(input)
                .unwrap_or_else(|error| {
                    panic!("index {index}: unknown variant deserialized correctly: {error}")
                });
            assert_eq!(expected, actual, "input matches actual output");
        }

        logctx.cleanup_successful();
    }
}
