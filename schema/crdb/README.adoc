:showtitle:
:numbered:

= Database Schemas

This directory describes the schema(s) used by CockroachDB.

We use the following conventions:

* `schema/crdb/VERSION/up.sql`: The necessary idempotent migrations to
  transition from the previous version of CockroachDB to this version. These
  migrations will always be placed within one transaction per file.
** If more than one change is needed per version, any number of files starting
   with `up` and ending with `.sql` may be used. These files will be sorted in
   lexicographic order before being executed, and each will be executed in a
   separate transaction.
** CockroachDB documentation recommends the following: "Execute schema
   changes... in a single explicit transaction consisting of the single schema
   change statement".  Practically this means: If you want to change multiple
   tables, columns, types, indices, or constraints, do so in separate files.
** More information can be found here:
   https://www.cockroachlabs.com/docs/stable/online-schema-changes
* `schema/crdb/dbinit.sql`: The necessary operations to create the latest
  version of the schema. Should be equivalent to running all `up.sql`
  migrations, in-order.
* `schema/crdb/dbwipe.sql`: The necessary operations to delete the latest
  version of the schema.

Note that to upgrade from version N to version N+2, we always need to apply the
N+1 upgrade first, before applying the N+2 upgrade. This simplifies our model
of DB schema changes as an incremental linear history.

== Offline Upgrade

Nexus currently supports **offline** schema migrations.
This means we're operating with the following constraints:

* We assume that downtime is acceptable to perform an update.
* We assume that while an update is occuring, all Nexus services
are running the same version of software.
* We assume that no (non-upgrade) concurrent database requests will happen for
the duration of the migration.

This is not an acceptable long-term solution - we must be able to update
without downtime - but it is an interim solution, and one which provides a
fall-back pathway for performing upgrades.

See RFD 319 for more discussion of the online upgrade plans.

=== How to change the schema

Assumptions:

* The (previously) latest schema version is referred to as `OLD_VERSION`
* Your new changes will bring the schema to a new version, `NEW_VERSION`

Process:

* Choose a `NEW_VERSION` number. This should almost certainly be a major
  version bump over `OLD_VERSION`.
* Add a file to `schema/crdb/NEW_VERSION/up.sql` with your changes to the
  schema.
** This file should validate the expected current version transactionally.
** This file should only issue a single schema-modifying statement per
   transaction.
** This file should not issue any data-modifying operations within the
   schema-modifying transactions.
* Update `schema/crdb/dbinit.sql` to match what the database should look like
  after your update is applied. Don't forget to update the version field of
  `db_metadata` at the bottom of the file!
** If necessary, do the same thing for `schema/crdb/dbwipe.sql`.
* Update Nexus's idea of the latest schema, by updating its `SCHEMA_VERSION` to
  `NEW_VERSION` within `nexus/db-model/src/schema.rs`.

SQL Validation, via Automated Tests:

* The `SCHEMA_VERSION` matches the version used in `dbinit.sql`
* The combination of all `up.sql` files results in the same schema as
  `dbinit.sql`
* All `up.sql` files can be applied twice without error

==== Handling common schema changes

Although CockroachDB's schema includes some opaque internally-generated fields
that are order dependent - such as the names of anonymous CHECK constraints -
our schema comparison tools intentionally ignore these values. As a result,
when performing schema changes, the order of new tables and constraints should
generally not be important.

As convention, however, we recommend keeping the `db_metadata` file at the end
of `dbinit.sql`, so that the database does not contain a version until it is
fully populated.

==== Adding new source tables to an existing view

An upgrade can add a new table and then use a `CREATE OR REPLACE VIEW` statement
to make an existing view depend on that table. To do this in `dbinit.sql` while
maintaining table and view ordering, use `CREATE VIEW` to create a "placeholder"
view in the correct position, then add the table to the bottom of `dbinit.sql`
and use `CREATE OR REPLACE VIEW` to "fill out" the placeholder definition to
refer to the new table. (You may need to do the `CREATE OR REPLACE VIEW` in a
separate transaction from the original `CREATE VIEW`.)

Note that `CREATE OR REPLACE VIEW` requires that the new view maintain all of
the columns of the old view with the same type and same order (though the query
used to populate them can change. See
https://www.postgresql.org/docs/15/sql-createview.html.

==== Renaming columns

Idempotently renaming existing columns is unfortunately not possible in our
current database configuration. (Postgres doesn't support the use of an `IF
EXISTS` qualifier on an `ALTER TABLE RENAME COLUMN` statement, and the version
of CockroachDB we use at this writing doesn't support the use of user-defined
functions as a workaround.)

An (imperfect) workaround is to use the `#[diesel(column_name = foo)]` attribute
in Rust code to preserve the existing name of a column in the database while
giving its corresponding struct field a different, more meaningful name.
