//! Types for the collection of metrics from client code.
// Copyright 2021 Oxide Computer Company

use std::boxed::Box;
use std::collections::{
    hash_map::{DefaultHasher, Entry},
    HashMap,
};
use std::hash::{Hash, Hasher};

use chrono::{DateTime, Utc};

use crate::{producer, Counter, Error, Metric, Producer, Sample, Target};

/// An opaque token used as a handle to a registered collection of metrics.
#[derive(Clone, Copy, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct CollectionToken(u64);

/// The `Collector` provides a way to register and export metrics from an application.
///
/// A [`Metric`] may be [`register`](Collector::register)ed with the `Collector` (along with a
/// [`Target`]). Metrics may be registered in isolation, or as a "collection", a group of related
/// metrics. In either case, a [`CollectionToken`] is returned to the client, and can be used to get
/// information about or deregister the collection at a later time.
///
/// Metrics are registered along with an implementation of the `Producer` trait, which the
/// `Collector` uses to retrieve the current values of the associated metrics, whenever the
/// [`Collector::collect`] method is called.
///
/// Example
/// -------
///
/// There are several convenience methods for common use cases. For example the
/// [`Collector::register_counter`] method can be used to return a [`Counter`] object, which client
/// code can increment whenever it wishes. The `Collector` will retrieve the latest value of the
/// counter.
///
/// ```rust
/// use oximeter::{Target, Metric, Measurement, Collector};
///
/// #[derive(Clone, Target)]
/// struct MyTarget {
///     pub field: String,
/// }
///
/// #[oximeter::metric("gauge", "i64")]
/// #[derive(Clone)]
/// struct MyMetric {
///     pub field: i64
/// }
///
/// fn main () {
///     let target = MyTarget{ field: String::from("a-name") };
///     let metric = MyMetric{ field: 10 };
///     let mut collector = Collector::new();
///
///     // Register a counter for the target and metric.
///     let (token, mut counter) = collector.register_counter(&target, &metric).unwrap();
///
///     // In downstream code, the counter can be incremented as needed.
///     counter.increment();
///     counter.add(4);
///
///     // `Counter`s may be cheaply cloned and shared with other threads as needed.
///     let mut counter2 = counter.clone();
///     counter2.increment();
///
///     // All counter manipulations should be reflected.
///     let samples = collector.collect().unwrap();
///     assert_eq!(samples[0].measurement, Measurement::I64(6));
/// }
/// ```
pub struct Collector {
    // server in here somewhere
    collections: HashMap<CollectionToken, Collection>,
    n_items: usize,
}

impl Collector {
    /// Construct a new collector, used to register and aggregate metrics in client code.
    pub fn new() -> Self {
        Self {
            collections: HashMap::new(),
            n_items: 0,
        }
    }

    /// Register a target and metric, with measurements to be generated by a producer.
    ///
    /// An `Err` is returned if the metrics are already registered.
    pub fn register<T, M, P>(
        &mut self,
        target: &T,
        metric: &M,
        producer: &P,
    ) -> Result<CollectionToken, Error>
    where
        T: Target + Clone + 'static,
        M: Metric + Clone + 'static,
        P: Producer + Clone + 'static,
    {
        // TODO-safety: It should be possible to provide more compile-time safety, by enforcing
        // that the metric and producer's expected types match. That would have to be done by an
        // associated type on each, and using the trait bounds to enforce they're the same.
        //
        // Note that this is very helpful, but the current interface still allows producing
        // measurements of the wrong type for a metric. The `Producer` trait returns an enum over
        // the possible measurement types, and so runtime errors are still possible. We may want to
        // change this interface to have a registration method _per metric type_.
        let mut hasher = DefaultHasher::new();
        target.key().hash(&mut hasher);
        metric.key().hash(&mut hasher);
        let tok = CollectionToken(hasher.finish());
        self.n_items += 1;
        match self.collections.entry(tok) {
            Entry::Occupied(_) => Err(Error::CollectionAlreadyRegistered),
            Entry::Vacant(entry) => {
                entry.insert(Collection {
                    targets: vec![Box::new(target.clone())],
                    metrics: vec![Box::new(metric.clone())],
                    producer: Box::new(producer.clone()),
                    created: Utc::now(),
                });
                Ok(tok)
            }
        }
    }

    /// A convenience function to register and return an atomic counter.
    ///
    /// An `Err` is returned if the metrics are already registered.
    pub fn register_counter<T, M>(
        &mut self,
        target: &T,
        metric: &M,
    ) -> Result<(CollectionToken, Counter), Error>
    where
        T: Target + Clone + 'static,
        M: Metric + Clone + 'static,
    {
        let counter = Counter::new();
        let token = self.register(target, metric, &counter)?;
        Ok((token, counter))
    }

    /// A convenience function to register and return a distribution over 64-bit integers.
    ///
    /// An `Err` is returned if the metrics are already registered.
    pub fn register_distribution_i64<T, M>(
        &mut self,
        target: &T,
        metric: &M,
        bins: &[i64],
    ) -> Result<(CollectionToken, producer::Distribution<i64>), Error>
    where
        T: Target + Clone + 'static,
        M: Metric + Clone + 'static,
    {
        let distribution = producer::Distribution::new(bins)?;
        let token = self.register(target, metric, &distribution)?;
        Ok((token, distribution))
    }

    /// A convenience function to register and return a distribution over 64-bit floats.
    ///
    /// An `Err` is returned if the metrics are already registered.
    pub fn register_distribution_f64<T, M>(
        &mut self,
        target: &T,
        metric: &M,
        bins: &[f64],
    ) -> Result<(CollectionToken, producer::Distribution<f64>), Error>
    where
        T: Target + Clone + 'static,
        M: Metric + Clone + 'static,
    {
        let distribution = producer::Distribution::new(bins)?;
        let token = self.register(target, metric, &distribution)?;
        Ok((token, distribution))
    }

    /// Register a set of targets and metrics, with measurements to be generated by the same
    /// producer.
    ///
    /// This method is useful when clients wish to report a set of related metrics at the same
    /// time. It's also helpful when generating the set of metrics is expensive -- in that case,
    /// the cost is paid once per collection, rather than once per metric.
    ///
    /// An `Err` is returned if the metrics are already registered.
    pub fn register_collection<T, M, P>(
        &mut self,
        targets: &[T],
        metrics: &[M],
        producer: &P,
    ) -> Result<CollectionToken, Error>
    where
        T: Target + Clone + 'static,
        M: Metric + Clone + 'static,
        P: Producer + Clone + 'static,
    {
        if targets.is_empty() || targets.len() != metrics.len() {
            return Err(Error::InvalidCollection(String::from(
                "Targets and metrics must have the same size and be nonempty",
            )));
        }
        let mut targets_ = Vec::<Box<dyn Target>>::with_capacity(targets.len());
        let mut metrics_ = Vec::<Box<dyn Metric>>::with_capacity(metrics.len());
        let mut hasher = DefaultHasher::new();
        for (target, metric) in targets.iter().zip(metrics.iter()) {
            target.key().hash(&mut hasher);
            metric.key().hash(&mut hasher);
            targets_.push(Box::new(target.clone()));
            metrics_.push(Box::new(metric.clone()));
        }
        let tok = CollectionToken(hasher.finish());
        self.n_items += targets_.len();
        match self.collections.entry(tok) {
            Entry::Occupied(_) => Err(Error::CollectionAlreadyRegistered),
            Entry::Vacant(entry) => {
                entry.insert(Collection {
                    targets: targets_,
                    metrics: metrics_,
                    producer: Box::new(producer.clone()),
                    created: Utc::now(),
                });
                Ok(tok)
            }
        }
    }

    /// Deregister a collection with this collector.
    ///
    /// An `Err` is returned if the token doesn't refer to a currently-registered collection. This
    /// means the collection was already registered, and can usually be ignored.
    pub fn deregister(&mut self, token: CollectionToken) -> Result<(), Error> {
        self.n_items -= self
            .collections
            .remove(&token)
            .ok_or_else(|| Error::CollectionNotRegistered)?
            .len();
        Ok(())
    }

    /// Collect the registered metrics.
    ///
    /// Metrics are scraped by collection (in an undefined order). The [`Producer`] registered for
    /// a collection is used to perform the actual generation of metrics. The
    /// [`Producer::setup_collection`] method is called, once per collection, and then the
    /// [`Producer::collect`] method is used to return the actual measurements for the collection.
    pub fn collect(&mut self) -> Result<Vec<Sample>, Error> {
        let mut samples = Vec::new();
        for collection in self.collections.values_mut() {
            let producer = &mut collection.producer;
            producer.setup_collection()?;
            let measurements = producer.collect()?;
            for i in 0..measurements.len() {
                if collection.metrics[i].metric_type() != measurements[i].metric_type() {
                    return Err(Error::ProducerTypeMismatch(
                        collection.metrics[i].metric_type(),
                        measurements[i].metric_type(),
                    ));
                }
                let sample = Sample::new(
                    &collection.targets[i],
                    &collection.metrics[i],
                    &measurements[i],
                    None,
                );
                samples.push(sample);
            }
        }
        Ok(samples)
    }

    /// Return the number of registered collections.
    pub fn n_collections(&self) -> usize {
        self.collections.len()
    }

    /// Return the total number of registered items, i.e., target/metric pairs, across all
    /// collections.
    pub fn n_items(&self) -> usize {
        self.n_items
    }

    /// Return basic information about a collection.
    ///
    /// This currently returns the number of timeseries and the creation time of the collection.
    pub fn collection_info(&self, token: CollectionToken) -> Result<(usize, DateTime<Utc>), Error> {
        self.collections
            .get(&token)
            .ok_or_else(|| Error::CollectionNotRegistered)
            .map(|collection| (collection.len(), collection.created))
    }
}

// Internal type used to manage metric collections in the `Collector`.
pub(crate) struct Collection {
    pub(crate) targets: Vec<Box<dyn Target>>,
    pub(crate) metrics: Vec<Box<dyn Metric>>,
    pub(crate) producer: Box<dyn Producer>,
    pub(crate) created: DateTime<Utc>,
}

impl Collection {
    pub(crate) fn len(&self) -> usize {
        self.targets.len()
    }
}
