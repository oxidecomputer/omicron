// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Subcommand: cargo xtask a4x2-deploy

use anyhow::{anyhow, bail, Result};
use camino::Utf8PathBuf;
use clap::{Args, Parser, Subcommand};
use serde_json::Value;
use std::env;
use std::fs;
use std::{thread, time};
use xshell::{cmd, Shell};

/// Args for sshing in without checking/storing the remote host key. Every time
/// we start a4x2, it will have new keys.
static INSECURE_SSH_ARGS: [&str; 8] = [
    "-o",
    "StrictHostKeyChecking no",
    "-o",
    "UserKnownHostsFile /dev/null",
    "-o",
    "GlobalKnownHostsFile /dev/null",
    "-o",
    "LogLevel error",
];

/// default path used when none provided on command line
static DEFAULT_A4X2_PKG_PATH: &str = "out/a4x2-package-out.tgz";

#[derive(Parser)]
pub struct A4x2DeployArgs {
    #[command(subcommand)]
    command: DeployCommand,
}

#[derive(Subcommand, Clone)]
pub enum DeployCommand {
    /// Start a4x2, deploy a control plane to it, and then leave it running.
    Start(StartArgs),

    /// Stop a4x2 that was previously launched with the `start` subcommand.
    Stop,

    /// Start a4x2, run tests, and then stop a4x2 unless you request otherwise.
    RunTests(RunTestsArgs),
}

#[derive(Args, Clone)]
pub struct StartArgs {
    /// Path to an a4x2-package bundle generated by a4x2-package xtask.
    #[clap(long, default_value_t = Utf8PathBuf::from(DEFAULT_A4X2_PKG_PATH))]
    package: Utf8PathBuf,
}

#[derive(Args, Clone)]
pub struct RunTestsArgs {
    /// Execute omicron live tests
    #[clap(long)]
    live_tests: bool,

    /// Leave a4x2 running after tests. Useful for investigating test
    /// failures.
    #[clap(long)]
    leave_running: bool,

    /// Path to an a4x2-package bundle generated by a4x2-package xtask.
    #[clap(long, default_value_t = Utf8PathBuf::from(DEFAULT_A4X2_PKG_PATH))]
    package: Utf8PathBuf,
}

struct Environment {
    a4x2_package_tar: Utf8PathBuf,
    work_dir: Utf8PathBuf,
    a4x2_dir: Utf8PathBuf,
    out_dir: Utf8PathBuf,
    in_ci: bool,
}

pub fn run_cmd(args: A4x2DeployArgs) -> Result<()> {
    let sh = Shell::new()?;

    // TODO: do we want to have a configurable falcon dataset?

    let env = {
        // Buildomat sets the CI environment variable. We'll work a bit
        // differently in that case (no cleanup, use /work)
        let in_ci = env::var("CI").is_ok();

        let a4x2_package_tar = match &args.command {
            // Unused by stop command, so harmless to fill in with a default
            DeployCommand::Stop => Utf8PathBuf::from(DEFAULT_A4X2_PKG_PATH),

            DeployCommand::Start(args) => args.package.clone(),
            DeployCommand::RunTests(args) => args.package.clone(),
        };
        let a4x2_package_tar = a4x2_package_tar.canonicalize_utf8()?;

        let home_dir = Utf8PathBuf::from(env::var("HOME")?);
        let work_dir = if in_ci {
            Utf8PathBuf::from("/work/a4x2-deploy")
        } else {
            home_dir.join(".cache/a4x2-deploy")
        };

        // a4x2 dir. will be created by the unpack step
        let a4x2_dir = work_dir.join("a4x2-package-out");

        // Output. Maybe in CI we want this to be /out
        let out_dir = work_dir.join("a4x2-deploy-out");

        Environment { a4x2_package_tar, work_dir, a4x2_dir, out_dir, in_ci }
    };

    match args.command {
        DeployCommand::Stop => teardown_a4x2(&sh, &env)?,
        DeployCommand::Start(_) | DeployCommand::RunTests(_) => {
            if !env.in_ci {
                // Teardown previous deploy if it exists, before wiping the data
                // for it. If this errors, we assume the deploy doesn't exist
                // and carry on.
                let result = teardown_a4x2(&sh, &env);
                eprintln!("teardown result: {:?}", result);
                eprintln!("continuing regardless of whether there were errors");

                // Delete any results from previous runs. We don't mind if
                // there's errors. This needs to run as root in case there are
                // artifacts owned by root left around from the deploy.
                cmd!(sh, "pfexec rm -rf").arg(&env.work_dir).run()?;
            }

            // Create work dir
            fs::create_dir_all(&env.out_dir)?;
            fs::create_dir_all(&env.work_dir)?;
            sh.change_dir(&env.work_dir);

            unpack_a4x2(&sh, &env)?;
            prepare_to_launch_a4x2(&sh, &env)?;

            // Launch a4x2. This can fail. In fact it fails quite a bit...
            // enough that perhaps it's owed at least one retry? But we do not
            // retry right now.
            //
            // We capture the error so we can tear down a4x2 gracefully. Note
            // that in the case of running tests, we will produce an error if
            // launching a4x2 succeeds but the tests themselves fail.
            let result =
                try_launch_a4x2(&sh, &env).and_then(|_| match &args.command {
                    DeployCommand::RunTests(test_args) => {
                        run_tests(&sh, &env, &test_args)
                    }
                    _ => Ok(()),
                });

            // TODO: Collect evidence!!! Try to retrieve the sled-agent logs
            // (and perhaps others?), to help diagnose a4x2 launch failures, and
            // provide context alongside live tests.

            // If we are in CI, we do not need to tear down, because the system
            // state is about to be wiped from existence anyway.
            if !env.in_ci {
                // Outside of CI, we do not tear down if we are just running the
                // start command, or if the user requested to leave a4x2 up
                // after running the tests.
                match args.command {
                    DeployCommand::RunTests(RunTestsArgs {
                        leave_running: false,
                        ..
                    }) => {
                        // We ignore any error here, because the result we
                        // actually want to produce is whether tests passed
                        let _ = teardown_a4x2(&sh, &env);
                    }

                    _ => {
                        // If we are leaving a4x2 up, we ought to be nice and
                        // print some information to the user so they can get
                        // into the system
                        print_a4x2_access_info(&sh, &env);
                    }
                }
            }

            // Unwrap the launch/tests error now, if there was one
            result?;
        }
    }

    Ok(())
}

fn unpack_a4x2(sh: &Shell, env: &Environment) -> Result<()> {
    cmd!(sh, "banner 'unpack'").run()?;
    let tgz_path = &env.a4x2_package_tar;

    if !tgz_path.try_exists()? {
        bail!("a4x2-package bundle does not exist at {}, did you run `cargo xtask a4x2-package`?", tgz_path);
    }

    cmd!(sh, "tar -xvzf {tgz_path}").run()?;

    if !env.a4x2_dir.try_exists()? {
        bail!("extracting a4x2-package bundle did not result in a4x2-package-out/ existing");
    }

    let a4x2_dir = &env.a4x2_dir;
    cmd!(sh, "tar -cf sled-common.tar -C {a4x2_dir}/cargo-bay/sled-common ./")
        .run()?;
    cmd!(sh, "tar -xf sled-common.tar -C {a4x2_dir}/cargo-bay/g0").run()?;
    cmd!(sh, "tar -xf sled-common.tar -C {a4x2_dir}/cargo-bay/g1").run()?;
    cmd!(sh, "tar -xf sled-common.tar -C {a4x2_dir}/cargo-bay/g2").run()?;
    cmd!(sh, "tar -xf sled-common.tar -C {a4x2_dir}/cargo-bay/g3").run()?;

    Ok(())
}

fn prepare_to_launch_a4x2(sh: &Shell, env: &Environment) -> Result<()> {
    cmd!(sh, "banner 'prepare'").run()?;

    // TODO could move these into the a4x2-package bundle.
    // mostly of matter of having a consistent version of propolis.
    exec_remote_script(&sh, "https://raw.githubusercontent.com/oxidecomputer/falcon/main/get-ovmf.sh")?;
    exec_remote_script(&sh, "https://raw.githubusercontent.com/oxidecomputer/falcon/main/get-propolis.sh")?;

    // Generate an ssh key we will use to log into the sleds.
    cmd!(sh, "ssh-keygen -t ed25519 -N '' -f a4x2-ssh-key").run()?;

    // Copy the public side into the cargo bay
    sh.copy_file(
        "a4x2-ssh-key.pub",
        env.a4x2_dir.join("cargo-bay/g0/root_authorized_keys"),
    )?;
    sh.copy_file(
        "a4x2-ssh-key.pub",
        env.a4x2_dir.join("cargo-bay/g1/root_authorized_keys"),
    )?;
    sh.copy_file(
        "a4x2-ssh-key.pub",
        env.a4x2_dir.join("cargo-bay/g2/root_authorized_keys"),
    )?;
    sh.copy_file(
        "a4x2-ssh-key.pub",
        env.a4x2_dir.join("cargo-bay/g3/root_authorized_keys"),
    )?;

    Ok(())
}

fn try_launch_a4x2(sh: &Shell, env: &Environment) -> Result<()> {
    let _popdir = sh.push_dir(&env.a4x2_dir);

    cmd!(sh, "pfexec ./a4x2 launch").run()?;

    // XXX Is there a better way to do this?
    let ce_addr_json =
        cmd!(sh, "./a4x2 exec ce 'ip -4 -j addr show enp0s10'").read()?;

    // Translated from this jq query:
    // .[0].addr_info[] | select(.dynamic == true) | .local
    let ce_addr_json: Value = serde_json::from_str(&ce_addr_json)?;
    let customer_edge_addr = &ce_addr_json[0]["addr_info"]
        .as_array()
        .unwrap()
        .iter()
        .find(|v| v["dynamic"] == Value::Bool(true))
        .ok_or(anyhow!("failed to find customer edge addr"))?["local"]
        .as_str()
        .unwrap();

    // XXX Im told that pinging the gateway from inside the sleds is no longer
    // necessary so I'm leaving it out for now. We'll see if that's true.
    // So far it seems to be.

    cmd!(sh, "pfexec route add 198.51.100.0/24 {customer_edge_addr}").run()?;

    // Not sure how this IP is fixed, but it is
    let api_url = "http://198.51.100.23";
    println!("polling control plane for signs of life for up to 25 minutes");

    // Print the date for the logs' benefit
    let _ = cmd!(sh, "date").run();

    // Timeout = (retries / 2) minutes
    // XXX this is an arbitrary timeout. Should it be configurable? Skippable?
    let mut retries = 50;

    // The important thing here is to do an HTTP request with timeout to the
    // control plane API endpoint. If the server is up, we'll get the page you'd
    // expect for an unauthenticated user. If not, then the request will either
    // - fail
    // - stall
    //
    // Stalling is why we do a timeout, and we need to handle timeout both at
    // the TCP level and the HTTP level. `curl -m 5` will hard-out after 5
    // seconds no matter what's going on.
    //
    // That 5 seconds is arbitrary, but it's been working well over in
    // rackletteadm, from which this logic is copied.
    //
    // We could replace curl with rust code, but make sure we do the same thing!
    while retries > 0 && cmd!(sh, "curl -s -m 5 {api_url}").run().is_err() {
        retries -= 1;
        thread::sleep(time::Duration::from_secs(25));

        if retries % 5 == 0 {
            // I see no reason to error while printing the date
            let _ = cmd!(sh, "date").run();
        }
    }

    if retries == 0 {
        bail!("timed out waiting for control plane");
    }

    Ok(())
}

fn run_tests(sh: &Shell, env: &Environment, args: &RunTestsArgs) -> Result<()> {
    // TODO: support running end to end tests
    if args.live_tests {
        cmd!(sh, "banner 'live tests'").run()?;
        let _popdir = sh.push_dir(&env.a4x2_dir);
        let g0ip = get_node_ip(&sh, env, "g0")?;

        let ssh_host = format!("root@{g0ip}");
        let mut ssh_args_owned = vec!["-i", "../a4x2-ssh-key"];
        ssh_args_owned.extend_from_slice(&INSECURE_SSH_ARGS);
        let ssh_args = &ssh_args_owned;

        cmd!(sh, "scp {ssh_args...} live-tests-bundle.tgz {ssh_host}:/zone/oxz_switch/root/root").run()?;

        // If you want any change in functionality for the test runner, update
        // run-live-tests over in a4x2_package.rs. Don't add it here!
        let switch_zone_script = r#"
            set -euxo pipefail
            tar xvzf live-tests-bundle.tgz
            cd live-tests-bundle
            ./run-live-tests
        "#;

        let remote_script =
            format!("zlogin oxz_switch bash -c '{switch_zone_script}'");

        // Will error if the live tests fail. This is desired.
        cmd!(sh, "ssh {ssh_args...} {ssh_host} {remote_script}").run()?;
    }

    Ok(())
}

fn teardown_a4x2(sh: &Shell, env: &Environment) -> Result<()> {
    let _popdir = sh.push_dir(&env.a4x2_dir);

    // destroy a4x2 stuff
    cmd!(sh, "pfexec ./a4x2 destroy").run()?;

    // destroy the route we added (and any stale ones laying around) Each time
    // we run `route get` we will get one gateway. If multiple routes have been
    // added for this IP (by, say, multiple spinup commands without teardowns in
    // between), then we will need to do this multiple times to fully tear down
    // all of them. But, I don't like unbounded loops, so we will do at max 10,
    // which is a number that seems unlikely enough to reach, to me.
    for _ in 0..10 {
        let mut route_cmd = cmd!(sh, "pfexec route get 198.51.100.0/24");

        // We get an error code when there is no route (and thus, nothing for
        // us to delete!)
        route_cmd.set_ignore_status(true);

        let route = route_cmd.read()?;

        let mut had_gateway = false;
        for ln in route.lines() {
            if ln.contains("gateway") {
                let gateway = ln.split_whitespace().nth(1).ok_or(anyhow!(
                    "teardown_a4x2: could not get gateway for a4x2 route from line {ln}"
                ))?;

                cmd!(sh, "pfexec route delete 198.51.100.0/24 {gateway}")
                    .run()?;

                had_gateway = true;
            }
        }

        if !had_gateway {
            break;
        }
    }

    Ok(())
}

fn print_a4x2_access_info(sh: &Shell, env: &Environment) {
    let a4x2_dir = &env.a4x2_dir;

    // This is best effort. If we can't get the node IPs, it's up to the reader
    // to decide on a course of action. Knowing that we can't get the node IPs
    // is itself useful information, and the stderr from trying should be
    // visible in the scrollback.
    let g0ip = get_node_ip(sh, env, "g0").unwrap_or("Unknown!".to_string());
    let g1ip = get_node_ip(sh, env, "g1").unwrap_or("Unknown!".to_string());
    let g2ip = get_node_ip(sh, env, "g2").unwrap_or("Unknown!".to_string());
    let g3ip = get_node_ip(sh, env, "g3").unwrap_or("Unknown!".to_string());

    let ssh_key_path = env.work_dir.join("a4x2-ssh-key");

    // pour one out for enjoyers of clean indentation
    println!(
        r#"=== A4x2 Access Information ===

The following commands can be run from the a4x2 workdir:

    Connect to a virtual sled's serial console:
    ./a4x2 serial <g0|g1|g2|g3>

    Run a command on a sled, over the serial console:
    ./a4x2 exec <g0|g1|g2|g3> 'command'

Consult ./a4x2 --help for additional a4x2 functionality.

NOTE: you *MUST* `cd` into the a4x2 workdir before using a4x2.

a4x2 workdir: {a4x2_dir}

---

If network setup succeeded, you should also be able to ssh/scp into the sleds as
root. Use the ssh key at:

    {ssh_key_path}

i.e.

    ssh -i {ssh_key_path} root@<ip>

Virtual Sled IP addresses:
- g0: {g0ip}
- g1: {g1ip}
- g2: {g2ip}
- g3: {g3ip}

"#
    );
}

/// Get the IP address of a node, so we can connect or ssh into it
fn get_node_ip(sh: &Shell, env: &Environment, node: &str) -> Result<String> {
    let _popdir = sh.push_dir(&env.a4x2_dir);

    let ipadm = cmd!(sh, "pfexec ./a4x2 exec {node} ipadm").read()?;

    for ln in ipadm.lines() {
        if ln.contains("dhcp") {
            let ipv4 = ln.split_whitespace().nth(3).ok_or(anyhow!("get_host_ip: could not extract IP for node {node} from line {ln}"))?;
            let ipv4 = ipv4.strip_suffix("/24").ok_or(anyhow!("get_host_ip: could not extract IP for node {node} from line {ln}"))?;
            return Ok(ipv4.to_string());
        }
    }

    // Loop above here will return early if we successfully found the IP
    bail!("get_host_ip: could not locate IP for node {node}");
}

/// effectively curl | bash, but reads the full script before running bash
fn exec_remote_script(sh: &Shell, url: &str) -> Result<()> {
    // this could use reqwest instead honestly
    let script = cmd!(sh, "curl -sSfL --retry 10 {url}").read()?;
    cmd!(sh, "bash").stdin(&script).run()?;
    Ok(())
}
