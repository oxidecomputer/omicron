// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Show information about Progenitor-based APIs

use anyhow::{Context, Result, bail};
use camino::Utf8PathBuf;
use clap::{Args, Parser, Subcommand};
use omicron_ls_apis::{
    AllApiMetadata, ApiDependencyFilter, LoadArgs, ServerComponentName,
    SystemApis, VersionedHow,
};
use parse_display::{Display, FromStr};

#[derive(Parser)]
#[command(
    name = "ls-apis",
    bin_name = "ls-apis",
    about = "Show information about Progenitor-based APIs"
)]
struct LsApis {
    /// path to metadata about APIs
    #[arg(long)]
    api_manifest: Option<Utf8PathBuf>,

    #[command(subcommand)]
    cmd: Cmds,
}

#[derive(Subcommand)]
enum Cmds {
    /// print out an Asciidoc table summarizing the APIs
    Adoc,
    /// print out each API, what exports it, and what consumes it
    Apis(ShowDepsArgs),
    /// check the update DAG and propose changes
    Check,
    /// print out APIs exported and consumed by each deployment unit
    DeploymentUnits(DotArgs),
    /// print out APIs exported and consumed, by server component
    Servers(DotArgs),
}

#[derive(Args)]
pub struct ShowDepsArgs {
    /// Show the Rust dependency path resulting in the API dependency
    #[arg(long)]
    show_deps: bool,

    /// Show only API dependencies matching the filter
    #[arg(long, default_value_t)]
    filter: ApiDependencyFilter,
}

#[derive(Args)]
pub struct DotArgs {
    /// What kind of output format to use
    #[arg(long, default_value_t)]
    output_format: OutputFormat,
    /// Show the Rust dependency path resulting in the API dependency
    #[arg(long)]
    show_deps: bool,

    /// Show only API dependencies matching the filter
    #[arg(long, default_value_t)]
    filter: ApiDependencyFilter,
}

#[derive(Clone, Copy, Debug, Default, Display, FromStr)]
#[display(style = "kebab-case")]
pub enum OutputFormat {
    Dot,
    #[default]
    Text,
}

fn main() -> Result<()> {
    let cli_args = LsApis::parse();
    let load_args = LoadArgs::try_from(&cli_args)?;
    let apis = SystemApis::load(load_args)?;

    match cli_args.cmd {
        Cmds::Adoc => run_adoc(&apis),
        Cmds::Apis(args) => run_apis(&apis, args),
        Cmds::Check => run_check(&apis),
        Cmds::DeploymentUnits(args) => run_deployment_units(&apis, args),
        Cmds::Servers(args) => run_servers(&apis, args),
    }
}

fn run_adoc(apis: &SystemApis) -> Result<()> {
    println!("// BEGIN auto-generated by Omicron's `cargo xtask ls-apis adoc`");
    println!("// DO NOT EDIT.");
    println!("// in the Omicron repo.");
    println!(
        ".List of OpenAPI/Progenitor-based interfaces for online upgrade."
    );
    println!(r#"[cols="1h,2,2,2a,2,2", options="header"]"#);
    println!("|===");
    println!("|API");
    println!("|Server location (`repo:path`)");
    println!("|Client packages (`repo:path`)");
    println!("|Consumers (`repo:path`; excluding omdb and tests)");
    println!("|Versioning");
    println!("|Notes");
    println!("");

    let metadata = apis.api_metadata();
    for api in metadata.apis() {
        let Some(server_component) =
            apis.api_producer(&api.client_package_name)
        else {
            continue;
        };
        println!("// DO NOT EDIT.  This table is auto-generated. See above.");
        println!("|{}", api.label);
        println!("|{}", apis.adoc_label(server_component)?);
        println!("|{}", apis.adoc_label(&api.client_package_name)?);
        println!("|");

        for (c, _) in apis.api_consumers(
            &api.client_package_name,
            ApiDependencyFilter::default(),
        )? {
            println!("* {}", apis.adoc_label(c)?);
        }

        match &api.versioned_how {
            VersionedHow::Unknown => println!("|TBD"),
            VersionedHow::Server => println!("|Server-side only"),
            VersionedHow::Client(reason) => {
                println!("|Client-side ({})", reason);
            }
        };

        print!("|{}", api.notes.as_deref().unwrap_or("-\n"));
        println!("");
    }

    println!("|===\n");
    println!("// END auto-generated by Omicron's `cargo xtask ls-apis adoc`");

    Ok(())
}

fn run_apis(apis: &SystemApis, args: ShowDepsArgs) -> Result<()> {
    let metadata = apis.api_metadata();
    for api in metadata.apis() {
        println!("{} (client: {})", api.label, api.client_package_name);
        for (s, dep_paths) in
            apis.api_consumers(&api.client_package_name, args.filter)?
        {
            let (repo_name, package_path) = apis.package_label(s)?;
            println!(
                "    consumed by: {} ({}/{}) via {} path{}",
                s,
                repo_name,
                package_path,
                dep_paths.len(),
                if dep_paths.len() == 1 { "" } else { "s" },
            );
            if args.show_deps {
                for (i, dep_path) in dep_paths.iter().enumerate() {
                    let label = if dep_paths.len() > 1 {
                        format!(" path {}", i + 1)
                    } else {
                        String::new()
                    };

                    for p in dep_path.nodes() {
                        println!("        via{}: {}", label, p);
                    }
                }
            }
        }
        println!("");
    }
    Ok(())
}

fn run_deployment_units(apis: &SystemApis, args: DotArgs) -> Result<()> {
    match &args.output_format {
        OutputFormat::Dot => println!("{}", apis.dot_by_unit(args.filter)?),
        OutputFormat::Text => {
            let metadata = apis.api_metadata();
            for unit in apis.deployment_units() {
                let server_components = apis.deployment_unit_servers(unit)?;
                println!("{}", unit);
                print_server_components(
                    apis,
                    metadata,
                    server_components,
                    "    ",
                    args.show_deps,
                    args.filter,
                )?;
                println!("");
            }
        }
    };

    Ok(())
}

fn print_server_components<'a>(
    apis: &SystemApis,
    metadata: &AllApiMetadata,
    server_components: impl IntoIterator<Item = &'a ServerComponentName>,
    prefix: &str,
    show_deps: bool,
    filter: ApiDependencyFilter,
) -> Result<()> {
    for s in server_components.into_iter() {
        let (repo_name, pkg_path) = apis.package_label(s)?;
        println!("{}{} ({}/{})", prefix, s, repo_name, pkg_path);
        for api in metadata.apis().filter(|a| {
            matches!(
                apis.api_producer(&a.client_package_name),
                Some (name) if name == s
            )
        }) {
            println!(
                "{}    exposes: {} (client = {})",
                prefix, api.label, api.client_package_name
            );
        }
        for (c, path) in apis.component_apis_consumed(s, filter)? {
            println!("{}    consumes: {}", prefix, c);
            if show_deps {
                for p in path.nodes() {
                    println!("{}        via: {}", prefix, p);
                }
            }
        }

        println!("");
    }
    Ok(())
}

fn run_servers(apis: &SystemApis, args: DotArgs) -> Result<()> {
    match &args.output_format {
        OutputFormat::Dot => {
            println!("{}", apis.dot_by_server_component(args.filter)?)
        }
        OutputFormat::Text => {
            let metadata = apis.api_metadata();
            print_server_components(
                apis,
                metadata,
                metadata.server_components(),
                "",
                args.show_deps,
                args.filter,
            )?;
        }
    };
    Ok(())
}

impl TryFrom<&LsApis> for LoadArgs {
    type Error = anyhow::Error;

    fn try_from(args: &LsApis) -> Result<Self> {
        let self_manifest_dir_str = std::env::var("CARGO_MANIFEST_DIR")
            .context("expected CARGO_MANIFEST_DIR in environment")?;
        let self_manifest_dir = Utf8PathBuf::from(self_manifest_dir_str);
        let api_manifest_path = args
            .api_manifest
            .clone()
            .unwrap_or_else(|| self_manifest_dir.join("api-manifest.toml"));
        Ok(LoadArgs { api_manifest_path })
    }
}

fn run_check(apis: &SystemApis) -> Result<()> {
    let dag_check = apis.dag_check()?;

    for (pkg, reasons) in dag_check.proposed_server_managed() {
        println!(
            "proposal: make {:?} server-managed: {}",
            pkg,
            reasons.join(", ")
        );
    }

    for (pkg, reasons) in dag_check.proposed_client_managed() {
        println!(
            "proposal: make {:?} client-managed: {}",
            pkg,
            reasons.join(", ")
        );
    }

    for (pkg1, pkg2) in dag_check.proposed_upick() {
        println!(
            "proposal: choose either {:?} or {:?} to be client-managed \
             (they directly depend on each other)",
            pkg1, pkg2,
        );
    }

    println!("\n");
    println!("Server-managed APIs:\n");
    for api in apis
        .api_metadata()
        .apis()
        .filter(|f| f.deployed() && f.versioned_how == VersionedHow::Server)
    {
        println!(
            "    {} ({}, exposed by {})",
            api.label,
            api.client_package_name,
            apis.api_producer(&api.client_package_name).unwrap()
        );
    }

    println!("\n");
    println!("Client-managed API:\n");
    for api in apis.api_metadata().apis().filter(|f| f.deployed()) {
        if let VersionedHow::Client(reason) = &api.versioned_how {
            println!(
                "    {} ({}, exposed by {})",
                api.label,
                api.client_package_name,
                apis.api_producer(&api.client_package_name).unwrap()
            );
            println!("        reason: {}", reason);
        }
    }

    println!("\n");
    print!("APIs with unknown version management:");
    let unknown: Vec<_> = apis
        .api_metadata()
        .apis()
        .filter(|f| f.versioned_how == VersionedHow::Unknown)
        .collect();
    if unknown.is_empty() {
        println!(" none");
    } else {
        println!("\n");
        for api in unknown {
            println!(
                "    {} ({}, exposed by {})",
                api.label,
                api.client_package_name,
                apis.api_producer(&api.client_package_name).unwrap()
            );
        }
        bail!("at least one API has unknown version strategy (see above)");
    }

    Ok(())
}
