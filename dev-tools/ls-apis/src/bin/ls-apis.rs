// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Show information about Progenitor-based APIs

use anyhow::{Context, Result, bail};
use camino::Utf8PathBuf;
use clap::{Args, Parser, Subcommand};
use indent_write::indentable::Indentable;
use omicron_ls_apis::{
    AllApiMetadata, ApiConsumerStatus, ApiDependencyFilter, ApiMetadata,
    FailedConsumerCheck, LoadArgs, ServerComponentName, SystemApis,
    VersionedHow, plural,
};
use parse_display::{Display, FromStr};

#[derive(Parser)]
#[command(
    name = "ls-apis",
    bin_name = "ls-apis",
    about = "Show information about Progenitor-based APIs"
)]
struct LsApis {
    /// path to metadata about APIs
    #[arg(long)]
    api_manifest: Option<Utf8PathBuf>,

    #[command(subcommand)]
    cmd: Cmds,
}

#[derive(Subcommand)]
enum Cmds {
    /// print out an Asciidoc table summarizing the APIs
    Adoc,
    /// print out each API, what exports it, and what consumes it
    Apis(ShowDepsArgs),
    /// check the update DAG and propose changes
    Check,
    /// print out APIs exported and consumed by each deployment unit
    DeploymentUnits(DotArgs),
    /// print out APIs exported and consumed, by server component
    Servers(DotArgs),
}

#[derive(Args)]
pub struct ShowDepsArgs {
    /// Show the Rust dependency path resulting in the API dependency
    #[arg(long)]
    show_deps: bool,

    /// Show only API dependencies matching the filter
    #[arg(long, default_value_t)]
    filter: ApiDependencyFilter,
}

#[derive(Args)]
pub struct DotArgs {
    /// What kind of output format to use
    #[arg(long, default_value_t)]
    output_format: OutputFormat,
    /// Show the Rust dependency path resulting in the API dependency
    #[arg(long)]
    show_deps: bool,

    /// Show only API dependencies matching the filter
    #[arg(long, default_value_t)]
    filter: ApiDependencyFilter,
}

#[derive(Clone, Copy, Debug, Default, Display, FromStr)]
#[display(style = "kebab-case")]
pub enum OutputFormat {
    Dot,
    #[default]
    Text,
}

fn main() -> Result<()> {
    let cli_args = LsApis::parse();
    let load_args = LoadArgs::try_from(&cli_args)?;
    let apis = SystemApis::load(load_args)?;

    match cli_args.cmd {
        Cmds::Adoc => run_adoc(&apis),
        Cmds::Apis(args) => run_apis(&apis, args),
        Cmds::Check => run_check(&apis),
        Cmds::DeploymentUnits(args) => run_deployment_units(&apis, args),
        Cmds::Servers(args) => run_servers(&apis, args),
    }
}

fn run_adoc(apis: &SystemApis) -> Result<()> {
    println!("// BEGIN auto-generated by Omicron's `cargo xtask ls-apis adoc`");
    println!("// DO NOT EDIT.");
    println!("// in the Omicron repo.");
    println!(
        ".List of OpenAPI/Progenitor-based interfaces for online upgrade."
    );
    println!(r#"[cols="1h,2,2,2a,2,2", options="header"]"#);
    println!("|===");
    println!("|API");
    println!("|Server location (`repo:path`)");
    println!("|Client packages (`repo:path`)");
    println!("|Consumers (`repo:path`; excluding omdb and tests)");
    println!("|Versioning");
    println!("|Notes");
    println!("");

    let metadata = apis.api_metadata();
    for api in metadata.apis() {
        println!("// DO NOT EDIT.  This table is auto-generated. See above.");
        println!("|{}", api.label);

        println!("|");
        for server_component in apis.api_producers(&api.client_package_name) {
            println!("* {}", apis.adoc_label(server_component)?);
        }

        println!("|{}", apis.adoc_label(&api.client_package_name)?);

        println!("|");
        for consumer in apis.api_consumers(
            &api.client_package_name,
            ApiDependencyFilter::default(),
        )? {
            println!("* {}", apis.adoc_label(&consumer.server_pkgname)?);
        }

        match &api.versioned_how {
            VersionedHow::Unknown => println!("|TBD"),
            VersionedHow::Server => println!("|Server-side only"),
            VersionedHow::Client(reason) => {
                println!("|Client-side ({})", reason);
            }
        };

        print!("|{}", api.notes.as_deref().unwrap_or("-\n"));
        println!("");
    }

    println!("|===\n");
    println!("// END auto-generated by Omicron's `cargo xtask ls-apis adoc`");

    Ok(())
}

fn run_apis(apis: &SystemApis, args: ShowDepsArgs) -> Result<()> {
    let mut error_count = 0;

    let metadata = apis.api_metadata();
    for api in metadata.apis() {
        println!("{} (client: {})", api.label, api.client_package_name);
        for c in apis.api_consumers(&api.client_package_name, args.filter)? {
            let (repo_name, package_path) =
                apis.package_label(c.server_pkgname)?;
            println!(
                "    consumed by: {} ({}/{}) via {} path{}",
                c.server_pkgname,
                repo_name,
                package_path,
                c.dep_paths.len(),
                if c.dep_paths.len() == 1 { "" } else { "s" },
            );
            if args.show_deps {
                for (i, dep_path) in c.dep_paths.iter().enumerate() {
                    let label = if c.dep_paths.len() > 1 {
                        format!(" path {}", i + 1)
                    } else {
                        String::new()
                    };

                    for p in dep_path.nodes() {
                        println!("        via{}: {}", label, p);
                    }
                }
            }
            match c.status {
                ApiConsumerStatus::NoAssertion => {
                    // We don't know whether it's okay for this API to be
                    // present.
                }
                ApiConsumerStatus::Expected { reason } => {
                    println!("        status: expected, reason: {reason}");
                }
                ApiConsumerStatus::Unexpected => {
                    println!("        error: unexpected dependency");
                    error_count += 1;
                }
            }
        }
        if let Some(missing) = apis.missing_consumers(&api.client_package_name)
        {
            println!("{}", missing.display(apis).indented("    "));
            error_count += missing.error_count();
        }
        println!();
    }
    if error_count > 0 {
        bail!(
            "{error_count} {} reported (see above)",
            plural::errors_str(error_count)
        );
    }
    Ok(())
}

fn run_deployment_units(apis: &SystemApis, args: DotArgs) -> Result<()> {
    match &args.output_format {
        OutputFormat::Dot => println!("{}", apis.dot_by_unit(args.filter)?),
        OutputFormat::Text => {
            let metadata = apis.api_metadata();
            for unit in apis.deployment_units() {
                let server_components = apis.deployment_unit_servers(unit)?;
                println!("{}", unit);
                print_server_components(
                    apis,
                    metadata,
                    server_components,
                    "    ",
                    args.show_deps,
                    args.filter,
                )?;
                println!("");
            }
        }
    };

    Ok(())
}

fn print_server_components<'a>(
    apis: &SystemApis,
    metadata: &AllApiMetadata,
    server_components: impl IntoIterator<Item = &'a ServerComponentName>,
    prefix: &str,
    show_deps: bool,
    filter: ApiDependencyFilter,
) -> Result<()> {
    for s in server_components.into_iter() {
        let (repo_name, pkg_path) = apis.package_label(s)?;
        println!("{}{} ({}/{})", prefix, s, repo_name, pkg_path);
        for api in metadata
            .apis()
            .filter(|a| apis.is_producer_of(s, &a.client_package_name))
        {
            println!(
                "{}    exposes: {} (client = {})",
                prefix, api.label, api.client_package_name
            );
        }
        for (c, path) in apis.component_apis_consumed(s, filter)? {
            println!("{}    consumes: {}", prefix, c);
            if show_deps {
                for p in path.nodes() {
                    println!("{}        via: {}", prefix, p);
                }
            }
        }

        println!("");
    }
    Ok(())
}

fn run_servers(apis: &SystemApis, args: DotArgs) -> Result<()> {
    match &args.output_format {
        OutputFormat::Dot => {
            println!("{}", apis.dot_by_server_component(args.filter)?)
        }
        OutputFormat::Text => {
            let metadata = apis.api_metadata();
            print_server_components(
                apis,
                metadata,
                metadata.server_components(),
                "",
                args.show_deps,
                args.filter,
            )?;
        }
    };
    Ok(())
}

impl TryFrom<&LsApis> for LoadArgs {
    type Error = anyhow::Error;

    fn try_from(args: &LsApis) -> Result<Self> {
        let self_manifest_dir_str = std::env::var("CARGO_MANIFEST_DIR")
            .context("expected CARGO_MANIFEST_DIR in environment")?;
        let self_manifest_dir = Utf8PathBuf::from(self_manifest_dir_str);
        let api_manifest_path = args
            .api_manifest
            .clone()
            .unwrap_or_else(|| self_manifest_dir.join("api-manifest.toml"));
        Ok(LoadArgs { api_manifest_path })
    }
}

fn run_check(apis: &SystemApis) -> Result<()> {
    let dag_check = apis.dag_check()?;

    for (pkg, reasons) in dag_check.proposed_server_managed() {
        println!(
            "proposal: make {:?} server-managed: {}",
            pkg,
            reasons.join(", ")
        );
    }

    for (pkg, reasons) in dag_check.proposed_client_managed() {
        println!(
            "proposal: make {:?} client-managed: {}",
            pkg,
            reasons.join(", ")
        );
    }

    for (pkg1, pkg2) in dag_check.proposed_upick() {
        println!(
            "proposal: choose either {:?} or {:?} to be client-managed \
             (they directly depend on each other)",
            pkg1, pkg2,
        );
    }

    fn print_api_and_producers(api: &ApiMetadata, apis: &SystemApis) {
        print!("    {} ({}", api.label, api.client_package_name,);
        let mut producers = apis.api_producers(&api.client_package_name);
        if let Some(producer) = producers.next() {
            print!(", exposed by {producer}");
            for producer in producers {
                print!(", {producer}")
            }
        }
        println!(")");
    }

    fn print_failed_consumer_check(
        api: &ApiMetadata,
        check: &FailedConsumerCheck,
        apis: &SystemApis,
    ) {
        println!("    {} ({}):", api.label, api.client_package_name);
        for consumer in &check.unexpected {
            let deployment_unit =
                apis.server_component_unit(consumer).unwrap_or_else(|| {
                    panic!(
                        "consumer {consumer} doesn't have an associated \
                         deployment unit (this is checked at load time)"
                    );
                });
            println!(
                "        error: unexpected dependency on {consumer} (part of {deployment_unit})"
            );
        }

        if let Some(missing) = check.missing {
            println!("{}", missing.display(apis).indented("        "));
        }
    }

    println!("\n");
    println!("Server-managed APIs:\n");
    for api in apis
        .api_metadata()
        .apis()
        .filter(|f| f.deployed() && f.versioned_how == VersionedHow::Server)
    {
        print_api_and_producers(api, apis);
    }

    println!("\n");
    println!("Client-managed API:\n");
    for api in apis.api_metadata().apis().filter(|f| f.deployed()) {
        if let VersionedHow::Client(reason) = &api.versioned_how {
            print_api_and_producers(api, apis);
            println!("        reason: {}", reason);
        }
    }

    let mut error_count = 0;

    println!("\n");
    print!("APIs with unknown version management:");
    let unknown: Vec<_> = apis
        .api_metadata()
        .apis()
        .filter(|f| f.versioned_how == VersionedHow::Unknown)
        .collect();
    if unknown.is_empty() {
        println!(" none");
    } else {
        println!("\n");
        for api in unknown {
            print_api_and_producers(api, apis);
            error_count += 1;
        }
    }

    println!("\n");
    print!("APIs that failed consumer checks:");
    if dag_check.failed_consumers().is_empty() {
        println!(" none");
    } else {
        println!("\n");
        for c in dag_check.failed_consumers() {
            let api = apis
                .api_metadata()
                .client_pkgname_lookup(c.client_pkgname)
                .unwrap_or_else(|| {
                    panic!(
                        "client package name {} not found in API metadata",
                        c.client_pkgname
                    )
                });
            print_failed_consumer_check(api, c, apis);
            error_count += c.error_count();
        }
    }

    if error_count > 0 {
        println!("\n");
        bail!(
            "{error_count} {} reported (see above)",
            plural::errors_str(error_count)
        );
    }

    Ok(())
}
