// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Schema management utilities

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use nexus_db_model::KNOWN_VERSIONS;
use std::collections::HashSet;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

#[derive(Parser)]
#[command(name = "schema", about = "Schema management utilities")]
struct Args {
    #[command(subcommand)]
    cmd: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate previous schema file for testing migration from last version
    GeneratePrevious,
}

fn main() -> Result<()> {
    let args = Args::parse();
    match args.cmd {
        Commands::GeneratePrevious => generate_previous_schema(),
    }
}

fn generate_previous_schema() -> Result<()> {
    println!("Generating previous schema file for migration testing");

    // Find the workspace root
    let workspace_root = find_workspace_root()?;

    // Clean and recreate the previous-schema directory
    let previous_schema_dir =
        workspace_root.join("schema/crdb/previous-schema");

    if previous_schema_dir.exists() {
        println!("Cleaning existing previous-schema directory");
        fs::remove_dir_all(&previous_schema_dir).with_context(|| {
            format!("Failed to remove directory: {:?}", previous_schema_dir)
        })?;
    }

    fs::create_dir_all(&previous_schema_dir).with_context(|| {
        format!("Failed to create directory: {:?}", previous_schema_dir)
    })?;

    // Create a warning file about auto-generated content
    let warning_file = previous_schema_dir.join("WARNING.txt");
    let warning_content = r#"WARNING: Auto-generated files

All files in this directory are automatically generated by:
    cargo xtask schema generate-previous

Do not edit these files manually. They will be overwritten.

These files are generated from historical git commits to provide
previous schema versions for migration testing.

To modify which versions are generated, edit:
    schema/crdb/previous-schemas.txt
"#;
    fs::write(&warning_file, warning_content).with_context(|| {
        format!("Failed to write WARNING.txt to {:?}", warning_file)
    })?;

    // Read the configuration file to determine which versions to generate
    let config_file = workspace_root.join("schema/crdb/previous-schemas.txt");
    let versions_to_generate = parse_previous_schemas_config(&config_file)?;

    println!("Found {} versions to generate", versions_to_generate.len());

    // Generate each requested version
    for version in &versions_to_generate {
        println!("Processing version: {}", version);

        // Find the git commit where this version was the current SCHEMA_VERSION
        let commit_hash =
            find_commit_for_schema_version(&workspace_root, &version)?;
        println!("Found commit {} for version {}", &commit_hash[..8], version);

        // Get the dbinit.sql from this commit
        let dbinit_content =
            get_dbinit_from_commit(&workspace_root, &commit_hash)?;

        // Save it to the previous-schema directory
        let version_dir = previous_schema_dir.join(&version.to_string());
        fs::create_dir_all(&version_dir).with_context(|| {
            format!("Failed to create version directory: {:?}", version_dir)
        })?;

        let dbinit_file = version_dir.join("dbinit.sql");
        fs::write(&dbinit_file, dbinit_content).with_context(|| {
            format!("Failed to write dbinit.sql to {:?}", dbinit_file)
        })?;

        println!(
            "Saved dbinit.sql for version {} in {:?}",
            version, version_dir
        );
    }

    println!(
        "Generated {} schema files in {:?}",
        versions_to_generate.len(),
        previous_schema_dir
    );
    Ok(())
}

fn parse_previous_schemas_config(
    config_file: &std::path::PathBuf,
) -> Result<Vec<semver::Version>> {
    let content = fs::read_to_string(config_file).with_context(|| {
        format!("Failed to read config file: {:?}", config_file)
    })?;

    let mut versions = Vec::new();

    for line in content.lines() {
        let line = line.trim();

        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        if line == "PREVIOUS" {
            // Get the previous version from KNOWN_VERSIONS
            if KNOWN_VERSIONS.len() < 2 {
                anyhow::bail!(
                    "Need at least 2 known versions to find previous version. Current count: {}",
                    KNOWN_VERSIONS.len()
                );
            }
            let previous_version = KNOWN_VERSIONS[1].semver().clone();
            versions.push(previous_version);
        } else {
            // Parse as semver
            let version = semver::Version::parse(line).with_context(|| {
                format!("Failed to parse version: {}", line)
            })?;
            versions.push(version);
        }
    }

    // Remove duplicates while preserving order
    let mut seen = HashSet::new();
    let mut unique_versions = Vec::new();
    for version in versions {
        if seen.insert(version.clone()) {
            unique_versions.push(version);
        }
    }

    Ok(unique_versions)
}

fn find_commit_for_schema_version(
    workspace_root: &PathBuf,
    target_version: &semver::Version,
) -> Result<String> {
    // Search through git history for both possible file locations
    // First try the new location (schema_versions.rs)
    let git_log_output = Command::new("git")
        .current_dir(workspace_root)
        .args([
            "log",
            "--oneline",
            "--format=%H",
            "nexus/db-model/src/schema_versions.rs",
        ])
        .output()
        .context("Failed to run git log for schema_versions.rs")?;

    if git_log_output.status.success() {
        let commits = String::from_utf8(git_log_output.stdout)?;
        for commit_hash in commits.lines() {
            let commit_hash = commit_hash.trim();
            if commit_hash.is_empty() {
                continue;
            }

            if let Some(version) =
                get_schema_version_from_commit(workspace_root, commit_hash)?
            {
                if version == *target_version {
                    return Ok(commit_hash.to_string());
                }
            }
        }
    }

    // Try the old location (schema.rs) for older versions
    let git_log_output_old = Command::new("git")
        .current_dir(workspace_root)
        .args([
            "log",
            "--oneline",
            "--format=%H",
            "--",
            "nexus/db-model/src/schema.rs",
        ])
        .output()
        .context("Failed to run git log for schema.rs")?;

    if git_log_output_old.status.success() {
        let commits = String::from_utf8(git_log_output_old.stdout)?;
        for commit_hash in commits.lines() {
            let commit_hash = commit_hash.trim();
            if commit_hash.is_empty() {
                continue;
            }

            if let Some(version) =
                get_schema_version_from_commit(workspace_root, commit_hash)?
            {
                if version == *target_version {
                    return Ok(commit_hash.to_string());
                }
            }
        }
    }

    anyhow::bail!(
        "Could not find git commit for schema version {}",
        target_version
    )
}

fn find_workspace_root() -> Result<PathBuf> {
    let current_dir =
        std::env::current_dir().context("Failed to get current directory")?;
    current_dir
        .ancestors()
        .find(|p| p.join("Cargo.toml").exists() && p.join(".git").exists())
        .map(|p| p.to_path_buf())
        .ok_or_else(|| anyhow::anyhow!("Could not find workspace root"))
}

fn get_schema_version_from_commit(
    workspace_root: &PathBuf,
    commit_hash: &str,
) -> Result<Option<semver::Version>> {
    // Try the new location first (schema_versions.rs)
    let show_output = Command::new("git")
        .current_dir(workspace_root)
        .args([
            "show",
            &format!("{}:nexus/db-model/src/schema_versions.rs", commit_hash),
        ])
        .output()
        .context("Failed to run git show")?;

    let file_content = if show_output.status.success() {
        String::from_utf8(show_output.stdout)?
    } else {
        // Try the old location (schema.rs) for older commits
        let show_output_old = Command::new("git")
            .current_dir(workspace_root)
            .args([
                "show",
                &format!("{}:nexus/db-model/src/schema.rs", commit_hash),
            ])
            .output()
            .context("Failed to run git show for old schema.rs")?;

        if !show_output_old.status.success() {
            return Ok(None); // File doesn't exist in either location
        }

        String::from_utf8(show_output_old.stdout)?
    };

    // Parse the SCHEMA_VERSION from the file
    for line in file_content.lines() {
        if line.contains("pub const SCHEMA_VERSION")
            && (line.contains("Version::new(")
                || line.contains("SemverVersion::new("))
        {
            // Handle both old format (SemverVersion::new) and new format (Version::new)
            let version_part = if line.contains("Version::new(") {
                line.split("Version::new(").nth(1)
            } else {
                line.split("SemverVersion::new(").nth(1)
            };

            if let Some(version_part) = version_part {
                if let Some(version_nums) = version_part.split(')').next() {
                    let parts: Vec<&str> = version_nums.split(',').collect();
                    if parts.len() >= 3 {
                        if let (Ok(major), Ok(minor), Ok(patch)) = (
                            parts[0].trim().parse::<u64>(),
                            parts[1].trim().parse::<u64>(),
                            parts[2].trim().parse::<u64>(),
                        ) {
                            return Ok(Some(semver::Version::new(
                                major, minor, patch,
                            )));
                        }
                    }
                }
            }
            break;
        }
    }

    Ok(None)
}

fn get_dbinit_from_commit(
    workspace_root: &PathBuf,
    commit_hash: &str,
) -> Result<String> {
    let show_output = Command::new("git")
        .current_dir(workspace_root)
        .args(["show", &format!("{}:schema/crdb/dbinit.sql", commit_hash)])
        .output()
        .context("Failed to run git show for dbinit.sql")?;

    if !show_output.status.success() {
        anyhow::bail!("dbinit.sql not found in commit");
    }

    Ok(String::from_utf8(show_output.stdout)?)
}
