// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Generated OpenAPI spec files

use crate::{
    apis::{ApiIdent, ManagedApis},
    spec_files_generic::{ApiSpecFile, ApiSpecFileName, ApiSpecFilesBuilder},
};
use std::collections::BTreeMap;

/// Container for OpenAPI spec files generated by the code in this repo
///
/// Most validation is not done at this point.
/// XXX-dap be more specific about what has and has not been validated at this
/// point.
// XXX-dap actually, maybe the thing to do here is to have one type with a
// sentinel generic type paramter, like SpecFileContainer<Local>.
#[derive(Debug)]
pub struct GeneratedFiles {
    pub spec_files: BTreeMap<
        ApiIdent,
        BTreeMap<semver::Version, Vec<GeneratedApiSpecFile>>,
    >,
    pub errors: Vec<anyhow::Error>,
    pub warnings: Vec<anyhow::Error>,
}

pub struct GeneratedApiSpecFile(ApiSpecFile);
NewtypeDebug! { () pub struct GeneratedApiSpecFile(ApiSpecFile); }
NewtypeDeref! { () pub struct GeneratedApiSpecFile(ApiSpecFile); }
NewtypeDerefMut! { () pub struct GeneratedApiSpecFile(ApiSpecFile); }
NewtypeFrom! { () pub struct GeneratedApiSpecFile(ApiSpecFile); }

impl GeneratedFiles {
    pub fn generate(apis: &ManagedApis) -> anyhow::Result<GeneratedFiles> {
        let mut api_files = ApiSpecFilesBuilder::new(apis);

        for api in apis.iter_apis() {
            if api.is_lockstep() {
                for version in api.iter_versions_semver() {
                    let contents = api.generate_spec_bytes(version)?;
                    let file_name = ApiSpecFileName::for_lockstep(api);
                    api_files.load_contents(file_name, contents);
                }
            } else {
                // unwrap(): this returns `Some` for versioned APIs.
                let supported_versions = api.iter_versioned_versions().unwrap();
                for supported_version in supported_versions {
                    let version = supported_version.semver();
                    let contents = api.generate_spec_bytes(version)?;
                    let label = supported_version.label();
                    let file_name = ApiSpecFileName::for_versioned(
                        api,
                        version.clone(),
                        label.to_owned(),
                    );
                    api_files.load_contents(file_name, contents);
                }
            }
        }

        let (spec_files, errors, warnings) = api_files.into_parts();
        Ok(GeneratedFiles { spec_files, errors, warnings })
    }
}
