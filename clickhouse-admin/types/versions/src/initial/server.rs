// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Server-specific types for the ClickHouse Admin Server and Single APIs.

use super::config::{ClickhouseHost, path_schema};
use camino::Utf8PathBuf;
use chrono::{DateTime, Utc};
use daft::Diffable;
use derive_more::{Add, AddAssign, Display, From};
use omicron_common::api::external::Generation;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::net::Ipv6Addr;

/// A unique ID for a Clickhouse Server
#[derive(
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    From,
    Add,
    AddAssign,
    Display,
    JsonSchema,
    Serialize,
    Deserialize,
    Diffable,
)]
pub struct ServerId(pub u64);

/// The top most type for configuring clickhouse-servers via
/// clickhouse-admin-server-api
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct ServerConfigurableSettings {
    /// A unique identifier for the configuration generation.
    pub generation: Generation,
    /// Configurable settings for a ClickHouse replica server node.
    pub settings: ServerSettings,
}

/// Configurable settings for a ClickHouse replica server node.
#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ServerSettings {
    /// Directory for the generated server configuration XML file
    #[schemars(schema_with = "path_schema")]
    pub config_dir: Utf8PathBuf,
    /// Unique ID of the server node
    pub id: ServerId,
    /// Directory for all files generated by ClickHouse itself
    #[schemars(schema_with = "path_schema")]
    pub datastore_path: Utf8PathBuf,
    /// Address the server is listening on
    pub listen_addr: Ipv6Addr,
    /// Addresses for each of the individual nodes in the Keeper cluster
    pub keepers: Vec<ClickhouseHost>,
    /// Addresses for each of the individual replica servers
    pub remote_servers: Vec<ClickhouseHost>,
}

#[derive(
    Clone,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Deserialize,
    Serialize,
    JsonSchema,
)]
#[serde(rename_all = "snake_case")]
/// Contains information about distributed ddl queries (ON CLUSTER clause) that were
/// executed on a cluster.
pub struct DistributedDdlQueue {
    /// Query id
    pub entry: String,
    /// Version of the entry
    pub entry_version: u64,
    /// Host that initiated the DDL operation
    pub initiator_host: String,
    /// Port used by the initiator
    pub initiator_port: u16,
    /// Cluster name
    pub cluster: String,
    /// Query executed
    pub query: String,
    /// Settings used in the DDL operation
    pub settings: BTreeMap<String, String>,
    /// Query created time
    pub query_create_time: DateTime<Utc>,
    /// Hostname
    pub host: Ipv6Addr,
    /// Host Port
    pub port: u16,
    /// Status of the query
    pub status: String,
    /// Exception code
    pub exception_code: u64,
    /// Exception message
    pub exception_text: String,
    /// Query finish time
    pub query_finish_time: DateTime<Utc>,
    /// Duration of query execution (in milliseconds)
    pub query_duration_ms: u64,
}

#[inline]
fn default_interval() -> u64 {
    60
}

#[inline]
fn default_time_range() -> u64 {
    86400
}

#[inline]
fn default_timestamp_format() -> TimestampFormat {
    TimestampFormat::Utc
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// Available metrics tables in the `system` database
pub enum SystemTable {
    AsynchronousMetricLog,
    MetricLog,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// Which format should the timestamp be in.
pub enum TimestampFormat {
    Utc,
    UnixEpoch,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct MetricInfoPath {
    /// Table to query in the `system` database
    pub table: SystemTable,
    /// Name of the metric to retrieve.
    pub metric: String,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct TimeSeriesSettingsQuery {
    /// The interval to collect monitoring metrics in seconds.
    /// Default is 60 seconds.
    #[serde(default = "default_interval")]
    pub interval: u64,
    /// Range of time to collect monitoring metrics in seconds.
    /// Default is 86400 seconds (24 hrs).
    #[serde(default = "default_time_range")]
    pub time_range: u64,
    /// Format in which each timeseries timestamp will be in.
    /// Default is UTC
    #[serde(default = "default_timestamp_format")]
    pub timestamp_format: TimestampFormat,
}

/// Settings to specify which time series to retrieve.
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct SystemTimeSeriesSettings {
    /// Time series retrieval settings (time range and interval)
    pub retrieval_settings: TimeSeriesSettingsQuery,
    /// Database table and name of the metric to retrieve
    pub metric_info: MetricInfoPath,
}

// Our OpenAPI generator does not allow for enums to be of different
// primitive types. Because Utc is a "string" in json, Unix cannot be an int.
// This is why we set it as a `String`.
#[derive(Debug, Display, Serialize, Deserialize, JsonSchema, PartialEq)]
#[serde(untagged)]
pub enum Timestamp {
    Utc(DateTime<Utc>),
    Unix(String),
}

/// Retrieved time series from the internal `system` database.
#[derive(Debug, Serialize, Deserialize, JsonSchema, PartialEq)]
#[serde(rename_all = "snake_case")]
pub struct SystemTimeSeries {
    pub time: String,
    pub value: f64,
    // TODO: Would be really nice to have an enum with possible units (s, ms, bytes)
    // Not sure if I can even add this, the system tables don't mention units at all.
}
