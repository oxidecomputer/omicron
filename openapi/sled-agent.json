{
  "openapi": "3.0.3",
  "info": {
    "title": "Oxide Sled Agent API",
    "description": "API for interacting with individual sleds",
    "contact": {
      "url": "https://oxide.computer",
      "email": "api@oxide.computer"
    },
    "version": "0.0.1"
  },
  "paths": {
    "/artifacts": {
      "get": {
        "operationId": "artifact_list",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtifactListResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/artifacts/{sha256}": {
      "put": {
        "operationId": "artifact_put",
        "parameters": [
          {
            "in": "path",
            "name": "sha256",
            "required": true,
            "schema": {
              "type": "string",
              "format": "hex string (32 bytes)"
            }
          },
          {
            "in": "query",
            "name": "generation",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Generation"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtifactPutResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/artifacts/{sha256}/copy-from-depot": {
      "post": {
        "operationId": "artifact_copy_from_depot",
        "parameters": [
          {
            "in": "path",
            "name": "sha256",
            "required": true,
            "schema": {
              "type": "string",
              "format": "hex string (32 bytes)"
            }
          },
          {
            "in": "query",
            "name": "generation",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/Generation"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ArtifactCopyFromDepotBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "successfully enqueued operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtifactCopyFromDepotResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/artifacts-config": {
      "get": {
        "operationId": "artifact_config_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ArtifactConfig"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "artifact_config_put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ArtifactConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/boot-disk/{boot_disk}/os/write": {
      "post": {
        "summary": "Write a new host OS image to the specified boot disk",
        "operationId": "host_os_write_start",
        "parameters": [
          {
            "in": "path",
            "name": "boot_disk",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/M2Slot"
            }
          },
          {
            "in": "query",
            "name": "sha3_256_digest",
            "required": true,
            "schema": {
              "type": "string",
              "format": "hex string (32 bytes)"
            }
          },
          {
            "in": "query",
            "name": "update_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/boot-disk/{boot_disk}/os/write/status": {
      "get": {
        "operationId": "host_os_write_status_get",
        "parameters": [
          {
            "in": "path",
            "name": "boot_disk",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/M2Slot"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BootDiskOsWriteStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/boot-disk/{boot_disk}/os/write/status/{update_id}": {
      "delete": {
        "summary": "Clear the status of a completed write of a new host OS",
        "operationId": "host_os_write_status_delete",
        "parameters": [
          {
            "in": "path",
            "name": "boot_disk",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/M2Slot"
            }
          },
          {
            "in": "path",
            "name": "update_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/bootstore/status": {
      "get": {
        "summary": "Get the internal state of the local bootstore node",
        "operationId": "bootstore_status",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BootstoreStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/disks/{disk_id}": {
      "put": {
        "operationId": "disk_put",
        "parameters": [
          {
            "in": "path",
            "name": "disk_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiskEnsureBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DiskRuntimeState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/eip-gateways": {
      "put": {
        "summary": "Update per-NIC IP address <-> internet gateway mappings.",
        "operationId": "set_eip_gateways",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIpGatewayMap"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/inventory": {
      "get": {
        "summary": "Fetch basic information about this sled",
        "operationId": "inventory",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Inventory"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/network-bootstore-config": {
      "get": {
        "summary": "This API endpoint is only reading the local sled agent's view of the",
        "description": "bootstore. The boostore is a distributed data store that is eventually consistent. Reads from individual nodes may not represent the latest state.",
        "operationId": "read_network_bootstore_config_cache",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EarlyNetworkConfig"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "write_network_bootstore_config",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EarlyNetworkConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/omicron-config": {
      "put": {
        "operationId": "omicron_config_put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OmicronSledConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sled-identifiers": {
      "get": {
        "summary": "Fetch sled identifiers",
        "operationId": "sled_identifiers",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledIdentifiers"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sled-role": {
      "get": {
        "operationId": "sled_role_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledRole"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sleds": {
      "put": {
        "summary": "Add a sled to a rack that was already initialized via RSS",
        "operationId": "sled_add",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddSledRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/dladm-info": {
      "get": {
        "operationId": "support_dladm_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SledDiagnosticsQueryOutput",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/health-check": {
      "get": {
        "operationId": "support_health_check",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SledDiagnosticsQueryOutput",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/ipadm-info": {
      "get": {
        "operationId": "support_ipadm_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SledDiagnosticsQueryOutput",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/logs/download/{zone}": {
      "get": {
        "summary": "This endpoint returns a zip file of a zone's logs organized by service.",
        "operationId": "support_logs_download",
        "parameters": [
          {
            "in": "path",
            "name": "zone",
            "description": "The zone for which one would like to collect logs for",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "max_rotated",
            "description": "The max number of rotated logs to include in the final support bundle",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "uint",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/support/logs/zones": {
      "get": {
        "summary": "This endpoint returns a list of known zones on a sled that have service",
        "description": "logs that can be collected into a support bundle.",
        "operationId": "support_logs",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_String",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/nvmeadm-info": {
      "get": {
        "operationId": "support_nvmeadm_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/pargs-info": {
      "get": {
        "operationId": "support_pargs_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SledDiagnosticsQueryOutput",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/pfiles-info": {
      "get": {
        "operationId": "support_pfiles_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SledDiagnosticsQueryOutput",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/pstack-info": {
      "get": {
        "operationId": "support_pstack_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SledDiagnosticsQueryOutput",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/zfs-info": {
      "get": {
        "operationId": "support_zfs_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/zoneadm-info": {
      "get": {
        "operationId": "support_zoneadm_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support/zpool-info": {
      "get": {
        "operationId": "support_zpool_info",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledDiagnosticsQueryOutput"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support-bundles/{zpool_id}/{dataset_id}": {
      "get": {
        "summary": "List all support bundles within a particular dataset",
        "operationId": "support_bundle_list",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_SupportBundleMetadata",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SupportBundleMetadata"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support-bundles/{zpool_id}/{dataset_id}/{support_bundle_id}": {
      "post": {
        "summary": "Create a support bundle within a particular dataset",
        "operationId": "support_bundle_create",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          },
          {
            "in": "query",
            "name": "hash",
            "required": true,
            "schema": {
              "type": "string",
              "format": "hex string (32 bytes)"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "successful creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SupportBundleMetadata"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Delete a support bundle from a particular dataset",
        "operationId": "support_bundle_delete",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "successful deletion"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/support-bundles/{zpool_id}/{dataset_id}/{support_bundle_id}/download": {
      "get": {
        "summary": "Fetch a support bundle from a particular dataset",
        "operationId": "support_bundle_download",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      },
      "head": {
        "summary": "Fetch metadata about a support bundle from a particular dataset",
        "operationId": "support_bundle_head",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/support-bundles/{zpool_id}/{dataset_id}/{support_bundle_id}/download/{file}": {
      "get": {
        "summary": "Fetch a file within a support bundle from a particular dataset",
        "operationId": "support_bundle_download_file",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "file",
            "description": "The path of the file within the support bundle to query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      },
      "head": {
        "summary": "Fetch metadata about a file within a support bundle from a particular dataset",
        "operationId": "support_bundle_head_file",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "file",
            "description": "The path of the file within the support bundle to query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/support-bundles/{zpool_id}/{dataset_id}/{support_bundle_id}/index": {
      "get": {
        "summary": "Fetch the index (list of files within a support bundle)",
        "operationId": "support_bundle_index",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      },
      "head": {
        "summary": "Fetch metadata about the list of files within a support bundle",
        "operationId": "support_bundle_head_index",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "description": "The dataset on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForDatasetKind"
            }
          },
          {
            "in": "path",
            "name": "support_bundle_id",
            "description": "The ID of the support bundle itself",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "description": "The zpool on which this support bundle was provisioned",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForZpoolKind"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/switch-ports": {
      "post": {
        "operationId": "uplink_ensure",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SwitchPorts"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/timesync": {
      "get": {
        "operationId": "timesync_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TimeSync"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/v2p": {
      "get": {
        "summary": "List v2p mappings present on sled",
        "operationId": "list_v2p",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_VirtualNetworkInterfaceHost",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/VirtualNetworkInterfaceHost"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "summary": "Create a mapping from a virtual NIC to a physical host",
        "operationId": "set_v2p",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VirtualNetworkInterfaceHost"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Delete a mapping from a virtual NIC to a physical host",
        "operationId": "del_v2p",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VirtualNetworkInterfaceHost"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vmms/{propolis_id}": {
      "put": {
        "operationId": "vmm_register",
        "parameters": [
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceEnsureBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledVmmState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "operationId": "vmm_unregister",
        "parameters": [
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmmUnregisterResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vmms/{propolis_id}/disks/{disk_id}/snapshot": {
      "post": {
        "summary": "Take a snapshot of a disk that is attached to an instance",
        "operationId": "vmm_issue_disk_snapshot_request",
        "parameters": [
          {
            "in": "path",
            "name": "disk_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VmmIssueDiskSnapshotRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmmIssueDiskSnapshotRequestResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vmms/{propolis_id}/external-ip": {
      "put": {
        "operationId": "vmm_put_external_ip",
        "parameters": [
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceExternalIpBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "operationId": "vmm_delete_external_ip",
        "parameters": [
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceExternalIpBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vmms/{propolis_id}/state": {
      "get": {
        "operationId": "vmm_get_state",
        "parameters": [
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledVmmState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "vmm_put_state",
        "parameters": [
          {
            "in": "path",
            "name": "propolis_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForPropolisKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VmmPutStateBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VmmPutStateResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vpc/{vpc_id}/firewall/rules": {
      "put": {
        "operationId": "vpc_firewall_rules_put",
        "parameters": [
          {
            "in": "path",
            "name": "vpc_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VpcFirewallRulesEnsureBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vpc-routes": {
      "get": {
        "summary": "Get the current versions of VPC routing rules.",
        "operationId": "list_vpc_routes",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ResolvedVpcRouteState",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ResolvedVpcRouteState"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "summary": "Update VPC routing rules.",
        "operationId": "set_vpc_routes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "title": "Array_of_ResolvedVpcRouteSet",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ResolvedVpcRouteSet"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones": {
      "get": {
        "summary": "List the zones that are currently managed by the sled agent.",
        "operationId": "zones_list",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_String",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundle-cleanup": {
      "post": {
        "summary": "Trigger a zone bundle cleanup.",
        "operationId": "zone_bundle_cleanup",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Map_of_CleanupCount",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/CleanupCount"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundle-cleanup/context": {
      "get": {
        "summary": "Return context used by the zone-bundle cleanup task.",
        "operationId": "zone_bundle_cleanup_context",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupContext"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "summary": "Update context used by the zone-bundle cleanup task.",
        "operationId": "zone_bundle_cleanup_context_update",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupContextUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundle-cleanup/utilization": {
      "get": {
        "summary": "Return utilization information about all zone bundles.",
        "operationId": "zone_bundle_utilization",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Map_of_BundleUtilization",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/BundleUtilization"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundles": {
      "get": {
        "summary": "List all zone bundles that exist, even for now-deleted zones.",
        "operationId": "zone_bundle_list_all",
        "parameters": [
          {
            "in": "query",
            "name": "filter",
            "description": "An optional substring used to filter zone bundles.",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ZoneBundleMetadata",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ZoneBundleMetadata"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundles/{zone_name}": {
      "get": {
        "summary": "List the zone bundles that are available for a running zone.",
        "operationId": "zone_bundle_list",
        "parameters": [
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ZoneBundleMetadata",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ZoneBundleMetadata"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundles/{zone_name}/{bundle_id}": {
      "get": {
        "summary": "Fetch the binary content of a single zone bundle.",
        "operationId": "zone_bundle_get",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "The ID for this bundle itself.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone this bundle is derived from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Delete a zone bundle.",
        "operationId": "zone_bundle_delete",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "The ID for this bundle itself.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone this bundle is derived from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "successful deletion"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AddSledRequest": {
        "description": "A request to Add a given sled after rack initialization has occurred",
        "type": "object",
        "properties": {
          "sled_id": {
            "$ref": "#/components/schemas/BaseboardId"
          },
          "start_request": {
            "$ref": "#/components/schemas/StartSledAgentRequest"
          }
        },
        "required": [
          "sled_id",
          "start_request"
        ]
      },
      "ArtifactConfig": {
        "type": "object",
        "properties": {
          "artifacts": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "hex string (32 bytes)"
            },
            "uniqueItems": true
          },
          "generation": {
            "$ref": "#/components/schemas/Generation"
          }
        },
        "required": [
          "artifacts",
          "generation"
        ]
      },
      "ArtifactCopyFromDepotBody": {
        "type": "object",
        "properties": {
          "depot_base_url": {
            "type": "string"
          }
        },
        "required": [
          "depot_base_url"
        ]
      },
      "ArtifactCopyFromDepotResponse": {
        "type": "object"
      },
      "ArtifactListResponse": {
        "type": "object",
        "properties": {
          "generation": {
            "$ref": "#/components/schemas/Generation"
          },
          "list": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "uint",
              "minimum": 0
            }
          }
        },
        "required": [
          "generation",
          "list"
        ]
      },
      "ArtifactPutResponse": {
        "type": "object",
        "properties": {
          "datasets": {
            "description": "The number of valid M.2 artifact datasets we found on the sled. There is typically one of these datasets for each functional M.2.",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "successful_writes": {
            "description": "The number of valid writes to the M.2 artifact datasets. This should be less than or equal to the number of artifact datasets.",
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "datasets",
          "successful_writes"
        ]
      },
      "Baseboard": {
        "description": "Describes properties that should uniquely identify a Gimlet.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string"
              },
              "model": {
                "type": "string"
              },
              "revision": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "gimlet"
                ]
              }
            },
            "required": [
              "identifier",
              "model",
              "revision",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unknown"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string"
              },
              "model": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "pc"
                ]
              }
            },
            "required": [
              "identifier",
              "model",
              "type"
            ]
          }
        ]
      },
      "BaseboardId": {
        "description": "A representation of a Baseboard ID as used in the inventory subsystem This type is essentially the same as a `Baseboard` except it doesn't have a revision or HW type (Gimlet, PC, Unknown).",
        "type": "object",
        "properties": {
          "part_number": {
            "description": "Oxide Part Number",
            "type": "string"
          },
          "serial_number": {
            "description": "Serial number (unique for a given part number)",
            "type": "string"
          }
        },
        "required": [
          "part_number",
          "serial_number"
        ]
      },
      "BfdMode": {
        "description": "BFD connection mode.",
        "type": "string",
        "enum": [
          "single_hop",
          "multi_hop"
        ]
      },
      "BfdPeerConfig": {
        "type": "object",
        "properties": {
          "detection_threshold": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "local": {
            "nullable": true,
            "type": "string",
            "format": "ip"
          },
          "mode": {
            "$ref": "#/components/schemas/BfdMode"
          },
          "remote": {
            "type": "string",
            "format": "ip"
          },
          "required_rx": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "switch": {
            "$ref": "#/components/schemas/SwitchLocation"
          }
        },
        "required": [
          "detection_threshold",
          "mode",
          "remote",
          "required_rx",
          "switch"
        ]
      },
      "BgpConfig": {
        "type": "object",
        "properties": {
          "asn": {
            "description": "The autonomous system number for the BGP configuration.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "checker": {
            "nullable": true,
            "description": "Checker to apply to incoming messages.",
            "default": null,
            "type": "string"
          },
          "originate": {
            "description": "The set of prefixes for the BGP router to originate.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Ipv4Net"
            }
          },
          "shaper": {
            "nullable": true,
            "description": "Shaper to apply to outgoing messages.",
            "default": null,
            "type": "string"
          }
        },
        "required": [
          "asn",
          "originate"
        ]
      },
      "BgpPeerConfig": {
        "type": "object",
        "properties": {
          "addr": {
            "description": "Address of the peer.",
            "type": "string",
            "format": "ipv4"
          },
          "allowed_export": {
            "description": "Define export policy for a peer.",
            "default": {
              "type": "no_filtering"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportExportPolicy"
              }
            ]
          },
          "allowed_import": {
            "description": "Define import policy for a peer.",
            "default": {
              "type": "no_filtering"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportExportPolicy"
              }
            ]
          },
          "asn": {
            "description": "The autonomous system number of the router the peer belongs to.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "communities": {
            "description": "Include the provided communities in updates sent to the peer.",
            "default": [],
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          },
          "connect_retry": {
            "nullable": true,
            "description": "The interval in seconds between peer connection retry attempts.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "delay_open": {
            "nullable": true,
            "description": "How long to delay sending open messages to a peer. In seconds.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "enforce_first_as": {
            "description": "Enforce that the first AS in paths received from this peer is the peer's AS.",
            "default": false,
            "type": "boolean"
          },
          "hold_time": {
            "nullable": true,
            "description": "How long to keep a session alive without a keepalive in seconds. Defaults to 6.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "idle_hold_time": {
            "nullable": true,
            "description": "How long to keep a peer in idle after a state machine reset in seconds.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "keepalive": {
            "nullable": true,
            "description": "The interval to send keepalive messages at.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "local_pref": {
            "nullable": true,
            "description": "Apply a local preference to routes received from this peer.",
            "default": null,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "md5_auth_key": {
            "nullable": true,
            "description": "Use the given key for TCP-MD5 authentication with the peer.",
            "default": null,
            "type": "string"
          },
          "min_ttl": {
            "nullable": true,
            "description": "Require messages from a peer have a minimum IP time to live field.",
            "default": null,
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "multi_exit_discriminator": {
            "nullable": true,
            "description": "Apply the provided multi-exit discriminator (MED) updates sent to the peer.",
            "default": null,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "port": {
            "description": "Switch port the peer is reachable on.",
            "type": "string"
          },
          "remote_asn": {
            "nullable": true,
            "description": "Require that a peer has a specified ASN.",
            "default": null,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "vlan_id": {
            "nullable": true,
            "description": "Associate a VLAN ID with a BGP peer session.",
            "default": null,
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "addr",
          "asn",
          "port"
        ]
      },
      "BlobStorageBackend": {
        "description": "A storage backend for a disk whose initial contents are given explicitly by the specification.",
        "type": "object",
        "properties": {
          "base64": {
            "description": "The disk's initial contents, encoded as a base64 string.",
            "type": "string"
          },
          "readonly": {
            "description": "Indicates whether the storage is read-only.",
            "type": "boolean"
          }
        },
        "required": [
          "base64",
          "readonly"
        ],
        "additionalProperties": false
      },
      "Board": {
        "description": "A VM's mainboard.",
        "type": "object",
        "properties": {
          "chipset": {
            "description": "The chipset to expose to guest software.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Chipset"
              }
            ]
          },
          "cpuid": {
            "nullable": true,
            "description": "The CPUID values to expose to the guest. If `None`, bhyve will derive default values from the host's CPUID values.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Cpuid"
              }
            ]
          },
          "cpus": {
            "description": "The number of virtual logical processors attached to this VM.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "guest_hv_interface": {
            "description": "The hypervisor platform to expose to the guest. The default is a bhyve-compatible interface with no additional features.\n\nFor compatibility with older versions of Propolis, this field is only serialized if it specifies a non-default interface.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GuestHypervisorInterface"
              }
            ]
          },
          "memory_mb": {
            "description": "The amount of guest RAM attached to this VM.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "chipset",
          "cpus",
          "memory_mb"
        ],
        "additionalProperties": false
      },
      "BootDiskOsWriteProgress": {
        "description": "Current progress of an OS image being written to disk.",
        "oneOf": [
          {
            "description": "The image is still being uploaded.",
            "type": "object",
            "properties": {
              "bytes_received": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "state": {
                "type": "string",
                "enum": [
                  "receiving_uploaded_image"
                ]
              }
            },
            "required": [
              "bytes_received",
              "state"
            ]
          },
          {
            "description": "The image is being written to disk.",
            "type": "object",
            "properties": {
              "bytes_written": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "state": {
                "type": "string",
                "enum": [
                  "writing_image_to_disk"
                ]
              }
            },
            "required": [
              "bytes_written",
              "state"
            ]
          },
          {
            "description": "The image is being read back from disk for validation.",
            "type": "object",
            "properties": {
              "bytes_read": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "state": {
                "type": "string",
                "enum": [
                  "validating_written_image"
                ]
              }
            },
            "required": [
              "bytes_read",
              "state"
            ]
          }
        ]
      },
      "BootDiskOsWriteStatus": {
        "description": "Status of an update to a boot disk OS.",
        "oneOf": [
          {
            "description": "No update has been started for this disk, or any previously-started update has completed and had its status cleared.",
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "no_update_started"
                ]
              }
            },
            "required": [
              "status"
            ]
          },
          {
            "description": "An update is currently running.",
            "type": "object",
            "properties": {
              "progress": {
                "$ref": "#/components/schemas/BootDiskOsWriteProgress"
              },
              "status": {
                "type": "string",
                "enum": [
                  "in_progress"
                ]
              },
              "update_id": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "progress",
              "status",
              "update_id"
            ]
          },
          {
            "description": "The most recent update completed successfully.",
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "complete"
                ]
              },
              "update_id": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "status",
              "update_id"
            ]
          },
          {
            "description": "The most recent update failed.",
            "type": "object",
            "properties": {
              "message": {
                "type": "string"
              },
              "status": {
                "type": "string",
                "enum": [
                  "failed"
                ]
              },
              "update_id": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "message",
              "status",
              "update_id"
            ]
          }
        ]
      },
      "BootOrderEntry": {
        "description": "An entry in the boot order stored in a [`BootSettings`] component.",
        "type": "object",
        "properties": {
          "id": {
            "description": "The ID of another component in the spec that Propolis should try to boot from.\n\nCurrently, only disk device components are supported.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpecKey"
              }
            ]
          }
        },
        "required": [
          "id"
        ]
      },
      "BootSettings": {
        "description": "Settings supplied to the guest's firmware image that specify the order in which it should consider its options when selecting a device to try to boot from.",
        "type": "object",
        "properties": {
          "order": {
            "description": "An ordered list of components to attempt to boot from.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BootOrderEntry"
            }
          }
        },
        "required": [
          "order"
        ],
        "additionalProperties": false
      },
      "BootstoreStatus": {
        "type": "object",
        "properties": {
          "accepted_connections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "established_connections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EstablishedConnection"
            }
          },
          "fsm_ledger_generation": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "fsm_state": {
            "type": "string"
          },
          "negotiating_connections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "network_config_ledger_generation": {
            "nullable": true,
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "peers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "accepted_connections",
          "established_connections",
          "fsm_ledger_generation",
          "fsm_state",
          "negotiating_connections",
          "peers"
        ]
      },
      "BundleUtilization": {
        "description": "The portion of a debug dataset used for zone bundles.",
        "type": "object",
        "properties": {
          "bytes_available": {
            "description": "The total number of bytes available for zone bundles.\n\nThis is `dataset_quota` multiplied by the context's storage limit.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "bytes_used": {
            "description": "Total bundle usage, in bytes.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "dataset_quota": {
            "description": "The total dataset quota, in bytes.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "bytes_available",
          "bytes_used",
          "dataset_quota"
        ]
      },
      "ByteCount": {
        "description": "Byte count to express memory or storage capacity.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "Chipset": {
        "description": "A kind of virtual chipset.",
        "oneOf": [
          {
            "description": "An Intel 440FX-compatible chipset.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "i440_fx"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/I440Fx"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "additionalProperties": false
          }
        ]
      },
      "CleanupContext": {
        "description": "Context provided for the zone bundle cleanup task.",
        "type": "object",
        "properties": {
          "period": {
            "description": "The period on which automatic checks and cleanup is performed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CleanupPeriod"
              }
            ]
          },
          "priority": {
            "description": "The priority ordering for keeping old bundles.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PriorityOrder"
              }
            ]
          },
          "storage_limit": {
            "description": "The limit on the dataset quota available for zone bundles.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StorageLimit"
              }
            ]
          }
        },
        "required": [
          "period",
          "priority",
          "storage_limit"
        ]
      },
      "CleanupContextUpdate": {
        "description": "Parameters used to update the zone bundle cleanup context.",
        "type": "object",
        "properties": {
          "period": {
            "nullable": true,
            "description": "The new period on which automatic cleanups are run.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ]
          },
          "priority": {
            "nullable": true,
            "description": "The priority ordering for preserving old zone bundles.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PriorityOrder"
              }
            ]
          },
          "storage_limit": {
            "nullable": true,
            "description": "The new limit on the underlying dataset quota allowed for bundles.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          }
        }
      },
      "CleanupCount": {
        "description": "The count of bundles / bytes removed during a cleanup operation.",
        "type": "object",
        "properties": {
          "bundles": {
            "description": "The number of bundles removed.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "bytes": {
            "description": "The number of bytes removed.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "bundles",
          "bytes"
        ]
      },
      "CleanupPeriod": {
        "description": "A period on which bundles are automatically cleaned up.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Duration"
          }
        ]
      },
      "ComponentV0": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/VirtioDisk"
              },
              "type": {
                "type": "string",
                "enum": [
                  "virtio_disk"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/NvmeDisk"
              },
              "type": {
                "type": "string",
                "enum": [
                  "nvme_disk"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/VirtioNic"
              },
              "type": {
                "type": "string",
                "enum": [
                  "virtio_nic"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/SerialPort"
              },
              "type": {
                "type": "string",
                "enum": [
                  "serial_port"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/PciPciBridge"
              },
              "type": {
                "type": "string",
                "enum": [
                  "pci_pci_bridge"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/QemuPvpanic"
              },
              "type": {
                "type": "string",
                "enum": [
                  "qemu_pvpanic"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/BootSettings"
              },
              "type": {
                "type": "string",
                "enum": [
                  "boot_settings"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/SoftNpuPciPort"
              },
              "type": {
                "type": "string",
                "enum": [
                  "soft_npu_pci_port"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/SoftNpuPort"
              },
              "type": {
                "type": "string",
                "enum": [
                  "soft_npu_port"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/SoftNpuP9"
              },
              "type": {
                "type": "string",
                "enum": [
                  "soft_npu_p9"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/P9fs"
              },
              "type": {
                "type": "string",
                "enum": [
                  "p9fs"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/MigrationFailureInjector"
              },
              "type": {
                "type": "string",
                "enum": [
                  "migration_failure_injector"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/CrucibleStorageBackend"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible_storage_backend"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/FileStorageBackend"
              },
              "type": {
                "type": "string",
                "enum": [
                  "file_storage_backend"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/BlobStorageBackend"
              },
              "type": {
                "type": "string",
                "enum": [
                  "blob_storage_backend"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/VirtioNetworkBackend"
              },
              "type": {
                "type": "string",
                "enum": [
                  "virtio_network_backend"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "component": {
                "$ref": "#/components/schemas/DlpiNetworkBackend"
              },
              "type": {
                "type": "string",
                "enum": [
                  "dlpi_network_backend"
                ]
              }
            },
            "required": [
              "component",
              "type"
            ],
            "additionalProperties": false
          }
        ]
      },
      "CompressionAlgorithm": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "on"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "off"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "gzip"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "level": {
                "$ref": "#/components/schemas/GzipLevel"
              },
              "type": {
                "type": "string",
                "enum": [
                  "gzip_n"
                ]
              }
            },
            "required": [
              "level",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lz4"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lzjb"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "zle"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "ConfigReconcilerInventory": {
        "description": "Describes the last attempt made by the sled-agent-config-reconciler to reconcile the current sled config against the actual state of the sled.",
        "type": "object",
        "properties": {
          "datasets": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ConfigReconcilerInventoryResult"
            }
          },
          "external_disks": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ConfigReconcilerInventoryResult"
            }
          },
          "last_reconciled_config": {
            "$ref": "#/components/schemas/OmicronSledConfig"
          },
          "zones": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ConfigReconcilerInventoryResult"
            }
          }
        },
        "required": [
          "datasets",
          "external_disks",
          "last_reconciled_config",
          "zones"
        ]
      },
      "ConfigReconcilerInventoryResult": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "result": {
                "type": "string",
                "enum": [
                  "ok"
                ]
              }
            },
            "required": [
              "result"
            ]
          },
          {
            "type": "object",
            "properties": {
              "message": {
                "type": "string"
              },
              "result": {
                "type": "string",
                "enum": [
                  "err"
                ]
              }
            },
            "required": [
              "message",
              "result"
            ]
          }
        ]
      },
      "ConfigReconcilerInventoryStatus": {
        "description": "Status of the sled-agent-config-reconciler task.",
        "oneOf": [
          {
            "description": "The reconciler task has not yet run for the first time since sled-agent started.",
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "not_yet_run"
                ]
              }
            },
            "required": [
              "status"
            ]
          },
          {
            "description": "The reconciler task is actively running.",
            "type": "object",
            "properties": {
              "config": {
                "$ref": "#/components/schemas/OmicronSledConfig"
              },
              "running_for": {
                "$ref": "#/components/schemas/Duration"
              },
              "started_at": {
                "type": "string",
                "format": "date-time"
              },
              "status": {
                "type": "string",
                "enum": [
                  "running"
                ]
              }
            },
            "required": [
              "config",
              "running_for",
              "started_at",
              "status"
            ]
          },
          {
            "description": "The reconciler task is currently idle, but previously did complete a reconciliation attempt.\n\nThis variant does not include the `OmicronSledConfig` used in the last attempt, because that's always available via [`ConfigReconcilerInventory::last_reconciled_config`].",
            "type": "object",
            "properties": {
              "completed_at": {
                "type": "string",
                "format": "date-time"
              },
              "ran_for": {
                "$ref": "#/components/schemas/Duration"
              },
              "status": {
                "type": "string",
                "enum": [
                  "idle"
                ]
              }
            },
            "required": [
              "completed_at",
              "ran_for",
              "status"
            ]
          }
        ]
      },
      "Cpuid": {
        "description": "A set of CPUID values to expose to a guest.",
        "type": "object",
        "properties": {
          "entries": {
            "description": "A list of CPUID leaves/subleaves and their associated values.\n\nPropolis servers require that each entry's `leaf` be unique and that it falls in either the \"standard\" (0 to 0xFFFF) or \"extended\" (0x8000_0000 to 0x8000_FFFF) function ranges, since these are the only valid input ranges currently defined by Intel and AMD. See the Intel 64 and IA-32 Architectures Software Developer's Manual (June 2024) Table 3-17 and the AMD64 Architecture Programmer's Manual (March 2024) Volume 3's documentation of the CPUID instruction.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CpuidEntry"
            }
          },
          "vendor": {
            "description": "The CPU vendor to emulate.\n\nCPUID leaves in the extended range (0x8000_0000 to 0x8000_FFFF) have vendor-defined semantics. Propolis uses this value to determine these semantics when deciding whether it needs to specialize the supplied template values for these leaves.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CpuidVendor"
              }
            ]
          }
        },
        "required": [
          "entries",
          "vendor"
        ],
        "additionalProperties": false
      },
      "CpuidEntry": {
        "description": "A full description of a CPUID leaf/subleaf and the values it produces.",
        "type": "object",
        "properties": {
          "eax": {
            "description": "The value to return in eax.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "ebx": {
            "description": "The value to return in ebx.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "ecx": {
            "description": "The value to return in ecx.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "edx": {
            "description": "The value to return in edx.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "leaf": {
            "description": "The leaf (function) number for this entry.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "subleaf": {
            "nullable": true,
            "description": "The subleaf (index) number for this entry, if it uses subleaves.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "eax",
          "ebx",
          "ecx",
          "edx",
          "leaf"
        ],
        "additionalProperties": false
      },
      "CpuidVendor": {
        "description": "A CPU vendor to use when interpreting the meanings of CPUID leaves in the extended ID range (0x80000000 to 0x8000FFFF).",
        "type": "string",
        "enum": [
          "amd",
          "intel"
        ]
      },
      "CrucibleStorageBackend": {
        "description": "A Crucible storage backend.",
        "type": "object",
        "properties": {
          "readonly": {
            "description": "Indicates whether the storage is read-only.",
            "type": "boolean"
          },
          "request_json": {
            "description": "A serialized `[crucible_client_types::VolumeConstructionRequest]`. This is stored in serialized form so that breaking changes to the definition of a `VolumeConstructionRequest` do not inadvertently break instance spec deserialization.\n\nWhen using a spec to initialize a new instance, the spec author must ensure this request is well-formed and can be deserialized by the version of `crucible_client_types` used by the target Propolis.",
            "type": "string"
          }
        },
        "required": [
          "readonly",
          "request_json"
        ],
        "additionalProperties": false
      },
      "DatasetConfig": {
        "description": "Configuration information necessary to request a single dataset.\n\nThese datasets are tracked directly by Nexus.",
        "type": "object",
        "properties": {
          "compression": {
            "description": "The compression mode to be used by the dataset",
            "allOf": [
              {
                "$ref": "#/components/schemas/CompressionAlgorithm"
              }
            ]
          },
          "id": {
            "description": "The UUID of the dataset being requested",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForDatasetKind"
              }
            ]
          },
          "name": {
            "description": "The dataset's name",
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetName"
              }
            ]
          },
          "quota": {
            "nullable": true,
            "description": "The upper bound on the amount of storage used by this dataset",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "reservation": {
            "nullable": true,
            "description": "The lower bound on the amount of storage usable by this dataset",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          }
        },
        "required": [
          "compression",
          "id",
          "name"
        ]
      },
      "DatasetKind": {
        "description": "The kind of dataset. See the `DatasetKind` enum in omicron-common for possible values.",
        "type": "string"
      },
      "DatasetName": {
        "type": "object",
        "properties": {
          "kind": {
            "$ref": "#/components/schemas/DatasetKind"
          },
          "pool_name": {
            "$ref": "#/components/schemas/ZpoolName"
          }
        },
        "required": [
          "kind",
          "pool_name"
        ]
      },
      "DhcpConfig": {
        "description": "DHCP configuration for a port\n\nNot present here: Hostname (DHCPv4 option 12; used in DHCPv6 option 39); we use `InstanceRuntimeState::hostname` for this value.",
        "type": "object",
        "properties": {
          "dns_servers": {
            "description": "DNS servers to send to the instance\n\n(DHCPv4 option 6; DHCPv6 option 23)",
            "type": "array",
            "items": {
              "type": "string",
              "format": "ip"
            }
          },
          "host_domain": {
            "nullable": true,
            "description": "DNS zone this instance's hostname belongs to (e.g. the `project.example` part of `instance1.project.example`)\n\n(DHCPv4 option 15; used in DHCPv6 option 39)",
            "type": "string"
          },
          "search_domains": {
            "description": "DNS search domains\n\n(DHCPv4 option 119; DHCPv6 option 24)",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "dns_servers",
          "search_domains"
        ]
      },
      "DiskEnsureBody": {
        "description": "Sent from to a sled agent to establish the runtime state of a Disk",
        "type": "object",
        "properties": {
          "initial_runtime": {
            "description": "Last runtime state of the Disk known to Nexus (used if the agent has never seen this Disk before).",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskRuntimeState"
              }
            ]
          },
          "target": {
            "description": "requested runtime state of the Disk",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskStateRequested"
              }
            ]
          }
        },
        "required": [
          "initial_runtime",
          "target"
        ]
      },
      "DiskIdentity": {
        "description": "Uniquely identifies a disk.",
        "type": "object",
        "properties": {
          "model": {
            "type": "string"
          },
          "serial": {
            "type": "string"
          },
          "vendor": {
            "type": "string"
          }
        },
        "required": [
          "model",
          "serial",
          "vendor"
        ]
      },
      "DiskRuntimeState": {
        "description": "Runtime state of the Disk, which includes its attach state and some minimal metadata",
        "type": "object",
        "properties": {
          "disk_state": {
            "description": "runtime state of the Disk",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskState"
              }
            ]
          },
          "gen": {
            "description": "generation number for this state",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "time_updated": {
            "description": "timestamp for this information",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "disk_state",
          "gen",
          "time_updated"
        ]
      },
      "DiskState": {
        "description": "State of a Disk",
        "oneOf": [
          {
            "description": "Disk is being initialized",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "creating"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is ready but detached from any Instance",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "detached"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is ready to receive blocks from an external source",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "import_ready"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is importing blocks from a URL",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "importing_from_url"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is importing blocks from bulk writes",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "importing_from_bulk_writes"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is being finalized to state Detached",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "finalizing"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is undergoing maintenance",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "maintenance"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is being attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attached"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is being detached from the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "detaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk has been destroyed",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "destroyed"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is unavailable",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "faulted"
                ]
              }
            },
            "required": [
              "state"
            ]
          }
        ]
      },
      "DiskStateRequested": {
        "description": "Used to request a Disk state change",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "detached"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attached"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "destroyed"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "faulted"
                ]
              }
            },
            "required": [
              "state"
            ]
          }
        ]
      },
      "DiskVariant": {
        "type": "string",
        "enum": [
          "U2",
          "M2"
        ]
      },
      "DlpiNetworkBackend": {
        "description": "A network backend associated with a DLPI VNIC on the host.",
        "type": "object",
        "properties": {
          "vnic_name": {
            "description": "The name of the VNIC to use as a backend.",
            "type": "string"
          }
        },
        "required": [
          "vnic_name"
        ],
        "additionalProperties": false
      },
      "Duration": {
        "type": "object",
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "nanos",
          "secs"
        ]
      },
      "EarlyNetworkConfig": {
        "description": "Network configuration required to bring up the control plane\n\nThe fields in this structure are those from [`crate::rack_init::RackInitializeRequest`] necessary for use beyond RSS. This is just for the initial rack configuration and cold boot purposes. Updates come from Nexus.",
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/EarlyNetworkConfigBody"
          },
          "generation": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "schema_version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "body",
          "generation",
          "schema_version"
        ]
      },
      "EarlyNetworkConfigBody": {
        "description": "This is the actual configuration of EarlyNetworking.\n\nWe nest it below the \"header\" of `generation` and `schema_version` so that we can perform partial deserialization of `EarlyNetworkConfig` to only read the header and defer deserialization of the body once we know the schema version. This is possible via the use of [`serde_json::value::RawValue`] in future (post-v1) deserialization paths.",
        "type": "object",
        "properties": {
          "ntp_servers": {
            "description": "The external NTP server addresses.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "rack_network_config": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/RackNetworkConfigV2"
              }
            ]
          }
        },
        "required": [
          "ntp_servers"
        ]
      },
      "Error": {
        "description": "Error information from a response.",
        "type": "object",
        "properties": {
          "error_code": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "request_id"
        ]
      },
      "EstablishedConnection": {
        "type": "object",
        "properties": {
          "addr": {
            "type": "string"
          },
          "baseboard": {
            "$ref": "#/components/schemas/Baseboard"
          }
        },
        "required": [
          "addr",
          "baseboard"
        ]
      },
      "ExternalIpGatewayMap": {
        "description": "Per-NIC mappings from external IP addresses to the Internet Gateways which can choose them as a source.",
        "type": "object",
        "properties": {
          "mappings": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "uniqueItems": true
              }
            }
          }
        },
        "required": [
          "mappings"
        ]
      },
      "FileStorageBackend": {
        "description": "A storage backend backed by a file in the host system's file system.",
        "type": "object",
        "properties": {
          "path": {
            "description": "A path to a file that backs a disk.",
            "type": "string"
          },
          "readonly": {
            "description": "Indicates whether the storage is read-only.",
            "type": "boolean"
          }
        },
        "required": [
          "path",
          "readonly"
        ],
        "additionalProperties": false
      },
      "Generation": {
        "description": "Generation numbers stored in the database, used for optimistic concurrency control",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "GuestHypervisorInterface": {
        "description": "A hypervisor interface to expose to the guest.",
        "oneOf": [
          {
            "description": "Expose a bhyve-like interface (\"bhyve bhyve \" as the hypervisor ID in leaf 0x4000_0000 and no additional leaves or features).",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "bhyve"
                ]
              }
            },
            "required": [
              "type"
            ],
            "additionalProperties": false
          },
          {
            "description": "Expose a Hyper-V-compatible hypervisor interface with the supplied features enabled.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "hyper_v"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "features": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/HyperVFeatureFlag"
                    },
                    "uniqueItems": true
                  }
                },
                "required": [
                  "features"
                ],
                "additionalProperties": false
              }
            },
            "required": [
              "type",
              "value"
            ],
            "additionalProperties": false
          }
        ]
      },
      "GzipLevel": {
        "type": "integer",
        "format": "uint8",
        "minimum": 0
      },
      "HostIdentifier": {
        "description": "A `HostIdentifier` represents either an IP host or network (v4 or v6), or an entire VPC (identified by its VNI). It is used in firewall rule host filters.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ip"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/IpNet"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "vpc"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/Vni"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "HostPortConfig": {
        "type": "object",
        "properties": {
          "addrs": {
            "description": "IP Address and prefix (e.g., `192.168.0.1/16`) to apply to switchport (must be in infra_ip pool).  May also include an optional VLAN ID.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UplinkAddressConfig"
            }
          },
          "lldp": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/LldpPortConfig"
              }
            ]
          },
          "port": {
            "description": "Switchport to use for external connectivity",
            "type": "string"
          },
          "tx_eq": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/TxEqConfig"
              }
            ]
          }
        },
        "required": [
          "addrs",
          "port"
        ]
      },
      "Hostname": {
        "title": "An RFC-1035-compliant hostname",
        "description": "A hostname identifies a host on a network, and is usually a dot-delimited sequence of labels, where each label contains only letters, digits, or the hyphen. See RFCs 1035 and 952 for more details.",
        "type": "string",
        "pattern": "^([a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))(\\.[a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))*$",
        "minLength": 1,
        "maxLength": 253
      },
      "HyperVFeatureFlag": {
        "description": "Flags that enable \"simple\" Hyper-V enlightenments that require no feature-specific configuration.",
        "type": "string",
        "enum": [
          "reference_tsc"
        ]
      },
      "I440Fx": {
        "description": "An Intel 440FX-compatible chipset.",
        "type": "object",
        "properties": {
          "enable_pcie": {
            "description": "Specifies whether the chipset should allow PCI configuration space to be accessed through the PCIe extended configuration mechanism.",
            "type": "boolean"
          }
        },
        "required": [
          "enable_pcie"
        ],
        "additionalProperties": false
      },
      "IdMapDatasetConfig": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/DatasetConfig"
        }
      },
      "IdMapOmicronPhysicalDiskConfig": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/OmicronPhysicalDiskConfig"
        }
      },
      "IdMapOmicronZoneConfig": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/OmicronZoneConfig"
        }
      },
      "ImportExportPolicy": {
        "description": "Define policy relating to the import and export of prefixes from a BGP peer.",
        "oneOf": [
          {
            "description": "Do not perform any filtering.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_filtering"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "allow"
                ]
              },
              "value": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IpNet"
                }
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "InstanceEnsureBody": {
        "description": "The body of a request to ensure that a instance and VMM are known to a sled agent.",
        "type": "object",
        "properties": {
          "instance_id": {
            "description": "The ID of the instance for which this VMM is being created.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForInstanceKind"
              }
            ]
          },
          "local_config": {
            "description": "Information about the sled-local configuration that needs to be established to make the VM's virtual hardware fully functional.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceSledLocalConfig"
              }
            ]
          },
          "metadata": {
            "description": "Metadata used to track instance statistics.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceMetadata"
              }
            ]
          },
          "migration_id": {
            "nullable": true,
            "description": "The ID of the migration in to this VMM, if this VMM is being ensured is part of a migration in. If this is `None`, the VMM is not being created due to a migration.",
            "type": "string",
            "format": "uuid"
          },
          "propolis_addr": {
            "description": "The address at which this VMM should serve a Propolis server API.",
            "type": "string"
          },
          "vmm_runtime": {
            "description": "The initial VMM runtime state for the VMM being registered.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmRuntimeState"
              }
            ]
          },
          "vmm_spec": {
            "description": "The virtual hardware configuration this virtual machine should have when it is started.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmSpec"
              }
            ]
          }
        },
        "required": [
          "instance_id",
          "local_config",
          "metadata",
          "propolis_addr",
          "vmm_runtime",
          "vmm_spec"
        ]
      },
      "InstanceExternalIpBody": {
        "description": "Used to dynamically update external IPs attached to an instance.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ephemeral"
                ]
              },
              "value": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "floating"
                ]
              },
              "value": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "InstanceMetadata": {
        "description": "Metadata used to track statistics about an instance.",
        "type": "object",
        "properties": {
          "project_id": {
            "type": "string",
            "format": "uuid"
          },
          "silo_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "project_id",
          "silo_id"
        ]
      },
      "InstanceMigrationTargetParams": {
        "description": "Parameters used when directing Propolis to initialize itself via live migration.",
        "type": "object",
        "properties": {
          "src_propolis_addr": {
            "description": "The address of the Propolis server that will serve as the migration source.",
            "type": "string"
          }
        },
        "required": [
          "src_propolis_addr"
        ]
      },
      "InstanceSledLocalConfig": {
        "description": "Describes sled-local configuration that a sled-agent must establish to make the instance's virtual hardware fully functional.",
        "type": "object",
        "properties": {
          "dhcp_config": {
            "$ref": "#/components/schemas/DhcpConfig"
          },
          "ephemeral_ip": {
            "nullable": true,
            "description": "Zero or more external IP addresses (either floating or ephemeral), provided to an instance to allow inbound connectivity.",
            "type": "string",
            "format": "ip"
          },
          "firewall_rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedVpcFirewallRule"
            }
          },
          "floating_ips": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "ip"
            }
          },
          "hostname": {
            "$ref": "#/components/schemas/Hostname"
          },
          "nics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkInterface"
            }
          },
          "source_nat": {
            "$ref": "#/components/schemas/SourceNatConfig"
          }
        },
        "required": [
          "dhcp_config",
          "firewall_rules",
          "floating_ips",
          "hostname",
          "nics",
          "source_nat"
        ]
      },
      "InstanceSpecV0": {
        "type": "object",
        "properties": {
          "board": {
            "$ref": "#/components/schemas/Board"
          },
          "components": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ComponentV0"
            }
          }
        },
        "required": [
          "board",
          "components"
        ],
        "additionalProperties": false
      },
      "InternetGatewayRouterTarget": {
        "description": "An Internet Gateway router target.",
        "oneOf": [
          {
            "description": "Targets the gateway for the system-internal services VPC.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "system"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Targets a gateway for an instance's VPC.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "instance"
                ]
              },
              "value": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "Inventory": {
        "description": "Identity and basic status information about this sled agent",
        "type": "object",
        "properties": {
          "baseboard": {
            "$ref": "#/components/schemas/Baseboard"
          },
          "datasets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InventoryDataset"
            }
          },
          "disks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InventoryDisk"
            }
          },
          "last_reconciliation": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ConfigReconcilerInventory"
              }
            ]
          },
          "ledgered_sled_config": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/OmicronSledConfig"
              }
            ]
          },
          "reconciler_status": {
            "$ref": "#/components/schemas/ConfigReconcilerInventoryStatus"
          },
          "reservoir_size": {
            "$ref": "#/components/schemas/ByteCount"
          },
          "sled_agent_address": {
            "type": "string"
          },
          "sled_id": {
            "$ref": "#/components/schemas/TypedUuidForSledKind"
          },
          "sled_role": {
            "$ref": "#/components/schemas/SledRole"
          },
          "usable_hardware_threads": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "usable_physical_ram": {
            "$ref": "#/components/schemas/ByteCount"
          },
          "zpools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InventoryZpool"
            }
          }
        },
        "required": [
          "baseboard",
          "datasets",
          "disks",
          "reconciler_status",
          "reservoir_size",
          "sled_agent_address",
          "sled_id",
          "sled_role",
          "usable_hardware_threads",
          "usable_physical_ram",
          "zpools"
        ]
      },
      "InventoryDataset": {
        "description": "Identifies information about datasets within Oxide-managed zpools",
        "type": "object",
        "properties": {
          "available": {
            "description": "The amount of remaining space usable by the dataset (and children) assuming there is no other activity within the pool.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "compression": {
            "description": "The compression algorithm used for this dataset, if any.",
            "type": "string"
          },
          "id": {
            "nullable": true,
            "description": "Although datasets mandated by the control plane will have UUIDs, datasets can be created (and have been created) without UUIDs.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForDatasetKind"
              }
            ]
          },
          "name": {
            "description": "This name is the full path of the dataset.",
            "type": "string"
          },
          "quota": {
            "nullable": true,
            "description": "The maximum amount of space usable by a dataset and all descendents.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "reservation": {
            "nullable": true,
            "description": "The minimum amount of space guaranteed to a dataset and descendents.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "used": {
            "description": "The amount of space consumed by this dataset and descendents.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          }
        },
        "required": [
          "available",
          "compression",
          "name",
          "used"
        ]
      },
      "InventoryDisk": {
        "description": "Identifies information about disks which may be attached to Sleds.",
        "type": "object",
        "properties": {
          "active_firmware_slot": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "identity": {
            "$ref": "#/components/schemas/DiskIdentity"
          },
          "next_active_firmware_slot": {
            "nullable": true,
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "number_of_firmware_slots": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "slot": {
            "type": "integer",
            "format": "int64"
          },
          "slot1_is_read_only": {
            "type": "boolean"
          },
          "slot_firmware_versions": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "variant": {
            "$ref": "#/components/schemas/DiskVariant"
          }
        },
        "required": [
          "active_firmware_slot",
          "identity",
          "number_of_firmware_slots",
          "slot",
          "slot1_is_read_only",
          "slot_firmware_versions",
          "variant"
        ]
      },
      "InventoryZpool": {
        "description": "Identifies information about zpools managed by the control plane",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/TypedUuidForZpoolKind"
          },
          "total_size": {
            "$ref": "#/components/schemas/ByteCount"
          }
        },
        "required": [
          "id",
          "total_size"
        ]
      },
      "IpNet": {
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::IpNet",
          "version": "0.1.0"
        },
        "oneOf": [
          {
            "title": "v4",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv4Net"
              }
            ]
          },
          {
            "title": "v6",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv6Net"
              }
            ]
          }
        ]
      },
      "Ipv4Net": {
        "example": "192.168.1.0/24",
        "title": "An IPv4 subnet",
        "description": "An IPv4 subnet, including prefix and prefix length",
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::Ipv4Net",
          "version": "0.1.0"
        },
        "type": "string",
        "pattern": "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|1[0-9]|2[0-9]|3[0-2])$"
      },
      "Ipv6Net": {
        "example": "fd12:3456::/64",
        "title": "An IPv6 subnet",
        "description": "An IPv6 subnet, including prefix and subnet mask",
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::Ipv6Net",
          "version": "0.1.0"
        },
        "type": "string",
        "pattern": "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
      },
      "Ipv6Subnet": {
        "description": "Wraps an [`Ipv6Net`] with a compile-time prefix length.",
        "type": "object",
        "properties": {
          "net": {
            "$ref": "#/components/schemas/Ipv6Net"
          }
        },
        "required": [
          "net"
        ]
      },
      "L4PortRange": {
        "example": "22",
        "title": "A range of IP ports",
        "description": "An inclusive-inclusive range of IP ports. The second port may be omitted to represent a single port.",
        "type": "string",
        "pattern": "^[0-9]{1,5}(-[0-9]{1,5})?$",
        "minLength": 1,
        "maxLength": 11
      },
      "LldpAdminStatus": {
        "description": "To what extent should this port participate in LLDP",
        "type": "string",
        "enum": [
          "enabled",
          "disabled",
          "rx_only",
          "tx_only"
        ]
      },
      "LldpPortConfig": {
        "description": "Per-port LLDP configuration settings.  Only the \"status\" setting is mandatory.  All other fields have natural defaults or may be inherited from the switch.",
        "type": "object",
        "properties": {
          "chassis_id": {
            "nullable": true,
            "description": "Chassis ID to advertise.  If this is set, it will be advertised as a LocallyAssigned ID type.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "string"
          },
          "management_addrs": {
            "nullable": true,
            "description": "Management IP addresses to advertise.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "ip"
            }
          },
          "port_description": {
            "nullable": true,
            "description": "Port description to advertise.  If this is not set, no description will be advertised.",
            "type": "string"
          },
          "port_id": {
            "nullable": true,
            "description": "Port ID to advertise.  If this is set, it will be advertised as a LocallyAssigned ID type.  If this is not set, it will be set to the port name. e.g., qsfp0/0.",
            "type": "string"
          },
          "status": {
            "description": "To what extent should this port participate in LLDP",
            "allOf": [
              {
                "$ref": "#/components/schemas/LldpAdminStatus"
              }
            ]
          },
          "system_description": {
            "nullable": true,
            "description": "System description to advertise.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "string"
          },
          "system_name": {
            "nullable": true,
            "description": "System name to advertise.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "string"
          }
        },
        "required": [
          "status"
        ]
      },
      "MacAddr": {
        "example": "ff:ff:ff:ff:ff:ff",
        "title": "A MAC address",
        "description": "A Media Access Control address, in EUI-48 format",
        "type": "string",
        "pattern": "^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$",
        "minLength": 5,
        "maxLength": 17
      },
      "MigrationFailureInjector": {
        "description": "Describes a synthetic device that registers for VM lifecycle notifications and returns errors during attempts to migrate.\n\nThis is only supported by Propolis servers compiled with the `failure-injection` feature.",
        "type": "object",
        "properties": {
          "fail_exports": {
            "description": "The number of times this device should fail requests to export state.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "fail_imports": {
            "description": "The number of times this device should fail requests to import state.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "fail_exports",
          "fail_imports"
        ],
        "additionalProperties": false
      },
      "MigrationRuntimeState": {
        "description": "An update from a sled regarding the state of a migration, indicating the role of the VMM whose migration state was updated.",
        "type": "object",
        "properties": {
          "gen": {
            "$ref": "#/components/schemas/Generation"
          },
          "migration_id": {
            "type": "string",
            "format": "uuid"
          },
          "state": {
            "$ref": "#/components/schemas/MigrationState"
          },
          "time_updated": {
            "description": "Timestamp for the migration state update.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "migration_id",
          "state",
          "time_updated"
        ]
      },
      "MigrationState": {
        "description": "The state of an instance's live migration.",
        "oneOf": [
          {
            "description": "The migration has not started for this VMM.",
            "type": "string",
            "enum": [
              "pending"
            ]
          },
          {
            "description": "The migration is in progress.",
            "type": "string",
            "enum": [
              "in_progress"
            ]
          },
          {
            "description": "The migration has failed.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "The migration has completed.",
            "type": "string",
            "enum": [
              "completed"
            ]
          }
        ]
      },
      "Name": {
        "title": "A name unique within the parent collection",
        "description": "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID, but they may contain a UUID. They can be at most 63 characters long.",
        "type": "string",
        "pattern": "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$",
        "minLength": 1,
        "maxLength": 63
      },
      "NetworkInterface": {
        "description": "Information required to construct a virtual network interface",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "ip": {
            "type": "string",
            "format": "ip"
          },
          "kind": {
            "$ref": "#/components/schemas/NetworkInterfaceKind"
          },
          "mac": {
            "$ref": "#/components/schemas/MacAddr"
          },
          "name": {
            "$ref": "#/components/schemas/Name"
          },
          "primary": {
            "type": "boolean"
          },
          "slot": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "subnet": {
            "$ref": "#/components/schemas/IpNet"
          },
          "transit_ips": {
            "default": [],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IpNet"
            }
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "id",
          "ip",
          "kind",
          "mac",
          "name",
          "primary",
          "slot",
          "subnet",
          "vni"
        ]
      },
      "NetworkInterfaceKind": {
        "description": "The type of network interface",
        "oneOf": [
          {
            "description": "A vNIC attached to a guest instance",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "instance"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          },
          {
            "description": "A vNIC associated with an internal service",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "service"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          },
          {
            "description": "A vNIC associated with a probe",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "probe"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          }
        ]
      },
      "NvmeDisk": {
        "description": "A disk that presents an NVMe interface to the guest.",
        "type": "object",
        "properties": {
          "backend_id": {
            "description": "The name of the disk's backend component.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpecKey"
              }
            ]
          },
          "pci_path": {
            "description": "The PCI bus/device/function at which this disk should be attached.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          },
          "serial_number": {
            "description": "The serial number to return in response to an NVMe Identify Controller command.",
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            },
            "minItems": 20,
            "maxItems": 20
          }
        },
        "required": [
          "backend_id",
          "pci_path",
          "serial_number"
        ],
        "additionalProperties": false
      },
      "OmicronPhysicalDiskConfig": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/TypedUuidForPhysicalDiskKind"
          },
          "identity": {
            "$ref": "#/components/schemas/DiskIdentity"
          },
          "pool_id": {
            "$ref": "#/components/schemas/TypedUuidForZpoolKind"
          }
        },
        "required": [
          "id",
          "identity",
          "pool_id"
        ]
      },
      "OmicronSledConfig": {
        "description": "Describes the set of Reconfigurator-managed configuration elements of a sled",
        "type": "object",
        "properties": {
          "datasets": {
            "$ref": "#/components/schemas/IdMapDatasetConfig"
          },
          "disks": {
            "$ref": "#/components/schemas/IdMapOmicronPhysicalDiskConfig"
          },
          "generation": {
            "$ref": "#/components/schemas/Generation"
          },
          "remove_mupdate_override": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForMupdateOverrideKind"
              }
            ]
          },
          "zones": {
            "$ref": "#/components/schemas/IdMapOmicronZoneConfig"
          }
        },
        "required": [
          "datasets",
          "disks",
          "generation",
          "zones"
        ]
      },
      "OmicronZoneConfig": {
        "description": "Describes one Omicron-managed zone running on a sled",
        "type": "object",
        "properties": {
          "filesystem_pool": {
            "nullable": true,
            "description": "The pool on which we'll place this zone's root filesystem.\n\nNote that the root filesystem is transient -- the sled agent is permitted to destroy this dataset each time the zone is initialized.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZpoolName"
              }
            ]
          },
          "id": {
            "$ref": "#/components/schemas/TypedUuidForOmicronZoneKind"
          },
          "image_source": {
            "default": {
              "type": "install_dataset"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/OmicronZoneImageSource"
              }
            ]
          },
          "zone_type": {
            "$ref": "#/components/schemas/OmicronZoneType"
          }
        },
        "required": [
          "id",
          "zone_type"
        ]
      },
      "OmicronZoneDataset": {
        "description": "Describes a persistent ZFS dataset associated with an Omicron zone",
        "type": "object",
        "properties": {
          "pool_name": {
            "$ref": "#/components/schemas/ZpoolName"
          }
        },
        "required": [
          "pool_name"
        ]
      },
      "OmicronZoneImageSource": {
        "description": "Where Sled Agent should get the image for a zone.",
        "oneOf": [
          {
            "description": "This zone's image source is whatever happens to be on the sled's \"install\" dataset.\n\nThis is whatever was put in place at the factory or by the latest MUPdate. The image used here can vary by sled and even over time (if the sled gets MUPdated again).\n\nHistorically, this was the only source for zone images. In an system with automated control-plane-driven update we expect to only use this variant in emergencies where the system had to be recovered via MUPdate.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "install_dataset"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "This zone's image source is the artifact matching this hash from the TUF artifact store (aka \"TUF repo depot\").\n\nThis originates from TUF repos uploaded to Nexus which are then replicated out to all sleds.",
            "type": "object",
            "properties": {
              "hash": {
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "type": {
                "type": "string",
                "enum": [
                  "artifact"
                ]
              }
            },
            "required": [
              "hash",
              "type"
            ]
          }
        ]
      },
      "OmicronZoneType": {
        "description": "Describes what kind of zone this is (i.e., what component is running in it) as well as any type-specific configuration",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dns_servers": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "domain": {
                "nullable": true,
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing outbound connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "ntp_servers": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "snat_cfg": {
                "description": "The SNAT configuration for outbound connections.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SourceNatConfig"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "boundary_ntp"
                ]
              }
            },
            "required": [
              "address",
              "dns_servers",
              "nic",
              "ntp_servers",
              "snat_cfg",
              "type"
            ]
          },
          {
            "description": "Type of clickhouse zone used for a single node clickhouse deployment",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "description": "A zone used to run a Clickhouse Keeper node\n\nKeepers are only used in replicated clickhouse setups",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_keeper"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "description": "A zone used to run a Clickhouse Server in a replicated deployment",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_server"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cockroach_db"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible_pantry"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "description": "The address at which the external DNS server is reachable.",
                "type": "string"
              },
              "http_address": {
                "description": "The address at which the external DNS server API is reachable.",
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "external_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "http_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "type": "string"
              },
              "gz_address": {
                "description": "The addresses in the global zone which should be created\n\nFor the DNS service, which exists outside the sleds's typical subnet - adding an address in the GZ is necessary to allow inter-zone traffic routing.",
                "type": "string",
                "format": "ipv6"
              },
              "gz_address_index": {
                "description": "The address is also identified with an auxiliary bit of information to ensure that the created global zone address can have a unique name.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "http_address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "gz_address",
              "gz_address_index",
              "http_address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_ntp"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "external_dns_servers": {
                "description": "External DNS servers Nexus can use to resolve external hosts.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "external_ip": {
                "description": "The address at which the external nexus server is reachable.",
                "type": "string",
                "format": "ip"
              },
              "external_tls": {
                "description": "Whether Nexus's external endpoint should use TLS",
                "type": "boolean"
              },
              "internal_address": {
                "description": "The address at which the internal nexus server is reachable.",
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "nexus"
                ]
              }
            },
            "required": [
              "external_dns_servers",
              "external_ip",
              "external_tls",
              "internal_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "oximeter"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          }
        ]
      },
      "P9fs": {
        "description": "Describes a filesystem to expose through a P9 device.\n\nThis is only supported by Propolis servers compiled with the `falcon` feature.",
        "type": "object",
        "properties": {
          "chunk_size": {
            "description": "The chunk size to use in the 9P protocol. Vanilla Helios images should use 8192. Falcon Helios base images and Linux can use up to 65536.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "pci_path": {
            "description": "The PCI path at which to attach the guest to this P9 filesystem.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          },
          "source": {
            "description": "The host source path to mount into the guest.",
            "type": "string"
          },
          "target": {
            "description": "The 9P target filesystem tag.",
            "type": "string"
          }
        },
        "required": [
          "chunk_size",
          "pci_path",
          "source",
          "target"
        ],
        "additionalProperties": false
      },
      "PciPath": {
        "description": "A PCI bus/device/function tuple.",
        "type": "object",
        "properties": {
          "bus": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "device": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "function": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          }
        },
        "required": [
          "bus",
          "device",
          "function"
        ]
      },
      "PciPciBridge": {
        "description": "A PCI-PCI bridge.",
        "type": "object",
        "properties": {
          "downstream_bus": {
            "description": "The logical bus number of this bridge's downstream bus. Other devices may use this bus number in their PCI paths to indicate they should be attached to this bridge's bus.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "pci_path": {
            "description": "The PCI path at which to attach this bridge.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          }
        },
        "required": [
          "downstream_bus",
          "pci_path"
        ],
        "additionalProperties": false
      },
      "PortConfigV2": {
        "type": "object",
        "properties": {
          "addresses": {
            "description": "This port's addresses and optional vlan IDs",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UplinkAddressConfig"
            }
          },
          "autoneg": {
            "description": "Whether or not to set autonegotiation",
            "default": false,
            "type": "boolean"
          },
          "bgp_peers": {
            "description": "BGP peers on this port",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BgpPeerConfig"
            }
          },
          "lldp": {
            "nullable": true,
            "description": "LLDP configuration for this port",
            "allOf": [
              {
                "$ref": "#/components/schemas/LldpPortConfig"
              }
            ]
          },
          "port": {
            "description": "Nmae of the port this config applies to.",
            "type": "string"
          },
          "routes": {
            "description": "The set of routes associated with this port.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RouteConfig"
            }
          },
          "switch": {
            "description": "Switch the port belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SwitchLocation"
              }
            ]
          },
          "tx_eq": {
            "nullable": true,
            "description": "TX-EQ configuration for this port",
            "allOf": [
              {
                "$ref": "#/components/schemas/TxEqConfig"
              }
            ]
          },
          "uplink_port_fec": {
            "nullable": true,
            "description": "Port forward error correction type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortFec"
              }
            ]
          },
          "uplink_port_speed": {
            "description": "Port speed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortSpeed"
              }
            ]
          }
        },
        "required": [
          "addresses",
          "bgp_peers",
          "port",
          "routes",
          "switch",
          "uplink_port_speed"
        ]
      },
      "PortFec": {
        "description": "Switchport FEC options",
        "type": "string",
        "enum": [
          "firecode",
          "none",
          "rs"
        ]
      },
      "PortSpeed": {
        "description": "Switchport Speed options",
        "type": "string",
        "enum": [
          "speed0_g",
          "speed1_g",
          "speed10_g",
          "speed25_g",
          "speed40_g",
          "speed50_g",
          "speed100_g",
          "speed200_g",
          "speed400_g"
        ]
      },
      "PriorityDimension": {
        "description": "A dimension along with bundles can be sorted, to determine priority.",
        "oneOf": [
          {
            "description": "Sorting by time, with older bundles with lower priority.",
            "type": "string",
            "enum": [
              "time"
            ]
          },
          {
            "description": "Sorting by the cause for creating the bundle.",
            "type": "string",
            "enum": [
              "cause"
            ]
          }
        ]
      },
      "PriorityOrder": {
        "description": "The priority order for bundles during cleanup.\n\nBundles are sorted along the dimensions in [`PriorityDimension`], with each dimension appearing exactly once. During cleanup, lesser-priority bundles are pruned first, to maintain the dataset quota. Note that bundles are sorted by each dimension in the order in which they appear, with each dimension having higher priority than the next.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PriorityDimension"
        },
        "minItems": 2,
        "maxItems": 2
      },
      "QemuPvpanic": {
        "type": "object",
        "properties": {
          "enable_isa": {
            "description": "Enable the QEMU PVPANIC ISA bus device (I/O port 0x505).",
            "type": "boolean"
          }
        },
        "required": [
          "enable_isa"
        ],
        "additionalProperties": false
      },
      "RackNetworkConfigV2": {
        "description": "Initial network configuration",
        "type": "object",
        "properties": {
          "bfd": {
            "description": "BFD configuration for connecting the rack to external networks",
            "default": [],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BfdPeerConfig"
            }
          },
          "bgp": {
            "description": "BGP configurations for connecting the rack to external networks",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BgpConfig"
            }
          },
          "infra_ip_first": {
            "description": "First ip address to be used for configuring network infrastructure",
            "type": "string",
            "format": "ipv4"
          },
          "infra_ip_last": {
            "description": "Last ip address to be used for configuring network infrastructure",
            "type": "string",
            "format": "ipv4"
          },
          "ports": {
            "description": "Uplinks for connecting the rack to external networks",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PortConfigV2"
            }
          },
          "rack_subnet": {
            "$ref": "#/components/schemas/Ipv6Net"
          }
        },
        "required": [
          "bgp",
          "infra_ip_first",
          "infra_ip_last",
          "ports",
          "rack_subnet"
        ]
      },
      "ResolvedVpcFirewallRule": {
        "description": "VPC firewall rule after object name resolution has been performed by Nexus",
        "type": "object",
        "properties": {
          "action": {
            "$ref": "#/components/schemas/VpcFirewallRuleAction"
          },
          "direction": {
            "$ref": "#/components/schemas/VpcFirewallRuleDirection"
          },
          "filter_hosts": {
            "nullable": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HostIdentifier"
            }
          },
          "filter_ports": {
            "nullable": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/L4PortRange"
            }
          },
          "filter_protocols": {
            "nullable": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VpcFirewallRuleProtocol"
            }
          },
          "priority": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "status": {
            "$ref": "#/components/schemas/VpcFirewallRuleStatus"
          },
          "targets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkInterface"
            }
          }
        },
        "required": [
          "action",
          "direction",
          "priority",
          "status",
          "targets"
        ]
      },
      "ResolvedVpcRoute": {
        "description": "A VPC route resolved into a concrete target.",
        "type": "object",
        "properties": {
          "dest": {
            "$ref": "#/components/schemas/IpNet"
          },
          "target": {
            "$ref": "#/components/schemas/RouterTarget"
          }
        },
        "required": [
          "dest",
          "target"
        ]
      },
      "ResolvedVpcRouteSet": {
        "description": "An updated set of routes for a given VPC and/or subnet.",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/RouterId"
          },
          "routes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedVpcRoute"
            },
            "uniqueItems": true
          },
          "version": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/RouterVersion"
              }
            ]
          }
        },
        "required": [
          "id",
          "routes"
        ]
      },
      "ResolvedVpcRouteState": {
        "description": "Version information for routes on a given VPC subnet.",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/RouterId"
          },
          "version": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/RouterVersion"
              }
            ]
          }
        },
        "required": [
          "id"
        ]
      },
      "RouteConfig": {
        "type": "object",
        "properties": {
          "destination": {
            "description": "The destination of the route.",
            "allOf": [
              {
                "$ref": "#/components/schemas/IpNet"
              }
            ]
          },
          "nexthop": {
            "description": "The nexthop/gateway address.",
            "type": "string",
            "format": "ip"
          },
          "rib_priority": {
            "nullable": true,
            "description": "The RIB priority (i.e. Admin Distance) associated with this route.",
            "default": null,
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "vlan_id": {
            "nullable": true,
            "description": "The VLAN id associated with this route.",
            "default": null,
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "destination",
          "nexthop"
        ]
      },
      "RouterId": {
        "description": "Identifier for a VPC and/or subnet.",
        "type": "object",
        "properties": {
          "kind": {
            "$ref": "#/components/schemas/RouterKind"
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "kind",
          "vni"
        ]
      },
      "RouterKind": {
        "description": "The scope of a set of VPC router rules.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "system"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "subnet": {
                "$ref": "#/components/schemas/IpNet"
              },
              "type": {
                "type": "string",
                "enum": [
                  "custom"
                ]
              }
            },
            "required": [
              "subnet",
              "type"
            ]
          }
        ]
      },
      "RouterTarget": {
        "description": "The target for a given router entry.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "drop"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "internet_gateway"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/InternetGatewayRouterTarget"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ip"
                ]
              },
              "value": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "vpc_subnet"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/IpNet"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "RouterVersion": {
        "description": "Information on the current parent router (and version) of a route set according to the control plane.",
        "type": "object",
        "properties": {
          "router_id": {
            "type": "string",
            "format": "uuid"
          },
          "version": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "router_id",
          "version"
        ]
      },
      "SerialPort": {
        "description": "A serial port device.",
        "type": "object",
        "properties": {
          "num": {
            "description": "The serial port number for this port.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SerialPortNumber"
              }
            ]
          }
        },
        "required": [
          "num"
        ],
        "additionalProperties": false
      },
      "SerialPortNumber": {
        "description": "A serial port identifier, which determines what I/O ports a guest can use to access a port.",
        "type": "string",
        "enum": [
          "com1",
          "com2",
          "com3",
          "com4"
        ]
      },
      "SledDiagnosticsQueryOutput": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "success": {
                "type": "object",
                "properties": {
                  "command": {
                    "description": "The command and its arguments.",
                    "type": "string"
                  },
                  "exit_code": {
                    "nullable": true,
                    "description": "The exit code if one was present when the command exited.",
                    "type": "integer",
                    "format": "int32"
                  },
                  "exit_status": {
                    "description": "The exit status of the command. This will be the exit code (if any) and exit reason such as from a signal.",
                    "type": "string"
                  },
                  "stdio": {
                    "description": "Any stdout/stderr produced by the command.",
                    "type": "string"
                  }
                },
                "required": [
                  "command",
                  "exit_status",
                  "stdio"
                ]
              }
            },
            "required": [
              "success"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "failure": {
                "type": "object",
                "properties": {
                  "error": {
                    "description": "The reason the command failed to execute.",
                    "type": "string"
                  }
                },
                "required": [
                  "error"
                ]
              }
            },
            "required": [
              "failure"
            ],
            "additionalProperties": false
          }
        ]
      },
      "SledIdentifiers": {
        "description": "Identifiers for a single sled.\n\nThis is intended primarily to be used in timeseries, to identify sled from which metric data originates.",
        "type": "object",
        "properties": {
          "model": {
            "description": "Model name of the sled",
            "type": "string"
          },
          "rack_id": {
            "description": "Control plane ID of the rack this sled is a member of",
            "type": "string",
            "format": "uuid"
          },
          "revision": {
            "description": "Revision number of the sled",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "serial": {
            "description": "Serial number of the sled",
            "type": "string"
          },
          "sled_id": {
            "description": "Control plane ID for the sled itself",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "model",
          "rack_id",
          "revision",
          "serial",
          "sled_id"
        ]
      },
      "SledRole": {
        "description": "Describes the role of the sled within the rack.\n\nNote that this may change if the sled is physically moved within the rack.",
        "oneOf": [
          {
            "description": "The sled is a general compute sled.",
            "type": "string",
            "enum": [
              "gimlet"
            ]
          },
          {
            "description": "The sled is attached to the network switch, and has additional responsibilities.",
            "type": "string",
            "enum": [
              "scrimlet"
            ]
          }
        ]
      },
      "SledVmmState": {
        "description": "A wrapper type containing a sled's total knowledge of the state of a VMM.",
        "type": "object",
        "properties": {
          "migration_in": {
            "nullable": true,
            "description": "The current state of any inbound migration to this VMM.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MigrationRuntimeState"
              }
            ]
          },
          "migration_out": {
            "nullable": true,
            "description": "The state of any outbound migration from this VMM.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MigrationRuntimeState"
              }
            ]
          },
          "vmm_state": {
            "description": "The most recent state of the sled's VMM process.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmRuntimeState"
              }
            ]
          }
        },
        "required": [
          "vmm_state"
        ]
      },
      "SoftNpuP9": {
        "description": "Describes a PCI device that shares host files with the guest using the P9 protocol.\n\nThis is only supported by Propolis servers compiled with the `falcon` feature.",
        "type": "object",
        "properties": {
          "pci_path": {
            "description": "The PCI path at which to attach the guest to this port.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          }
        },
        "required": [
          "pci_path"
        ],
        "additionalProperties": false
      },
      "SoftNpuPciPort": {
        "description": "Describes a SoftNPU PCI device.\n\nThis is only supported by Propolis servers compiled with the `falcon` feature.",
        "type": "object",
        "properties": {
          "pci_path": {
            "description": "The PCI path at which to attach the guest to this port.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          }
        },
        "required": [
          "pci_path"
        ],
        "additionalProperties": false
      },
      "SoftNpuPort": {
        "description": "Describes a port in a SoftNPU emulated ASIC.\n\nThis is only supported by Propolis servers compiled with the `falcon` feature.",
        "type": "object",
        "properties": {
          "backend_id": {
            "description": "The name of the port's associated DLPI backend.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpecKey"
              }
            ]
          },
          "link_name": {
            "description": "The data link name for this port.",
            "type": "string"
          }
        },
        "required": [
          "backend_id",
          "link_name"
        ],
        "additionalProperties": false
      },
      "SourceNatConfig": {
        "description": "An IP address and port range used for source NAT, i.e., making outbound network connections from guests or services.",
        "type": "object",
        "properties": {
          "first_port": {
            "description": "The first port used for source NAT, inclusive.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "ip": {
            "description": "The external address provided to the instance or service.",
            "type": "string",
            "format": "ip"
          },
          "last_port": {
            "description": "The last port used for source NAT, also inclusive.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "first_port",
          "ip",
          "last_port"
        ]
      },
      "SpecKey": {
        "description": "A key identifying a component in an instance spec.",
        "oneOf": [
          {
            "title": "uuid",
            "allOf": [
              {
                "type": "string",
                "format": "uuid"
              }
            ]
          },
          {
            "title": "name",
            "allOf": [
              {
                "type": "string"
              }
            ]
          }
        ]
      },
      "StartSledAgentRequest": {
        "description": "Configuration information for launching a Sled Agent.",
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/StartSledAgentRequestBody"
          },
          "generation": {
            "description": "The current generation number of data as stored in CRDB.\n\nThe initial generation is set during RSS time and then only mutated by Nexus. For now, we don't actually anticipate mutating this data, but we leave open the possiblity.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "schema_version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "body",
          "generation",
          "schema_version"
        ]
      },
      "StartSledAgentRequestBody": {
        "description": "This is the actual app level data of `StartSledAgentRequest`\n\nWe nest it below the \"header\" of `generation` and `schema_version` so that we can perform partial deserialization of `EarlyNetworkConfig` to only read the header and defer deserialization of the body once we know the schema version. This is possible via the use of [`serde_json::value::RawValue`] in future (post-v1) deserialization paths.",
        "type": "object",
        "properties": {
          "id": {
            "description": "Uuid of the Sled Agent to be created.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForSledKind"
              }
            ]
          },
          "is_lrtq_learner": {
            "description": "Is this node an LRTQ learner node?\n\nWe only put the node into learner mode if `use_trust_quorum` is also true.",
            "type": "boolean"
          },
          "rack_id": {
            "description": "Uuid of the rack to which this sled agent belongs.",
            "type": "string",
            "format": "uuid"
          },
          "subnet": {
            "description": "Portion of the IP space to be managed by the Sled Agent.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv6Subnet"
              }
            ]
          },
          "use_trust_quorum": {
            "description": "Use trust quorum for key generation",
            "type": "boolean"
          }
        },
        "required": [
          "id",
          "is_lrtq_learner",
          "rack_id",
          "subnet",
          "use_trust_quorum"
        ]
      },
      "StorageLimit": {
        "description": "The limit on space allowed for zone bundles, as a percentage of the overall dataset's quota.",
        "type": "integer",
        "format": "uint8",
        "minimum": 0
      },
      "SupportBundleMetadata": {
        "description": "Metadata about a support bundle",
        "type": "object",
        "properties": {
          "state": {
            "$ref": "#/components/schemas/SupportBundleState"
          },
          "support_bundle_id": {
            "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
          }
        },
        "required": [
          "state",
          "support_bundle_id"
        ]
      },
      "SupportBundleState": {
        "type": "string",
        "enum": [
          "complete",
          "incomplete"
        ]
      },
      "SwitchLocation": {
        "description": "Identifies switch physical location",
        "oneOf": [
          {
            "description": "Switch in upper slot",
            "type": "string",
            "enum": [
              "switch0"
            ]
          },
          {
            "description": "Switch in lower slot",
            "type": "string",
            "enum": [
              "switch1"
            ]
          }
        ]
      },
      "SwitchPorts": {
        "description": "A set of switch uplinks.",
        "type": "object",
        "properties": {
          "uplinks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HostPortConfig"
            }
          }
        },
        "required": [
          "uplinks"
        ]
      },
      "TimeSync": {
        "type": "object",
        "properties": {
          "correction": {
            "description": "The current offset between the NTP clock and system clock.",
            "type": "number",
            "format": "double"
          },
          "ip_addr": {
            "description": "The NTP reference IP address.",
            "type": "string",
            "format": "ip"
          },
          "ref_id": {
            "description": "The NTP reference ID.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "ref_time": {
            "description": "The NTP reference time (i.e. what chrony thinks the current time is, not necessarily the current system time).",
            "type": "number",
            "format": "double"
          },
          "stratum": {
            "description": "The NTP stratum (our upstream's stratum plus one).",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "sync": {
            "description": "The synchronization state of the sled, true when the system clock and the NTP clock are in sync (to within a small window).",
            "type": "boolean"
          }
        },
        "required": [
          "correction",
          "ip_addr",
          "ref_id",
          "ref_time",
          "stratum",
          "sync"
        ]
      },
      "TxEqConfig": {
        "description": "Per-port tx-eq overrides.  This can be used to fine-tune the transceiver equalization settings to improve signal integrity.",
        "type": "object",
        "properties": {
          "main": {
            "nullable": true,
            "description": "Main tap",
            "type": "integer",
            "format": "int32"
          },
          "post1": {
            "nullable": true,
            "description": "Post-cursor tap1",
            "type": "integer",
            "format": "int32"
          },
          "post2": {
            "nullable": true,
            "description": "Post-cursor tap2",
            "type": "integer",
            "format": "int32"
          },
          "pre1": {
            "nullable": true,
            "description": "Pre-cursor tap1",
            "type": "integer",
            "format": "int32"
          },
          "pre2": {
            "nullable": true,
            "description": "Pre-cursor tap2",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "TypedUuidForDatasetKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForInstanceKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForMupdateOverrideKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForOmicronZoneKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForPhysicalDiskKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForSledKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForSupportBundleKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForZpoolKind": {
        "type": "string",
        "format": "uuid"
      },
      "UplinkAddressConfig": {
        "type": "object",
        "properties": {
          "address": {
            "$ref": "#/components/schemas/IpNet"
          },
          "vlan_id": {
            "nullable": true,
            "description": "The VLAN id (if any) associated with this address.",
            "default": null,
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "address"
        ]
      },
      "VirtioDisk": {
        "description": "A disk that presents a virtio-block interface to the guest.",
        "type": "object",
        "properties": {
          "backend_id": {
            "description": "The name of the disk's backend component.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpecKey"
              }
            ]
          },
          "pci_path": {
            "description": "The PCI bus/device/function at which this disk should be attached.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          }
        },
        "required": [
          "backend_id",
          "pci_path"
        ],
        "additionalProperties": false
      },
      "VirtioNetworkBackend": {
        "description": "A network backend associated with a virtio-net (viona) VNIC on the host.",
        "type": "object",
        "properties": {
          "vnic_name": {
            "description": "The name of the viona VNIC to use as a backend.",
            "type": "string"
          }
        },
        "required": [
          "vnic_name"
        ],
        "additionalProperties": false
      },
      "VirtioNic": {
        "description": "A network card that presents a virtio-net interface to the guest.",
        "type": "object",
        "properties": {
          "backend_id": {
            "description": "The name of the device's backend.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpecKey"
              }
            ]
          },
          "interface_id": {
            "description": "A caller-defined correlation identifier for this interface. If Propolis is configured to collect network interface kstats in its Oximeter metrics, the metric series for this interface will be associated with this identifier.",
            "type": "string",
            "format": "uuid"
          },
          "pci_path": {
            "description": "The PCI path at which to attach this device.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PciPath"
              }
            ]
          }
        },
        "required": [
          "backend_id",
          "interface_id",
          "pci_path"
        ],
        "additionalProperties": false
      },
      "VirtualNetworkInterfaceHost": {
        "description": "A mapping from a virtual NIC to a physical host",
        "type": "object",
        "properties": {
          "physical_host_ip": {
            "type": "string",
            "format": "ipv6"
          },
          "virtual_ip": {
            "type": "string",
            "format": "ip"
          },
          "virtual_mac": {
            "$ref": "#/components/schemas/MacAddr"
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "physical_host_ip",
          "virtual_ip",
          "virtual_mac",
          "vni"
        ]
      },
      "VmmIssueDiskSnapshotRequestBody": {
        "type": "object",
        "properties": {
          "snapshot_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "snapshot_id"
        ]
      },
      "VmmIssueDiskSnapshotRequestResponse": {
        "type": "object",
        "properties": {
          "snapshot_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "snapshot_id"
        ]
      },
      "VmmPutStateBody": {
        "description": "The body of a request to move a previously-ensured instance into a specific runtime state.",
        "type": "object",
        "properties": {
          "state": {
            "description": "The state into which the instance should be driven.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmStateRequested"
              }
            ]
          }
        },
        "required": [
          "state"
        ]
      },
      "VmmPutStateResponse": {
        "description": "The response sent from a request to move an instance into a specific runtime state.",
        "type": "object",
        "properties": {
          "updated_runtime": {
            "nullable": true,
            "description": "The current runtime state of the instance after handling the request to change its state. If the instance's state did not change, this field is `None`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SledVmmState"
              }
            ]
          }
        }
      },
      "VmmRuntimeState": {
        "description": "The dynamic runtime properties of an individual VMM process.",
        "type": "object",
        "properties": {
          "gen": {
            "description": "The generation number for this VMM's state.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "state": {
            "description": "The last state reported by this VMM.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmState"
              }
            ]
          },
          "time_updated": {
            "description": "Timestamp for the VMM's state.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "state",
          "time_updated"
        ]
      },
      "VmmSpec": {
        "description": "Specifies the virtual hardware configuration of a new Propolis VMM in the form of a Propolis instance specification.\n\nSled-agent expects that when an instance spec is provided alongside an `InstanceSledLocalConfig` to initialize a new instance, the NIC IDs in that config's network interface list will match the IDs of the virtio network backends in the instance spec.",
        "allOf": [
          {
            "$ref": "#/components/schemas/InstanceSpecV0"
          }
        ]
      },
      "VmmState": {
        "description": "One of the states that a VMM can be in.",
        "oneOf": [
          {
            "description": "The VMM is initializing and has not started running guest CPUs yet.",
            "type": "string",
            "enum": [
              "starting"
            ]
          },
          {
            "description": "The VMM has finished initializing and may be running guest CPUs.",
            "type": "string",
            "enum": [
              "running"
            ]
          },
          {
            "description": "The VMM is shutting down.",
            "type": "string",
            "enum": [
              "stopping"
            ]
          },
          {
            "description": "The VMM's guest has stopped, and the guest will not run again, but the VMM process may not have released all of its resources yet.",
            "type": "string",
            "enum": [
              "stopped"
            ]
          },
          {
            "description": "The VMM is being restarted or its guest OS is rebooting.",
            "type": "string",
            "enum": [
              "rebooting"
            ]
          },
          {
            "description": "The VMM is part of a live migration.",
            "type": "string",
            "enum": [
              "migrating"
            ]
          },
          {
            "description": "The VMM process reported an internal failure.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "The VMM process has been destroyed and its resources have been released.",
            "type": "string",
            "enum": [
              "destroyed"
            ]
          }
        ]
      },
      "VmmStateRequested": {
        "description": "Requestable running state of an Instance.\n\nA subset of [`omicron_common::api::external::InstanceState`].",
        "oneOf": [
          {
            "description": "Run this instance by migrating in from a previous running incarnation of the instance.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "migration_target"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/InstanceMigrationTargetParams"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "Start the instance if it is not already running.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "running"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Stop the instance.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stopped"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Immediately reset the instance, as though it had stopped and immediately began to run again.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "reboot"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "VmmUnregisterResponse": {
        "description": "The response sent from a request to unregister an instance.",
        "type": "object",
        "properties": {
          "updated_runtime": {
            "nullable": true,
            "description": "The current state of the instance after handling the request to unregister it. If the instance's state did not change, this field is `None`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SledVmmState"
              }
            ]
          }
        }
      },
      "Vni": {
        "description": "A Geneve Virtual Network Identifier",
        "type": "integer",
        "format": "uint32",
        "minimum": 0
      },
      "VpcFirewallRuleAction": {
        "type": "string",
        "enum": [
          "allow",
          "deny"
        ]
      },
      "VpcFirewallRuleDirection": {
        "type": "string",
        "enum": [
          "inbound",
          "outbound"
        ]
      },
      "VpcFirewallRuleProtocol": {
        "description": "The protocols that may be specified in a firewall rule's filter",
        "type": "string",
        "enum": [
          "TCP",
          "UDP",
          "ICMP"
        ]
      },
      "VpcFirewallRuleStatus": {
        "type": "string",
        "enum": [
          "disabled",
          "enabled"
        ]
      },
      "VpcFirewallRulesEnsureBody": {
        "description": "Update firewall rules for a VPC",
        "type": "object",
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResolvedVpcFirewallRule"
            }
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "rules",
          "vni"
        ]
      },
      "ZoneBundleCause": {
        "description": "The reason or cause for a zone bundle, i.e., why it was created.",
        "oneOf": [
          {
            "description": "Some other, unspecified reason.",
            "type": "string",
            "enum": [
              "other"
            ]
          },
          {
            "description": "A zone bundle taken when a sled agent finds a zone that it does not expect to be running.",
            "type": "string",
            "enum": [
              "unexpected_zone"
            ]
          },
          {
            "description": "An instance zone was terminated.",
            "type": "string",
            "enum": [
              "terminated_instance"
            ]
          }
        ]
      },
      "ZoneBundleId": {
        "description": "An identifier for a zone bundle.",
        "type": "object",
        "properties": {
          "bundle_id": {
            "description": "The ID for this bundle itself.",
            "type": "string",
            "format": "uuid"
          },
          "zone_name": {
            "description": "The name of the zone this bundle is derived from.",
            "type": "string"
          }
        },
        "required": [
          "bundle_id",
          "zone_name"
        ]
      },
      "ZoneBundleMetadata": {
        "description": "Metadata about a zone bundle.",
        "type": "object",
        "properties": {
          "cause": {
            "description": "The reason or cause a bundle was created.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZoneBundleCause"
              }
            ]
          },
          "id": {
            "description": "Identifier for this zone bundle",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZoneBundleId"
              }
            ]
          },
          "time_created": {
            "description": "The time at which this zone bundle was created.",
            "type": "string",
            "format": "date-time"
          },
          "version": {
            "description": "A version number for this zone bundle.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          }
        },
        "required": [
          "cause",
          "id",
          "time_created",
          "version"
        ]
      },
      "ZpoolName": {
        "title": "The name of a Zpool",
        "description": "Zpool names are of the format ox{i,p}_<UUID>. They are either Internal or External, and should be unique",
        "type": "string",
        "pattern": "^ox[ip]_[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
      },
      "M2Slot": {
        "description": "Describes an M.2 slot, often in the context of writing a system image to it.",
        "type": "string",
        "enum": [
          "A",
          "B"
        ]
      },
      "TypedUuidForPropolisKind": {
        "type": "string",
        "format": "uuid"
      }
    },
    "responses": {
      "Error": {
        "description": "Error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      }
    }
  }
}
