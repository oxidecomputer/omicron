{
  "openapi": "3.0.3",
  "info": {
    "title": "Oxide Sled Agent API",
    "description": "API for interacting with individual sleds",
    "contact": {
      "url": "https://oxide.computer",
      "email": "api@oxide.computer"
    },
    "version": "0.0.1"
  },
  "paths": {
    "/boot-disk/{boot_disk}/os/write": {
      "post": {
        "summary": "Write a new host OS image to the specified boot disk",
        "operationId": "host_os_write_start",
        "parameters": [
          {
            "in": "path",
            "name": "boot_disk",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/M2Slot"
            }
          },
          {
            "in": "query",
            "name": "sha3_256_digest",
            "required": true,
            "schema": {
              "type": "string",
              "format": "hex string (32 bytes)"
            }
          },
          {
            "in": "query",
            "name": "update_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/boot-disk/{boot_disk}/os/write/status": {
      "get": {
        "summary": "Get the status of writing a new host OS",
        "operationId": "host_os_write_status_get",
        "parameters": [
          {
            "in": "path",
            "name": "boot_disk",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/M2Slot"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BootDiskOsWriteStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/boot-disk/{boot_disk}/os/write/status/{update_id}": {
      "delete": {
        "summary": "Clear the status of a completed write of a new host OS",
        "operationId": "host_os_write_status_delete",
        "parameters": [
          {
            "in": "path",
            "name": "boot_disk",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/M2Slot"
            }
          },
          {
            "in": "path",
            "name": "update_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/bootstore/status": {
      "get": {
        "summary": "Get the internal state of the local bootstore node",
        "operationId": "bootstore_status",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BootstoreStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/cockroachdb": {
      "post": {
        "summary": "Initializes a CockroachDB cluster",
        "operationId": "cockroachdb_init",
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/disks/{disk_id}": {
      "put": {
        "operationId": "disk_put",
        "parameters": [
          {
            "in": "path",
            "name": "disk_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiskEnsureBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DiskRuntimeState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/instances/{instance_id}": {
      "put": {
        "operationId": "instance_register",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceEnsureBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledInstanceState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "operationId": "instance_unregister",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InstanceUnregisterResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/instances/{instance_id}/disks/{disk_id}/snapshot": {
      "post": {
        "summary": "Take a snapshot of a disk that is attached to an instance",
        "operationId": "instance_issue_disk_snapshot_request",
        "parameters": [
          {
            "in": "path",
            "name": "disk_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceIssueDiskSnapshotRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InstanceIssueDiskSnapshotRequestResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/instances/{instance_id}/external-ip": {
      "put": {
        "operationId": "instance_put_external_ip",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceExternalIpBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "operationId": "instance_delete_external_ip",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceExternalIpBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/instances/{instance_id}/migration-ids": {
      "put": {
        "operationId": "instance_put_migration_ids",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstancePutMigrationIdsBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledInstanceState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/instances/{instance_id}/state": {
      "get": {
        "operationId": "instance_get_state",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledInstanceState"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "instance_put_state",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstancePutStateBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InstancePutStateResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/inventory": {
      "get": {
        "summary": "Fetch basic information about this sled",
        "operationId": "inventory",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Inventory"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/network-bootstore-config": {
      "get": {
        "summary": "This API endpoint is only reading the local sled agent's view of the",
        "description": "bootstore. The boostore is a distributed data store that is eventually consistent. Reads from individual nodes may not represent the latest state.",
        "operationId": "read_network_bootstore_config_cache",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EarlyNetworkConfig"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "write_network_bootstore_config",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EarlyNetworkConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/omicron-physical-disks": {
      "get": {
        "operationId": "omicron_physical_disks_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OmicronPhysicalDisksConfig"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "omicron_physical_disks_put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OmicronPhysicalDisksConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DisksManagementResult"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/omicron-zones": {
      "get": {
        "operationId": "omicron_zones_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OmicronZonesConfig"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "operationId": "omicron_zones_put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OmicronZonesConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sled-role": {
      "get": {
        "operationId": "sled_role_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledRole"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sleds": {
      "put": {
        "summary": "Add a sled to a rack that was already initialized via RSS",
        "operationId": "sled_add",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddSledRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/switch-ports": {
      "post": {
        "operationId": "uplink_ensure",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SwitchPorts"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/timesync": {
      "get": {
        "operationId": "timesync_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TimeSync"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/update": {
      "post": {
        "operationId": "update_artifact",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateArtifactId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/v2p": {
      "get": {
        "summary": "List v2p mappings present on sled",
        "operationId": "list_v2p",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_VirtualNetworkInterfaceHost",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/VirtualNetworkInterfaceHost"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "summary": "Create a mapping from a virtual NIC to a physical host",
        "operationId": "set_v2p",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VirtualNetworkInterfaceHost"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Delete a mapping from a virtual NIC to a physical host",
        "operationId": "del_v2p",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VirtualNetworkInterfaceHost"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/vpc/{vpc_id}/firewall/rules": {
      "put": {
        "operationId": "vpc_firewall_rules_put",
        "parameters": [
          {
            "in": "path",
            "name": "vpc_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VpcFirewallRulesEnsureBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones": {
      "get": {
        "summary": "List the zones that are currently managed by the sled agent.",
        "operationId": "zones_list",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_String",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundle-cleanup": {
      "post": {
        "summary": "Trigger a zone bundle cleanup.",
        "operationId": "zone_bundle_cleanup",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Map_of_CleanupCount",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/CleanupCount"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundle-cleanup/context": {
      "get": {
        "summary": "Return context used by the zone-bundle cleanup task.",
        "operationId": "zone_bundle_cleanup_context",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CleanupContext"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "summary": "Update context used by the zone-bundle cleanup task.",
        "operationId": "zone_bundle_cleanup_context_update",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CleanupContextUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundle-cleanup/utilization": {
      "get": {
        "summary": "Return utilization information about all zone bundles.",
        "operationId": "zone_bundle_utilization",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Map_of_BundleUtilization",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/BundleUtilization"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundles": {
      "get": {
        "summary": "List all zone bundles that exist, even for now-deleted zones.",
        "operationId": "zone_bundle_list_all",
        "parameters": [
          {
            "in": "query",
            "name": "filter",
            "description": "An optional substring used to filter zone bundles.",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ZoneBundleMetadata",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ZoneBundleMetadata"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundles/{zone_name}": {
      "get": {
        "summary": "List the zone bundles that are available for a running zone.",
        "operationId": "zone_bundle_list",
        "parameters": [
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ZoneBundleMetadata",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ZoneBundleMetadata"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "post": {
        "summary": "Ask the sled agent to create a zone bundle.",
        "operationId": "zone_bundle_create",
        "parameters": [
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "successful creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZoneBundleMetadata"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zones/bundles/{zone_name}/{bundle_id}": {
      "get": {
        "summary": "Fetch the binary content of a single zone bundle.",
        "operationId": "zone_bundle_get",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "The ID for this bundle itself.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone this bundle is derived from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Delete a zone bundle.",
        "operationId": "zone_bundle_delete",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "The ID for this bundle itself.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "zone_name",
            "description": "The name of the zone this bundle is derived from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "successful deletion"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/zpools": {
      "get": {
        "operationId": "zpools_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_Zpool",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Zpool"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AddSledRequest": {
        "description": "A request to Add a given sled after rack initialization has occurred",
        "type": "object",
        "properties": {
          "sled_id": {
            "$ref": "#/components/schemas/BaseboardId"
          },
          "start_request": {
            "$ref": "#/components/schemas/StartSledAgentRequest"
          }
        },
        "required": [
          "sled_id",
          "start_request"
        ]
      },
      "Baseboard": {
        "description": "Describes properties that should uniquely identify a Gimlet.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string"
              },
              "model": {
                "type": "string"
              },
              "revision": {
                "type": "integer",
                "format": "int64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "gimlet"
                ]
              }
            },
            "required": [
              "identifier",
              "model",
              "revision",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unknown"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string"
              },
              "model": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "pc"
                ]
              }
            },
            "required": [
              "identifier",
              "model",
              "type"
            ]
          }
        ]
      },
      "BaseboardId": {
        "description": "A representation of a Baseboard ID as used in the inventory subsystem This type is essentially the same as a `Baseboard` except it doesn't have a revision or HW type (Gimlet, PC, Unknown).",
        "type": "object",
        "properties": {
          "part_number": {
            "description": "Oxide Part Number",
            "type": "string"
          },
          "serial_number": {
            "description": "Serial number (unique for a given part number)",
            "type": "string"
          }
        },
        "required": [
          "part_number",
          "serial_number"
        ]
      },
      "BfdMode": {
        "description": "BFD connection mode.",
        "type": "string",
        "enum": [
          "single_hop",
          "multi_hop"
        ]
      },
      "BfdPeerConfig": {
        "type": "object",
        "properties": {
          "detection_threshold": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "local": {
            "nullable": true,
            "type": "string",
            "format": "ip"
          },
          "mode": {
            "$ref": "#/components/schemas/BfdMode"
          },
          "remote": {
            "type": "string",
            "format": "ip"
          },
          "required_rx": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "switch": {
            "$ref": "#/components/schemas/SwitchLocation"
          }
        },
        "required": [
          "detection_threshold",
          "mode",
          "remote",
          "required_rx",
          "switch"
        ]
      },
      "BgpConfig": {
        "type": "object",
        "properties": {
          "asn": {
            "description": "The autonomous system number for the BGP configuration.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "checker": {
            "nullable": true,
            "description": "Checker to apply to incoming messages.",
            "type": "string"
          },
          "originate": {
            "description": "The set of prefixes for the BGP router to originate.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Ipv4Net"
            }
          },
          "shaper": {
            "nullable": true,
            "description": "Shaper to apply to outgoing messages.",
            "type": "string"
          }
        },
        "required": [
          "asn",
          "originate"
        ]
      },
      "BgpPeerConfig": {
        "type": "object",
        "properties": {
          "addr": {
            "description": "Address of the peer.",
            "type": "string",
            "format": "ipv4"
          },
          "allowed_export": {
            "description": "Define export policy for a peer.",
            "default": {
              "type": "no_filtering"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportExportPolicy"
              }
            ]
          },
          "allowed_import": {
            "description": "Define import policy for a peer.",
            "default": {
              "type": "no_filtering"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportExportPolicy"
              }
            ]
          },
          "asn": {
            "description": "The autonomous system number of the router the peer belongs to.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "communities": {
            "description": "Include the provided communities in updates sent to the peer.",
            "default": [],
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          },
          "connect_retry": {
            "nullable": true,
            "description": "The interval in seconds between peer connection retry attempts.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "delay_open": {
            "nullable": true,
            "description": "How long to delay sending open messages to a peer. In seconds.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "enforce_first_as": {
            "description": "Enforce that the first AS in paths received from this peer is the peer's AS.",
            "default": false,
            "type": "boolean"
          },
          "hold_time": {
            "nullable": true,
            "description": "How long to keep a session alive without a keepalive in seconds. Defaults to 6.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "idle_hold_time": {
            "nullable": true,
            "description": "How long to keep a peer in idle after a state machine reset in seconds.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "keepalive": {
            "nullable": true,
            "description": "The interval to send keepalive messages at.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "local_pref": {
            "nullable": true,
            "description": "Apply a local preference to routes received from this peer.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "md5_auth_key": {
            "nullable": true,
            "description": "Use the given key for TCP-MD5 authentication with the peer.",
            "type": "string"
          },
          "min_ttl": {
            "nullable": true,
            "description": "Require messages from a peer have a minimum IP time to live field.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "multi_exit_discriminator": {
            "nullable": true,
            "description": "Apply the provided multi-exit discriminator (MED) updates sent to the peer.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "port": {
            "description": "Switch port the peer is reachable on.",
            "type": "string"
          },
          "remote_asn": {
            "nullable": true,
            "description": "Require that a peer has a specified ASN.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "vlan_id": {
            "nullable": true,
            "description": "Associate a VLAN ID with a BGP peer session.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "addr",
          "asn",
          "port"
        ]
      },
      "BootDiskOsWriteProgress": {
        "description": "Current progress of an OS image being written to disk.",
        "oneOf": [
          {
            "description": "The image is still being uploaded.",
            "type": "object",
            "properties": {
              "bytes_received": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "state": {
                "type": "string",
                "enum": [
                  "receiving_uploaded_image"
                ]
              }
            },
            "required": [
              "bytes_received",
              "state"
            ]
          },
          {
            "description": "The image is being written to disk.",
            "type": "object",
            "properties": {
              "bytes_written": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "state": {
                "type": "string",
                "enum": [
                  "writing_image_to_disk"
                ]
              }
            },
            "required": [
              "bytes_written",
              "state"
            ]
          },
          {
            "description": "The image is being read back from disk for validation.",
            "type": "object",
            "properties": {
              "bytes_read": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "state": {
                "type": "string",
                "enum": [
                  "validating_written_image"
                ]
              }
            },
            "required": [
              "bytes_read",
              "state"
            ]
          }
        ]
      },
      "BootDiskOsWriteStatus": {
        "description": "Status of an update to a boot disk OS.",
        "oneOf": [
          {
            "description": "No update has been started for this disk, or any previously-started update has completed and had its status cleared.",
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "no_update_started"
                ]
              }
            },
            "required": [
              "status"
            ]
          },
          {
            "description": "An update is currently running.",
            "type": "object",
            "properties": {
              "progress": {
                "$ref": "#/components/schemas/BootDiskOsWriteProgress"
              },
              "status": {
                "type": "string",
                "enum": [
                  "in_progress"
                ]
              },
              "update_id": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "progress",
              "status",
              "update_id"
            ]
          },
          {
            "description": "The most recent update completed successfully.",
            "type": "object",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "complete"
                ]
              },
              "update_id": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "status",
              "update_id"
            ]
          },
          {
            "description": "The most recent update failed.",
            "type": "object",
            "properties": {
              "message": {
                "type": "string"
              },
              "status": {
                "type": "string",
                "enum": [
                  "failed"
                ]
              },
              "update_id": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "message",
              "status",
              "update_id"
            ]
          }
        ]
      },
      "BootstoreStatus": {
        "type": "object",
        "properties": {
          "accepted_connections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "established_connections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EstablishedConnection"
            }
          },
          "fsm_ledger_generation": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "fsm_state": {
            "type": "string"
          },
          "negotiating_connections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          },
          "network_config_ledger_generation": {
            "nullable": true,
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "peers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "accepted_connections",
          "established_connections",
          "fsm_ledger_generation",
          "fsm_state",
          "negotiating_connections",
          "peers"
        ]
      },
      "BundleUtilization": {
        "description": "The portion of a debug dataset used for zone bundles.",
        "type": "object",
        "properties": {
          "bytes_available": {
            "description": "The total number of bytes available for zone bundles.\n\nThis is `dataset_quota` multiplied by the context's storage limit.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "bytes_used": {
            "description": "Total bundle usage, in bytes.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "dataset_quota": {
            "description": "The total dataset quota, in bytes.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "bytes_available",
          "bytes_used",
          "dataset_quota"
        ]
      },
      "ByteCount": {
        "description": "Byte count to express memory or storage capacity.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "CleanupContext": {
        "description": "Context provided for the zone bundle cleanup task.",
        "type": "object",
        "properties": {
          "period": {
            "description": "The period on which automatic checks and cleanup is performed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CleanupPeriod"
              }
            ]
          },
          "priority": {
            "description": "The priority ordering for keeping old bundles.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PriorityOrder"
              }
            ]
          },
          "storage_limit": {
            "description": "The limit on the dataset quota available for zone bundles.",
            "allOf": [
              {
                "$ref": "#/components/schemas/StorageLimit"
              }
            ]
          }
        },
        "required": [
          "period",
          "priority",
          "storage_limit"
        ]
      },
      "CleanupContextUpdate": {
        "description": "Parameters used to update the zone bundle cleanup context.",
        "type": "object",
        "properties": {
          "period": {
            "nullable": true,
            "description": "The new period on which automatic cleanups are run.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ]
          },
          "priority": {
            "nullable": true,
            "description": "The priority ordering for preserving old zone bundles.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PriorityOrder"
              }
            ]
          },
          "storage_limit": {
            "nullable": true,
            "description": "The new limit on the underlying dataset quota allowed for bundles.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          }
        }
      },
      "CleanupCount": {
        "description": "The count of bundles / bytes removed during a cleanup operation.",
        "type": "object",
        "properties": {
          "bundles": {
            "description": "The number of bundles removed.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "bytes": {
            "description": "The number of bytes removed.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "bundles",
          "bytes"
        ]
      },
      "CleanupPeriod": {
        "description": "A period on which bundles are automatically cleaned up.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Duration"
          }
        ]
      },
      "CrucibleOpts": {
        "description": "CrucibleOpts\n\n<details><summary>JSON schema</summary>\n\n```json { \"type\": \"object\", \"required\": [ \"id\", \"lossy\", \"read_only\", \"target\" ], \"properties\": { \"cert_pem\": { \"type\": [ \"string\", \"null\" ] }, \"control\": { \"type\": [ \"string\", \"null\" ] }, \"flush_timeout\": { \"type\": [ \"number\", \"null\" ], \"format\": \"float\" }, \"id\": { \"type\": \"string\", \"format\": \"uuid\" }, \"key\": { \"type\": [ \"string\", \"null\" ] }, \"key_pem\": { \"type\": [ \"string\", \"null\" ] }, \"lossy\": { \"type\": \"boolean\" }, \"read_only\": { \"type\": \"boolean\" }, \"root_cert_pem\": { \"type\": [ \"string\", \"null\" ] }, \"target\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } } } } ``` </details>",
        "type": "object",
        "properties": {
          "cert_pem": {
            "nullable": true,
            "type": "string"
          },
          "control": {
            "nullable": true,
            "type": "string"
          },
          "flush_timeout": {
            "nullable": true,
            "type": "number",
            "format": "float"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "key": {
            "nullable": true,
            "type": "string"
          },
          "key_pem": {
            "nullable": true,
            "type": "string"
          },
          "lossy": {
            "type": "boolean"
          },
          "read_only": {
            "type": "boolean"
          },
          "root_cert_pem": {
            "nullable": true,
            "type": "string"
          },
          "target": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "id",
          "lossy",
          "read_only",
          "target"
        ]
      },
      "DhcpConfig": {
        "description": "DHCP configuration for a port\n\nNot present here: Hostname (DHCPv4 option 12; used in DHCPv6 option 39); we use `InstanceRuntimeState::hostname` for this value.",
        "type": "object",
        "properties": {
          "dns_servers": {
            "description": "DNS servers to send to the instance\n\n(DHCPv4 option 6; DHCPv6 option 23)",
            "type": "array",
            "items": {
              "type": "string",
              "format": "ip"
            }
          },
          "host_domain": {
            "nullable": true,
            "description": "DNS zone this instance's hostname belongs to (e.g. the `project.example` part of `instance1.project.example`)\n\n(DHCPv4 option 15; used in DHCPv6 option 39)",
            "type": "string"
          },
          "search_domains": {
            "description": "DNS search domains\n\n(DHCPv4 option 119; DHCPv6 option 24)",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "dns_servers",
          "search_domains"
        ]
      },
      "DiskEnsureBody": {
        "description": "Sent from to a sled agent to establish the runtime state of a Disk",
        "type": "object",
        "properties": {
          "initial_runtime": {
            "description": "Last runtime state of the Disk known to Nexus (used if the agent has never seen this Disk before).",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskRuntimeState"
              }
            ]
          },
          "target": {
            "description": "requested runtime state of the Disk",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskStateRequested"
              }
            ]
          }
        },
        "required": [
          "initial_runtime",
          "target"
        ]
      },
      "DiskIdentity": {
        "description": "Uniquely identifies a disk.",
        "type": "object",
        "properties": {
          "model": {
            "type": "string"
          },
          "serial": {
            "type": "string"
          },
          "vendor": {
            "type": "string"
          }
        },
        "required": [
          "model",
          "serial",
          "vendor"
        ]
      },
      "DiskManagementError": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "not_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "zpool_uuid_mismatch"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "expected": {
                    "$ref": "#/components/schemas/TypedUuidForZpoolKind"
                  },
                  "observed": {
                    "$ref": "#/components/schemas/TypedUuidForZpoolKind"
                  }
                },
                "required": [
                  "expected",
                  "observed"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "key_manager"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "other"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "DiskManagementStatus": {
        "description": "Identifies how a single disk management operation may have succeeded or failed.",
        "type": "object",
        "properties": {
          "err": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskManagementError"
              }
            ]
          },
          "identity": {
            "$ref": "#/components/schemas/DiskIdentity"
          }
        },
        "required": [
          "identity"
        ]
      },
      "DiskRequest": {
        "description": "DiskRequest\n\n<details><summary>JSON schema</summary>\n\n```json { \"type\": \"object\", \"required\": [ \"device\", \"name\", \"read_only\", \"slot\", \"volume_construction_request\" ], \"properties\": { \"device\": { \"type\": \"string\" }, \"name\": { \"type\": \"string\" }, \"read_only\": { \"type\": \"boolean\" }, \"slot\": { \"$ref\": \"#/components/schemas/Slot\" }, \"volume_construction_request\": { \"$ref\": \"#/components/schemas/VolumeConstructionRequest\" } } } ``` </details>",
        "type": "object",
        "properties": {
          "device": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "read_only": {
            "type": "boolean"
          },
          "slot": {
            "$ref": "#/components/schemas/Slot"
          },
          "volume_construction_request": {
            "$ref": "#/components/schemas/VolumeConstructionRequest"
          }
        },
        "required": [
          "device",
          "name",
          "read_only",
          "slot",
          "volume_construction_request"
        ]
      },
      "DiskRuntimeState": {
        "description": "Runtime state of the Disk, which includes its attach state and some minimal metadata",
        "type": "object",
        "properties": {
          "disk_state": {
            "description": "runtime state of the Disk",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskState"
              }
            ]
          },
          "gen": {
            "description": "generation number for this state",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "time_updated": {
            "description": "timestamp for this information",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "disk_state",
          "gen",
          "time_updated"
        ]
      },
      "DiskState": {
        "description": "State of a Disk",
        "oneOf": [
          {
            "description": "Disk is being initialized",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "creating"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is ready but detached from any Instance",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "detached"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is ready to receive blocks from an external source",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "import_ready"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is importing blocks from a URL",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "importing_from_url"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is importing blocks from bulk writes",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "importing_from_bulk_writes"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is being finalized to state Detached",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "finalizing"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is undergoing maintenance",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "maintenance"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is being attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attached"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is being detached from the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "detaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk has been destroyed",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "destroyed"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is unavailable",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "faulted"
                ]
              }
            },
            "required": [
              "state"
            ]
          }
        ]
      },
      "DiskStateRequested": {
        "description": "Used to request a Disk state change",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "detached"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attached"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "destroyed"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "faulted"
                ]
              }
            },
            "required": [
              "state"
            ]
          }
        ]
      },
      "DiskType": {
        "type": "string",
        "enum": [
          "U2",
          "M2"
        ]
      },
      "DiskVariant": {
        "type": "string",
        "enum": [
          "U2",
          "M2"
        ]
      },
      "DisksManagementResult": {
        "description": "The result from attempting to manage underlying disks.\n\nThis is more complex than a simple \"Error\" type because it's possible for some disks to be initialized correctly, while others can fail.\n\nThis structure provides a mechanism for callers to learn about partial failures, and handle them appropriately on a per-disk basis.",
        "type": "object",
        "properties": {
          "status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DiskManagementStatus"
            }
          }
        },
        "required": [
          "status"
        ]
      },
      "Duration": {
        "type": "object",
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "nanos",
          "secs"
        ]
      },
      "EarlyNetworkConfig": {
        "description": "Network configuration required to bring up the control plane\n\nThe fields in this structure are those from [`super::params::RackInitializeRequest`] necessary for use beyond RSS. This is just for the initial rack configuration and cold boot purposes. Updates come from Nexus.",
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/EarlyNetworkConfigBody"
          },
          "generation": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "schema_version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "body",
          "generation",
          "schema_version"
        ]
      },
      "EarlyNetworkConfigBody": {
        "description": "This is the actual configuration of EarlyNetworking.\n\nWe nest it below the \"header\" of `generation` and `schema_version` so that we can perform partial deserialization of `EarlyNetworkConfig` to only read the header and defer deserialization of the body once we know the schema version. This is possible via the use of [`serde_json::value::RawValue`] in future (post-v1) deserialization paths.",
        "type": "object",
        "properties": {
          "ntp_servers": {
            "description": "The external NTP server addresses.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "rack_network_config": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/RackNetworkConfigV2"
              }
            ]
          }
        },
        "required": [
          "ntp_servers"
        ]
      },
      "Error": {
        "description": "Error information from a response.",
        "type": "object",
        "properties": {
          "error_code": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "request_id"
        ]
      },
      "EstablishedConnection": {
        "type": "object",
        "properties": {
          "addr": {
            "type": "string"
          },
          "baseboard": {
            "$ref": "#/components/schemas/Baseboard"
          }
        },
        "required": [
          "addr",
          "baseboard"
        ]
      },
      "Generation": {
        "description": "Generation numbers stored in the database, used for optimistic concurrency control",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "HostIdentifier": {
        "description": "A `HostIdentifier` represents either an IP host or network (v4 or v6), or an entire VPC (identified by its VNI). It is used in firewall rule host filters.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ip"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/IpNet"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "vpc"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/Vni"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "HostPortConfig": {
        "type": "object",
        "properties": {
          "addrs": {
            "description": "IP Address and prefix (e.g., `192.168.0.1/16`) to apply to switchport (must be in infra_ip pool).  May also include an optional VLAN ID.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UplinkAddressConfig"
            }
          },
          "port": {
            "description": "Switchport to use for external connectivity",
            "type": "string"
          }
        },
        "required": [
          "addrs",
          "port"
        ]
      },
      "Hostname": {
        "title": "An RFC-1035-compliant hostname",
        "description": "A hostname identifies a host on a network, and is usually a dot-delimited sequence of labels, where each label contains only letters, digits, or the hyphen. See RFCs 1035 and 952 for more details.",
        "type": "string",
        "pattern": "^([a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))(\\.[a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))*$",
        "minLength": 1,
        "maxLength": 253
      },
      "ImportExportPolicy": {
        "description": "Define policy relating to the import and export of prefixes from a BGP peer.",
        "oneOf": [
          {
            "description": "Do not perform any filtering.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_filtering"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "allow"
                ]
              },
              "value": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IpNet"
                }
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "InstanceCpuCount": {
        "description": "The number of CPUs in an Instance",
        "type": "integer",
        "format": "uint16",
        "minimum": 0
      },
      "InstanceEnsureBody": {
        "description": "The body of a request to ensure that a instance and VMM are known to a sled agent.",
        "type": "object",
        "properties": {
          "hardware": {
            "description": "A description of the instance's virtual hardware and the initial runtime state this sled agent should store for this incarnation of the instance.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceHardware"
              }
            ]
          },
          "instance_runtime": {
            "description": "The instance runtime state for the instance being registered.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceRuntimeState"
              }
            ]
          },
          "metadata": {
            "description": "Metadata used to track instance statistics.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceMetadata"
              }
            ]
          },
          "propolis_addr": {
            "description": "The address at which this VMM should serve a Propolis server API.",
            "type": "string"
          },
          "propolis_id": {
            "description": "The ID of the VMM being registered. This may not be the active VMM ID in the instance runtime state (e.g. if the new VMM is going to be a migration target).",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForPropolisKind"
              }
            ]
          },
          "vmm_runtime": {
            "description": "The initial VMM runtime state for the VMM being registered.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmRuntimeState"
              }
            ]
          }
        },
        "required": [
          "hardware",
          "instance_runtime",
          "metadata",
          "propolis_addr",
          "propolis_id",
          "vmm_runtime"
        ]
      },
      "InstanceExternalIpBody": {
        "description": "Used to dynamically update external IPs attached to an instance.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ephemeral"
                ]
              },
              "value": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "floating"
                ]
              },
              "value": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "InstanceHardware": {
        "description": "Describes the instance hardware.",
        "type": "object",
        "properties": {
          "cloud_init_bytes": {
            "nullable": true,
            "type": "string"
          },
          "dhcp_config": {
            "$ref": "#/components/schemas/DhcpConfig"
          },
          "disks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DiskRequest"
            }
          },
          "ephemeral_ip": {
            "nullable": true,
            "description": "Zero or more external IP addresses (either floating or ephemeral), provided to an instance to allow inbound connectivity.",
            "type": "string",
            "format": "ip"
          },
          "firewall_rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VpcFirewallRule"
            }
          },
          "floating_ips": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "ip"
            }
          },
          "nics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkInterface"
            }
          },
          "properties": {
            "$ref": "#/components/schemas/InstanceProperties"
          },
          "source_nat": {
            "$ref": "#/components/schemas/SourceNatConfig"
          }
        },
        "required": [
          "dhcp_config",
          "disks",
          "firewall_rules",
          "floating_ips",
          "nics",
          "properties",
          "source_nat"
        ]
      },
      "InstanceIssueDiskSnapshotRequestBody": {
        "type": "object",
        "properties": {
          "snapshot_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "snapshot_id"
        ]
      },
      "InstanceIssueDiskSnapshotRequestResponse": {
        "type": "object",
        "properties": {
          "snapshot_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "snapshot_id"
        ]
      },
      "InstanceMetadata": {
        "description": "Metadata used to track statistics about an instance.",
        "type": "object",
        "properties": {
          "project_id": {
            "type": "string",
            "format": "uuid"
          },
          "silo_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "project_id",
          "silo_id"
        ]
      },
      "InstanceMigrationSourceParams": {
        "description": "Instance runtime state to update for a migration.",
        "type": "object",
        "properties": {
          "dst_propolis_id": {
            "$ref": "#/components/schemas/TypedUuidForPropolisKind"
          },
          "migration_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "dst_propolis_id",
          "migration_id"
        ]
      },
      "InstanceMigrationTargetParams": {
        "description": "Parameters used when directing Propolis to initialize itself via live migration.",
        "type": "object",
        "properties": {
          "src_propolis_addr": {
            "description": "The address of the Propolis server that will serve as the migration source.",
            "type": "string"
          },
          "src_propolis_id": {
            "description": "The Propolis ID of the migration source.",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "src_propolis_addr",
          "src_propolis_id"
        ]
      },
      "InstanceProperties": {
        "description": "The \"static\" properties of an instance: information about the instance that doesn't change while the instance is running.",
        "type": "object",
        "properties": {
          "hostname": {
            "description": "RFC1035-compliant hostname for the instance.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Hostname"
              }
            ]
          },
          "memory": {
            "$ref": "#/components/schemas/ByteCount"
          },
          "ncpus": {
            "$ref": "#/components/schemas/InstanceCpuCount"
          }
        },
        "required": [
          "hostname",
          "memory",
          "ncpus"
        ]
      },
      "InstancePutMigrationIdsBody": {
        "description": "The body of a request to set or clear the migration identifiers from a sled agent's instance state records.",
        "type": "object",
        "properties": {
          "migration_params": {
            "nullable": true,
            "description": "The migration identifiers to set. If `None`, this operation clears the migration IDs.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceMigrationSourceParams"
              }
            ]
          },
          "old_runtime": {
            "description": "The last instance runtime state known to this requestor. This request will succeed if either (a) the state generation in the sled agent's runtime state matches the generation in this record, or (b) the sled agent's runtime state matches what would result from applying this request to the caller's runtime state. This latter condition provides idempotency.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceRuntimeState"
              }
            ]
          }
        },
        "required": [
          "old_runtime"
        ]
      },
      "InstancePutStateBody": {
        "description": "The body of a request to move a previously-ensured instance into a specific runtime state.",
        "type": "object",
        "properties": {
          "state": {
            "description": "The state into which the instance should be driven.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceStateRequested"
              }
            ]
          }
        },
        "required": [
          "state"
        ]
      },
      "InstancePutStateResponse": {
        "description": "The response sent from a request to move an instance into a specific runtime state.",
        "type": "object",
        "properties": {
          "updated_runtime": {
            "nullable": true,
            "description": "The current runtime state of the instance after handling the request to change its state. If the instance's state did not change, this field is `None`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SledInstanceState"
              }
            ]
          }
        }
      },
      "InstanceRuntimeState": {
        "description": "The dynamic runtime properties of an instance: its current VMM ID (if any), migration information (if any), and the instance state to report if there is no active VMM.",
        "type": "object",
        "properties": {
          "dst_propolis_id": {
            "nullable": true,
            "description": "If a migration is active, the ID of the target VMM.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForPropolisKind"
              }
            ]
          },
          "gen": {
            "description": "Generation number for this state.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "migration_id": {
            "nullable": true,
            "description": "If a migration is active, the ID of that migration.",
            "type": "string",
            "format": "uuid"
          },
          "propolis_id": {
            "nullable": true,
            "description": "The instance's currently active VMM ID.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForPropolisKind"
              }
            ]
          },
          "time_updated": {
            "description": "Timestamp for this information.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "time_updated"
        ]
      },
      "InstanceStateRequested": {
        "description": "Requestable running state of an Instance.\n\nA subset of [`omicron_common::api::external::InstanceState`].",
        "oneOf": [
          {
            "description": "Run this instance by migrating in from a previous running incarnation of the instance.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "migration_target"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/InstanceMigrationTargetParams"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "Start the instance if it is not already running.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "running"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Stop the instance.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stopped"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Immediately reset the instance, as though it had stopped and immediately began to run again.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "reboot"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "InstanceUnregisterResponse": {
        "description": "The response sent from a request to unregister an instance.",
        "type": "object",
        "properties": {
          "updated_runtime": {
            "nullable": true,
            "description": "The current state of the instance after handling the request to unregister it. If the instance's state did not change, this field is `None`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SledInstanceState"
              }
            ]
          }
        }
      },
      "Inventory": {
        "description": "Identity and basic status information about this sled agent",
        "type": "object",
        "properties": {
          "baseboard": {
            "$ref": "#/components/schemas/Baseboard"
          },
          "disks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InventoryDisk"
            }
          },
          "reservoir_size": {
            "$ref": "#/components/schemas/ByteCount"
          },
          "sled_agent_address": {
            "type": "string"
          },
          "sled_id": {
            "type": "string",
            "format": "uuid"
          },
          "sled_role": {
            "$ref": "#/components/schemas/SledRole"
          },
          "usable_hardware_threads": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "usable_physical_ram": {
            "$ref": "#/components/schemas/ByteCount"
          },
          "zpools": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InventoryZpool"
            }
          }
        },
        "required": [
          "baseboard",
          "disks",
          "reservoir_size",
          "sled_agent_address",
          "sled_id",
          "sled_role",
          "usable_hardware_threads",
          "usable_physical_ram",
          "zpools"
        ]
      },
      "InventoryDisk": {
        "description": "Identifies information about disks which may be attached to Sleds.",
        "type": "object",
        "properties": {
          "identity": {
            "$ref": "#/components/schemas/DiskIdentity"
          },
          "slot": {
            "type": "integer",
            "format": "int64"
          },
          "variant": {
            "$ref": "#/components/schemas/DiskVariant"
          }
        },
        "required": [
          "identity",
          "slot",
          "variant"
        ]
      },
      "InventoryZpool": {
        "description": "Identifies information about zpools managed by the control plane",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/TypedUuidForZpoolKind"
          },
          "total_size": {
            "$ref": "#/components/schemas/ByteCount"
          }
        },
        "required": [
          "id",
          "total_size"
        ]
      },
      "IpNet": {
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::IpNet",
          "version": "0.1.0"
        },
        "oneOf": [
          {
            "title": "v4",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv4Net"
              }
            ]
          },
          {
            "title": "v6",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv6Net"
              }
            ]
          }
        ]
      },
      "Ipv4Net": {
        "example": "192.168.1.0/24",
        "title": "An IPv4 subnet",
        "description": "An IPv4 subnet, including prefix and prefix length",
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::Ipv4Net",
          "version": "0.1.0"
        },
        "type": "string",
        "pattern": "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|1[0-9]|2[0-9]|3[0-2])$"
      },
      "Ipv6Net": {
        "example": "fd12:3456::/64",
        "title": "An IPv6 subnet",
        "description": "An IPv6 subnet, including prefix and subnet mask",
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::Ipv6Net",
          "version": "0.1.0"
        },
        "type": "string",
        "pattern": "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
      },
      "Ipv6Subnet": {
        "description": "Wraps an [`Ipv6Net`] with a compile-time prefix length.",
        "type": "object",
        "properties": {
          "net": {
            "$ref": "#/components/schemas/Ipv6Net"
          }
        },
        "required": [
          "net"
        ]
      },
      "KnownArtifactKind": {
        "description": "Kinds of update artifacts, as used by Nexus to determine what updates are available and by sled-agent to determine how to apply an update when asked.",
        "type": "string",
        "enum": [
          "gimlet_sp",
          "gimlet_rot",
          "gimlet_rot_bootloader",
          "host",
          "trampoline",
          "control_plane",
          "psc_sp",
          "psc_rot",
          "psc_rot_bootloader",
          "switch_sp",
          "switch_rot",
          "switch_rot_bootloader"
        ]
      },
      "L4PortRange": {
        "example": "22",
        "title": "A range of IP ports",
        "description": "An inclusive-inclusive range of IP ports. The second port may be omitted to represent a single port",
        "type": "string",
        "pattern": "^[0-9]{1,5}(-[0-9]{1,5})?$",
        "minLength": 1,
        "maxLength": 11
      },
      "MacAddr": {
        "example": "ff:ff:ff:ff:ff:ff",
        "title": "A MAC address",
        "description": "A Media Access Control address, in EUI-48 format",
        "type": "string",
        "pattern": "^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$",
        "minLength": 5,
        "maxLength": 17
      },
      "MigrationRole": {
        "oneOf": [
          {
            "description": "This update concerns the source VMM of a migration.",
            "type": "string",
            "enum": [
              "source"
            ]
          },
          {
            "description": "This update concerns the target VMM of a migration.",
            "type": "string",
            "enum": [
              "target"
            ]
          }
        ]
      },
      "MigrationRuntimeState": {
        "description": "An update from a sled regarding the state of a migration, indicating the role of the VMM whose migration state was updated.",
        "type": "object",
        "properties": {
          "gen": {
            "$ref": "#/components/schemas/Generation"
          },
          "migration_id": {
            "type": "string",
            "format": "uuid"
          },
          "role": {
            "$ref": "#/components/schemas/MigrationRole"
          },
          "state": {
            "$ref": "#/components/schemas/MigrationState"
          },
          "time_updated": {
            "description": "Timestamp for the migration state update.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "migration_id",
          "role",
          "state",
          "time_updated"
        ]
      },
      "MigrationState": {
        "description": "The state of an instance's live migration.",
        "oneOf": [
          {
            "description": "The migration has not started for this VMM.",
            "type": "string",
            "enum": [
              "pending"
            ]
          },
          {
            "description": "The migration is in progress.",
            "type": "string",
            "enum": [
              "in_progress"
            ]
          },
          {
            "description": "The migration has failed.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "The migration has completed.",
            "type": "string",
            "enum": [
              "completed"
            ]
          }
        ]
      },
      "Name": {
        "title": "A name unique within the parent collection",
        "description": "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID.",
        "type": "string",
        "pattern": "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$",
        "minLength": 1,
        "maxLength": 63
      },
      "NetworkInterface": {
        "description": "Information required to construct a virtual network interface",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "ip": {
            "type": "string",
            "format": "ip"
          },
          "kind": {
            "$ref": "#/components/schemas/NetworkInterfaceKind"
          },
          "mac": {
            "$ref": "#/components/schemas/MacAddr"
          },
          "name": {
            "$ref": "#/components/schemas/Name"
          },
          "primary": {
            "type": "boolean"
          },
          "slot": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "subnet": {
            "$ref": "#/components/schemas/IpNet"
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "id",
          "ip",
          "kind",
          "mac",
          "name",
          "primary",
          "slot",
          "subnet",
          "vni"
        ]
      },
      "NetworkInterfaceKind": {
        "description": "The type of network interface",
        "oneOf": [
          {
            "description": "A vNIC attached to a guest instance",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "instance"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          },
          {
            "description": "A vNIC associated with an internal service",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "service"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          },
          {
            "description": "A vNIC associated with a probe",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "probe"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          }
        ]
      },
      "OmicronPhysicalDiskConfig": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "identity": {
            "$ref": "#/components/schemas/DiskIdentity"
          },
          "pool_id": {
            "$ref": "#/components/schemas/TypedUuidForZpoolKind"
          }
        },
        "required": [
          "id",
          "identity",
          "pool_id"
        ]
      },
      "OmicronPhysicalDisksConfig": {
        "type": "object",
        "properties": {
          "disks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OmicronPhysicalDiskConfig"
            }
          },
          "generation": {
            "description": "generation number of this configuration\n\nThis generation number is owned by the control plane (i.e., RSS or Nexus, depending on whether RSS-to-Nexus handoff has happened).  It should not be bumped within Sled Agent.\n\nSled Agent rejects attempts to set the configuration to a generation older than the one it's currently running.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          }
        },
        "required": [
          "disks",
          "generation"
        ]
      },
      "OmicronZoneConfig": {
        "description": "Describes one Omicron-managed zone running on a sled",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "underlay_address": {
            "type": "string",
            "format": "ipv6"
          },
          "zone_type": {
            "$ref": "#/components/schemas/OmicronZoneType"
          }
        },
        "required": [
          "id",
          "underlay_address",
          "zone_type"
        ]
      },
      "OmicronZoneDataset": {
        "description": "Describes a persistent ZFS dataset associated with an Omicron zone",
        "type": "object",
        "properties": {
          "pool_name": {
            "$ref": "#/components/schemas/ZpoolName"
          }
        },
        "required": [
          "pool_name"
        ]
      },
      "OmicronZoneType": {
        "description": "Describes what kind of zone this is (i.e., what component is running in it) as well as any type-specific configuration",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dns_servers": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "domain": {
                "nullable": true,
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing outbound connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "ntp_servers": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "snat_cfg": {
                "description": "The SNAT configuration for outbound connections.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SourceNatConfig"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "boundary_ntp"
                ]
              }
            },
            "required": [
              "address",
              "dns_servers",
              "nic",
              "ntp_servers",
              "snat_cfg",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_keeper"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cockroach_db"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible_pantry"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "description": "The address at which the external DNS server is reachable.",
                "type": "string"
              },
              "http_address": {
                "description": "The address at which the external DNS server API is reachable.",
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "external_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "http_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "type": "string"
              },
              "gz_address": {
                "description": "The addresses in the global zone which should be created\n\nFor the DNS service, which exists outside the sleds's typical subnet - adding an address in the GZ is necessary to allow inter-zone traffic routing.",
                "type": "string",
                "format": "ipv6"
              },
              "gz_address_index": {
                "description": "The address is also identified with an auxiliary bit of information to ensure that the created global zone address can have a unique name.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "http_address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "gz_address",
              "gz_address_index",
              "http_address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dns_servers": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "domain": {
                "nullable": true,
                "type": "string"
              },
              "ntp_servers": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_ntp"
                ]
              }
            },
            "required": [
              "address",
              "dns_servers",
              "ntp_servers",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "external_dns_servers": {
                "description": "External DNS servers Nexus can use to resolve external hosts.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "external_ip": {
                "description": "The address at which the external nexus server is reachable.",
                "type": "string",
                "format": "ip"
              },
              "external_tls": {
                "description": "Whether Nexus's external endpoint should use TLS",
                "type": "boolean"
              },
              "internal_address": {
                "description": "The address at which the internal nexus server is reachable.",
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "nexus"
                ]
              }
            },
            "required": [
              "external_dns_servers",
              "external_ip",
              "external_tls",
              "internal_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "oximeter"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          }
        ]
      },
      "OmicronZonesConfig": {
        "description": "Describes the set of Omicron-managed zones running on a sled",
        "type": "object",
        "properties": {
          "generation": {
            "description": "generation number of this configuration\n\nThis generation number is owned by the control plane (i.e., RSS or Nexus, depending on whether RSS-to-Nexus handoff has happened).  It should not be bumped within Sled Agent.\n\nSled Agent rejects attempts to set the configuration to a generation older than the one it's currently running.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "zones": {
            "description": "list of running zones",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OmicronZoneConfig"
            }
          }
        },
        "required": [
          "generation",
          "zones"
        ]
      },
      "PortConfigV2": {
        "type": "object",
        "properties": {
          "addresses": {
            "description": "This port's addresses and optional vlan IDs",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UplinkAddressConfig"
            }
          },
          "autoneg": {
            "description": "Whether or not to set autonegotiation",
            "default": false,
            "type": "boolean"
          },
          "bgp_peers": {
            "description": "BGP peers on this port",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BgpPeerConfig"
            }
          },
          "port": {
            "description": "Nmae of the port this config applies to.",
            "type": "string"
          },
          "routes": {
            "description": "The set of routes associated with this port.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RouteConfig"
            }
          },
          "switch": {
            "description": "Switch the port belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SwitchLocation"
              }
            ]
          },
          "uplink_port_fec": {
            "description": "Port forward error correction type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortFec"
              }
            ]
          },
          "uplink_port_speed": {
            "description": "Port speed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortSpeed"
              }
            ]
          }
        },
        "required": [
          "addresses",
          "bgp_peers",
          "port",
          "routes",
          "switch",
          "uplink_port_fec",
          "uplink_port_speed"
        ]
      },
      "PortFec": {
        "description": "Switchport FEC options",
        "type": "string",
        "enum": [
          "firecode",
          "none",
          "rs"
        ]
      },
      "PortSpeed": {
        "description": "Switchport Speed options",
        "type": "string",
        "enum": [
          "speed0_g",
          "speed1_g",
          "speed10_g",
          "speed25_g",
          "speed40_g",
          "speed50_g",
          "speed100_g",
          "speed200_g",
          "speed400_g"
        ]
      },
      "PriorityDimension": {
        "description": "A dimension along with bundles can be sorted, to determine priority.",
        "oneOf": [
          {
            "description": "Sorting by time, with older bundles with lower priority.",
            "type": "string",
            "enum": [
              "time"
            ]
          },
          {
            "description": "Sorting by the cause for creating the bundle.",
            "type": "string",
            "enum": [
              "cause"
            ]
          }
        ]
      },
      "PriorityOrder": {
        "description": "The priority order for bundles during cleanup.\n\nBundles are sorted along the dimensions in [`PriorityDimension`], with each dimension appearing exactly once. During cleanup, lesser-priority bundles are pruned first, to maintain the dataset quota. Note that bundles are sorted by each dimension in the order in which they appear, with each dimension having higher priority than the next.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PriorityDimension"
        },
        "minItems": 2,
        "maxItems": 2
      },
      "RackNetworkConfigV2": {
        "description": "Initial network configuration",
        "type": "object",
        "properties": {
          "bfd": {
            "description": "BFD configuration for connecting the rack to external networks",
            "default": [],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BfdPeerConfig"
            }
          },
          "bgp": {
            "description": "BGP configurations for connecting the rack to external networks",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BgpConfig"
            }
          },
          "infra_ip_first": {
            "description": "First ip address to be used for configuring network infrastructure",
            "type": "string",
            "format": "ipv4"
          },
          "infra_ip_last": {
            "description": "Last ip address to be used for configuring network infrastructure",
            "type": "string",
            "format": "ipv4"
          },
          "ports": {
            "description": "Uplinks for connecting the rack to external networks",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PortConfigV2"
            }
          },
          "rack_subnet": {
            "$ref": "#/components/schemas/Ipv6Net"
          }
        },
        "required": [
          "bgp",
          "infra_ip_first",
          "infra_ip_last",
          "ports",
          "rack_subnet"
        ]
      },
      "RouteConfig": {
        "type": "object",
        "properties": {
          "destination": {
            "description": "The destination of the route.",
            "allOf": [
              {
                "$ref": "#/components/schemas/IpNet"
              }
            ]
          },
          "nexthop": {
            "description": "The nexthop/gateway address.",
            "type": "string",
            "format": "ip"
          },
          "vlan_id": {
            "nullable": true,
            "description": "The VLAN id associated with this route.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "destination",
          "nexthop"
        ]
      },
      "SemverVersion": {
        "type": "string",
        "pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
      },
      "SledInstanceState": {
        "description": "A wrapper type containing a sled's total knowledge of the state of a specific VMM and the instance it incarnates.",
        "type": "object",
        "properties": {
          "instance_state": {
            "description": "The sled's conception of the state of the instance.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceRuntimeState"
              }
            ]
          },
          "migration_state": {
            "nullable": true,
            "description": "The current state of any in-progress migration for this instance, as understood by this sled.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MigrationRuntimeState"
              }
            ]
          },
          "propolis_id": {
            "description": "The ID of the VMM whose state is being reported.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TypedUuidForPropolisKind"
              }
            ]
          },
          "vmm_state": {
            "description": "The most recent state of the sled's VMM process.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmRuntimeState"
              }
            ]
          }
        },
        "required": [
          "instance_state",
          "propolis_id",
          "vmm_state"
        ]
      },
      "SledRole": {
        "description": "Describes the role of the sled within the rack.\n\nNote that this may change if the sled is physically moved within the rack.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"Describes the role of the sled within the rack.\\n\\nNote that this may change if the sled is physically moved within the rack.\", \"oneOf\": [ { \"description\": \"The sled is a general compute sled.\", \"type\": \"string\", \"enum\": [ \"gimlet\" ] }, { \"description\": \"The sled is attached to the network switch, and has additional responsibilities.\", \"type\": \"string\", \"enum\": [ \"scrimlet\" ] } ] } ``` </details>",
        "oneOf": [
          {
            "description": "The sled is a general compute sled.",
            "type": "string",
            "enum": [
              "gimlet"
            ]
          },
          {
            "description": "The sled is attached to the network switch, and has additional responsibilities.",
            "type": "string",
            "enum": [
              "scrimlet"
            ]
          }
        ]
      },
      "Slot": {
        "description": "A stable index which is translated by Propolis into a PCI BDF, visible to the guest.\n\n<details><summary>JSON schema</summary>\n\n```json { \"description\": \"A stable index which is translated by Propolis into a PCI BDF, visible to the guest.\", \"type\": \"integer\", \"format\": \"uint8\", \"minimum\": 0.0 } ``` </details>",
        "type": "integer",
        "format": "uint8",
        "minimum": 0
      },
      "SourceNatConfig": {
        "description": "An IP address and port range used for source NAT, i.e., making outbound network connections from guests or services.",
        "type": "object",
        "properties": {
          "first_port": {
            "description": "The first port used for source NAT, inclusive.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "ip": {
            "description": "The external address provided to the instance or service.",
            "type": "string",
            "format": "ip"
          },
          "last_port": {
            "description": "The last port used for source NAT, also inclusive.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "first_port",
          "ip",
          "last_port"
        ]
      },
      "StartSledAgentRequest": {
        "description": "Configuration information for launching a Sled Agent.",
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/StartSledAgentRequestBody"
          },
          "generation": {
            "description": "The current generation number of data as stored in CRDB.\n\nThe initial generation is set during RSS time and then only mutated by Nexus. For now, we don't actually anticipate mutating this data, but we leave open the possiblity.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "schema_version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "body",
          "generation",
          "schema_version"
        ]
      },
      "StartSledAgentRequestBody": {
        "description": "This is the actual app level data of `StartSledAgentRequest`\n\nWe nest it below the \"header\" of `generation` and `schema_version` so that we can perform partial deserialization of `EarlyNetworkConfig` to only read the header and defer deserialization of the body once we know the schema version. This is possible via the use of [`serde_json::value::RawValue`] in future (post-v1) deserialization paths.",
        "type": "object",
        "properties": {
          "id": {
            "description": "Uuid of the Sled Agent to be created.",
            "type": "string",
            "format": "uuid"
          },
          "is_lrtq_learner": {
            "description": "Is this node an LRTQ learner node?\n\nWe only put the node into learner mode if `use_trust_quorum` is also true.",
            "type": "boolean"
          },
          "rack_id": {
            "description": "Uuid of the rack to which this sled agent belongs.",
            "type": "string",
            "format": "uuid"
          },
          "subnet": {
            "description": "Portion of the IP space to be managed by the Sled Agent.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv6Subnet"
              }
            ]
          },
          "use_trust_quorum": {
            "description": "Use trust quorum for key generation",
            "type": "boolean"
          }
        },
        "required": [
          "id",
          "is_lrtq_learner",
          "rack_id",
          "subnet",
          "use_trust_quorum"
        ]
      },
      "StorageLimit": {
        "description": "The limit on space allowed for zone bundles, as a percentage of the overall dataset's quota.",
        "type": "integer",
        "format": "uint8",
        "minimum": 0
      },
      "SwitchLocation": {
        "description": "Identifies switch physical location",
        "oneOf": [
          {
            "description": "Switch in upper slot",
            "type": "string",
            "enum": [
              "switch0"
            ]
          },
          {
            "description": "Switch in lower slot",
            "type": "string",
            "enum": [
              "switch1"
            ]
          }
        ]
      },
      "SwitchPorts": {
        "description": "A set of switch uplinks.",
        "type": "object",
        "properties": {
          "uplinks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HostPortConfig"
            }
          }
        },
        "required": [
          "uplinks"
        ]
      },
      "TimeSync": {
        "type": "object",
        "properties": {
          "correction": {
            "description": "The current offset between the NTP clock and system clock.",
            "type": "number",
            "format": "double"
          },
          "ip_addr": {
            "description": "The NTP reference IP address.",
            "type": "string",
            "format": "ip"
          },
          "ref_id": {
            "description": "The NTP reference ID.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "ref_time": {
            "description": "The NTP reference time (i.e. what chrony thinks the current time is, not necessarily the current system time).",
            "type": "number",
            "format": "double"
          },
          "stratum": {
            "description": "The NTP stratum (our upstream's stratum plus one).",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "sync": {
            "description": "The synchronization state of the sled, true when the system clock and the NTP clock are in sync (to within a small window).",
            "type": "boolean"
          }
        },
        "required": [
          "correction",
          "ip_addr",
          "ref_id",
          "ref_time",
          "stratum",
          "sync"
        ]
      },
      "TypedUuidForPropolisKind": {
        "type": "string",
        "format": "uuid"
      },
      "TypedUuidForZpoolKind": {
        "type": "string",
        "format": "uuid"
      },
      "UpdateArtifactId": {
        "description": "An identifier for a single update artifact.",
        "type": "object",
        "properties": {
          "kind": {
            "description": "The kind of update artifact this is.",
            "allOf": [
              {
                "$ref": "#/components/schemas/KnownArtifactKind"
              }
            ]
          },
          "name": {
            "description": "The artifact's name.",
            "type": "string"
          },
          "version": {
            "description": "The artifact's version.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SemverVersion"
              }
            ]
          }
        },
        "required": [
          "kind",
          "name",
          "version"
        ]
      },
      "UplinkAddressConfig": {
        "type": "object",
        "properties": {
          "address": {
            "$ref": "#/components/schemas/IpNet"
          },
          "vlan_id": {
            "nullable": true,
            "description": "The VLAN id (if any) associated with this address.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "address"
        ]
      },
      "VirtualNetworkInterfaceHost": {
        "description": "A mapping from a virtual NIC to a physical host",
        "type": "object",
        "properties": {
          "physical_host_ip": {
            "type": "string",
            "format": "ipv6"
          },
          "virtual_ip": {
            "type": "string",
            "format": "ip"
          },
          "virtual_mac": {
            "$ref": "#/components/schemas/MacAddr"
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "physical_host_ip",
          "virtual_ip",
          "virtual_mac",
          "vni"
        ]
      },
      "VmmRuntimeState": {
        "description": "The dynamic runtime properties of an individual VMM process.",
        "type": "object",
        "properties": {
          "gen": {
            "description": "The generation number for this VMM's state.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "state": {
            "description": "The last state reported by this VMM.",
            "allOf": [
              {
                "$ref": "#/components/schemas/VmmState"
              }
            ]
          },
          "time_updated": {
            "description": "Timestamp for the VMM's state.",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "state",
          "time_updated"
        ]
      },
      "VmmState": {
        "description": "One of the states that a VMM can be in.",
        "oneOf": [
          {
            "description": "The VMM is initializing and has not started running guest CPUs yet.",
            "type": "string",
            "enum": [
              "starting"
            ]
          },
          {
            "description": "The VMM has finished initializing and may be running guest CPUs.",
            "type": "string",
            "enum": [
              "running"
            ]
          },
          {
            "description": "The VMM is shutting down.",
            "type": "string",
            "enum": [
              "stopping"
            ]
          },
          {
            "description": "The VMM's guest has stopped, and the guest will not run again, but the VMM process may not have released all of its resources yet.",
            "type": "string",
            "enum": [
              "stopped"
            ]
          },
          {
            "description": "The VMM is being restarted or its guest OS is rebooting.",
            "type": "string",
            "enum": [
              "rebooting"
            ]
          },
          {
            "description": "The VMM is part of a live migration.",
            "type": "string",
            "enum": [
              "migrating"
            ]
          },
          {
            "description": "The VMM process reported an internal failure.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "The VMM process has been destroyed and its resources have been released.",
            "type": "string",
            "enum": [
              "destroyed"
            ]
          }
        ]
      },
      "Vni": {
        "description": "A Geneve Virtual Network Identifier",
        "type": "integer",
        "format": "uint32",
        "minimum": 0
      },
      "VolumeConstructionRequest": {
        "description": "VolumeConstructionRequest\n\n<details><summary>JSON schema</summary>\n\n```json { \"oneOf\": [ { \"type\": \"object\", \"required\": [ \"block_size\", \"id\", \"sub_volumes\", \"type\" ], \"properties\": { \"block_size\": { \"type\": \"integer\", \"format\": \"uint64\", \"minimum\": 0.0 }, \"id\": { \"type\": \"string\", \"format\": \"uuid\" }, \"read_only_parent\": { \"allOf\": [ { \"$ref\": \"#/components/schemas/VolumeConstructionRequest\" } ] }, \"sub_volumes\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/VolumeConstructionRequest\" } }, \"type\": { \"type\": \"string\", \"enum\": [ \"volume\" ] } } }, { \"type\": \"object\", \"required\": [ \"block_size\", \"id\", \"type\", \"url\" ], \"properties\": { \"block_size\": { \"type\": \"integer\", \"format\": \"uint64\", \"minimum\": 0.0 }, \"id\": { \"type\": \"string\", \"format\": \"uuid\" }, \"type\": { \"type\": \"string\", \"enum\": [ \"url\" ] }, \"url\": { \"type\": \"string\" } } }, { \"type\": \"object\", \"required\": [ \"block_size\", \"blocks_per_extent\", \"extent_count\", \"gen\", \"opts\", \"type\" ], \"properties\": { \"block_size\": { \"type\": \"integer\", \"format\": \"uint64\", \"minimum\": 0.0 }, \"blocks_per_extent\": { \"type\": \"integer\", \"format\": \"uint64\", \"minimum\": 0.0 }, \"extent_count\": { \"type\": \"integer\", \"format\": \"uint32\", \"minimum\": 0.0 }, \"gen\": { \"type\": \"integer\", \"format\": \"uint64\", \"minimum\": 0.0 }, \"opts\": { \"$ref\": \"#/components/schemas/CrucibleOpts\" }, \"type\": { \"type\": \"string\", \"enum\": [ \"region\" ] } } }, { \"type\": \"object\", \"required\": [ \"block_size\", \"id\", \"path\", \"type\" ], \"properties\": { \"block_size\": { \"type\": \"integer\", \"format\": \"uint64\", \"minimum\": 0.0 }, \"id\": { \"type\": \"string\", \"format\": \"uuid\" }, \"path\": { \"type\": \"string\" }, \"type\": { \"type\": \"string\", \"enum\": [ \"file\" ] } } } ] } ``` </details>",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "block_size": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "read_only_parent": {
                "nullable": true,
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VolumeConstructionRequest"
                  }
                ]
              },
              "sub_volumes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/VolumeConstructionRequest"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "volume"
                ]
              }
            },
            "required": [
              "block_size",
              "id",
              "sub_volumes",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "block_size": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "url"
                ]
              },
              "url": {
                "type": "string"
              }
            },
            "required": [
              "block_size",
              "id",
              "type",
              "url"
            ]
          },
          {
            "type": "object",
            "properties": {
              "block_size": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "blocks_per_extent": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "extent_count": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "gen": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "opts": {
                "$ref": "#/components/schemas/CrucibleOpts"
              },
              "type": {
                "type": "string",
                "enum": [
                  "region"
                ]
              }
            },
            "required": [
              "block_size",
              "blocks_per_extent",
              "extent_count",
              "gen",
              "opts",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "block_size": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "path": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "file"
                ]
              }
            },
            "required": [
              "block_size",
              "id",
              "path",
              "type"
            ]
          }
        ]
      },
      "VpcFirewallRule": {
        "description": "VPC firewall rule after object name resolution has been performed by Nexus",
        "type": "object",
        "properties": {
          "action": {
            "$ref": "#/components/schemas/VpcFirewallRuleAction"
          },
          "direction": {
            "$ref": "#/components/schemas/VpcFirewallRuleDirection"
          },
          "filter_hosts": {
            "nullable": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HostIdentifier"
            }
          },
          "filter_ports": {
            "nullable": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/L4PortRange"
            }
          },
          "filter_protocols": {
            "nullable": true,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VpcFirewallRuleProtocol"
            }
          },
          "priority": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "status": {
            "$ref": "#/components/schemas/VpcFirewallRuleStatus"
          },
          "targets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkInterface"
            }
          }
        },
        "required": [
          "action",
          "direction",
          "priority",
          "status",
          "targets"
        ]
      },
      "VpcFirewallRuleAction": {
        "type": "string",
        "enum": [
          "allow",
          "deny"
        ]
      },
      "VpcFirewallRuleDirection": {
        "type": "string",
        "enum": [
          "inbound",
          "outbound"
        ]
      },
      "VpcFirewallRuleProtocol": {
        "description": "The protocols that may be specified in a firewall rule's filter",
        "type": "string",
        "enum": [
          "TCP",
          "UDP",
          "ICMP"
        ]
      },
      "VpcFirewallRuleStatus": {
        "type": "string",
        "enum": [
          "disabled",
          "enabled"
        ]
      },
      "VpcFirewallRulesEnsureBody": {
        "description": "Update firewall rules for a VPC",
        "type": "object",
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VpcFirewallRule"
            }
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "rules",
          "vni"
        ]
      },
      "ZoneBundleCause": {
        "description": "The reason or cause for a zone bundle, i.e., why it was created.",
        "oneOf": [
          {
            "description": "Some other, unspecified reason.",
            "type": "string",
            "enum": [
              "other"
            ]
          },
          {
            "description": "A zone bundle taken when a sled agent finds a zone that it does not expect to be running.",
            "type": "string",
            "enum": [
              "unexpected_zone"
            ]
          },
          {
            "description": "An instance zone was terminated.",
            "type": "string",
            "enum": [
              "terminated_instance"
            ]
          },
          {
            "description": "Generated in response to an explicit request to the sled agent.",
            "type": "string",
            "enum": [
              "explicit_request"
            ]
          }
        ]
      },
      "ZoneBundleId": {
        "description": "An identifier for a zone bundle.",
        "type": "object",
        "properties": {
          "bundle_id": {
            "description": "The ID for this bundle itself.",
            "type": "string",
            "format": "uuid"
          },
          "zone_name": {
            "description": "The name of the zone this bundle is derived from.",
            "type": "string"
          }
        },
        "required": [
          "bundle_id",
          "zone_name"
        ]
      },
      "ZoneBundleMetadata": {
        "description": "Metadata about a zone bundle.",
        "type": "object",
        "properties": {
          "cause": {
            "description": "The reason or cause a bundle was created.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZoneBundleCause"
              }
            ]
          },
          "id": {
            "description": "Identifier for this zone bundle",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZoneBundleId"
              }
            ]
          },
          "time_created": {
            "description": "The time at which this zone bundle was created.",
            "type": "string",
            "format": "date-time"
          },
          "version": {
            "description": "A version number for this zone bundle.",
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          }
        },
        "required": [
          "cause",
          "id",
          "time_created",
          "version"
        ]
      },
      "Zpool": {
        "type": "object",
        "properties": {
          "disk_type": {
            "$ref": "#/components/schemas/DiskType"
          },
          "id": {
            "$ref": "#/components/schemas/TypedUuidForZpoolKind"
          }
        },
        "required": [
          "disk_type",
          "id"
        ]
      },
      "ZpoolName": {
        "title": "The name of a Zpool",
        "description": "Zpool names are of the format ox{i,p}_<UUID>. They are either Internal or External, and should be unique",
        "type": "string",
        "pattern": "^ox[ip]_[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
      },
      "M2Slot": {
        "description": "An M.2 slot that was written.",
        "type": "string",
        "enum": [
          "A",
          "B"
        ]
      },
      "TypedUuidForInstanceKind": {
        "type": "string",
        "format": "uuid"
      }
    },
    "responses": {
      "Error": {
        "description": "Error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      }
    }
  }
}
