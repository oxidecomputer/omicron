{
  "openapi": "3.0.3",
  "info": {
    "title": "Nexus lockstep API",
    "description": "Nexus lockstep internal API",
    "contact": {
      "url": "https://oxide.computer",
      "email": "api@oxide.computer"
    },
    "version": "0.0.1"
  },
  "paths": {
    "/bgtasks": {
      "get": {
        "summary": "List background tasks",
        "description": "This is a list of discrete background activities that Nexus carries out. This is exposed for support and debugging.",
        "operationId": "bgtask_list",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Map_of_BackgroundTask",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/BackgroundTask"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/bgtasks/activate": {
      "post": {
        "summary": "Activates one or more background tasks, causing them to be run immediately",
        "description": "if idle, or scheduled to run again as soon as possible if already running.",
        "operationId": "bgtask_activate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BackgroundTasksActivateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/bgtasks/view/{bgtask_name}": {
      "get": {
        "summary": "Fetch status of one background task",
        "description": "This is exposed for support and debugging.",
        "operationId": "bgtask_view",
        "parameters": [
          {
            "in": "path",
            "name": "bgtask_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundTask"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/clickhouse/policy": {
      "get": {
        "summary": "Get the current clickhouse policy",
        "operationId": "clickhouse_policy_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClickhousePolicy"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "post": {
        "summary": "Set the new clickhouse policy",
        "operationId": "clickhouse_policy_set",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClickhousePolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/debug/fetch-omdb-binary": {
      "get": {
        "summary": "Fetch an `omdb` binary that lives in the zone alongside this Nexus.",
        "description": "This is only useful as a support tool, and is accessible via `omdb nexus fetch-omdb ...`. During a Reconfigurator-driven upgrade, the `omdb` binary in the switch zone is updated much earlier in the process than Nexus or the database schema, meaning it is often unable to communicate with Nexus or the DB due to mismatched expectation. It can be used to fetch an _older_ `omdb` that matches the running Nexuses and DB schema via this endpoint.",
        "operationId": "fetch_omdb",
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/demo-saga": {
      "post": {
        "summary": "Kick off an instance of the \"demo\" saga",
        "description": "This saga is used for demo and testing.  The saga just waits until you complete using the `saga_demo_complete` API.",
        "operationId": "saga_demo_create",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DemoSaga"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/demo-saga/{demo_saga_id}/complete": {
      "post": {
        "summary": "Complete a waiting demo saga",
        "description": "Note that the id used here is not the same as the id of the saga.  It's the one returned by the `saga_demo_create` API.",
        "operationId": "saga_demo_complete",
        "parameters": [
          {
            "in": "path",
            "name": "demo_saga_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/DemoSagaUuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/blueprints/all": {
      "get": {
        "summary": "Lists blueprints",
        "operationId": "blueprint_list",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "description": "Maximum number of items returned by a single call",
            "schema": {
              "nullable": true,
              "type": "integer",
              "format": "uint32",
              "minimum": 1
            }
          },
          {
            "in": "query",
            "name": "page_token",
            "description": "Token returned by previous call to retrieve the subsequent page",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sort_by",
            "schema": {
              "$ref": "#/components/schemas/IdSortMode"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlueprintMetadataResultsPage"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        },
        "x-dropshot-pagination": {
          "required": []
        }
      }
    },
    "/deployment/blueprints/all/{blueprint_id}": {
      "get": {
        "summary": "Fetches one blueprint",
        "operationId": "blueprint_view",
        "parameters": [
          {
            "in": "path",
            "name": "blueprint_id",
            "description": "ID of the blueprint",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Blueprint"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Deletes one blueprint",
        "operationId": "blueprint_delete",
        "parameters": [
          {
            "in": "path",
            "name": "blueprint_id",
            "description": "ID of the blueprint",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "successful deletion"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/blueprints/import": {
      "post": {
        "summary": "Imports a client-provided blueprint",
        "description": "This is intended for development and support, not end users or operators.",
        "operationId": "blueprint_import",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Blueprint"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/blueprints/regenerate": {
      "post": {
        "summary": "Generates a new blueprint for the current system, re-evaluating anything",
        "description": "that's changed since the last one was generated",
        "operationId": "blueprint_regenerate",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Blueprint"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/blueprints/target": {
      "get": {
        "summary": "Fetches the current target blueprint, if any",
        "operationId": "blueprint_target_view",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlueprintTarget"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "post": {
        "summary": "Make the specified blueprint the new target",
        "operationId": "blueprint_target_set",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BlueprintTargetSet"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlueprintTarget"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/blueprints/target/enabled": {
      "put": {
        "summary": "Set the `enabled` field of the current target blueprint",
        "operationId": "blueprint_target_set_enabled",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BlueprintTargetSet"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BlueprintTarget"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/reconfigurator-config": {
      "get": {
        "summary": "Get the current reconfigurator configuration",
        "operationId": "reconfigurator_config_show_current",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReconfiguratorConfigView"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "post": {
        "summary": "Update the reconfigurator config at the latest versions",
        "operationId": "reconfigurator_config_set",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReconfiguratorConfigParam"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/reconfigurator-config/{version}": {
      "get": {
        "summary": "Get the reconfigurator config at `version` if it exists",
        "operationId": "reconfigurator_config_show",
        "parameters": [
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReconfiguratorConfigView"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/deployment/update-status": {
      "get": {
        "summary": "Show deployed versions of artifacts",
        "operationId": "update_status",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/experimental/v1/system/support-bundles": {
      "get": {
        "summary": "List all support bundles",
        "operationId": "support_bundle_list",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "description": "Maximum number of items returned by a single call",
            "schema": {
              "nullable": true,
              "type": "integer",
              "format": "uint32",
              "minimum": 1
            }
          },
          {
            "in": "query",
            "name": "page_token",
            "description": "Token returned by previous call to retrieve the subsequent page",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sort_by",
            "schema": {
              "$ref": "#/components/schemas/TimeAndIdSortMode"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SupportBundleInfoResultsPage"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        },
        "x-dropshot-pagination": {
          "required": []
        }
      },
      "post": {
        "summary": "Create a new support bundle",
        "operationId": "support_bundle_create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SupportBundleCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "successful creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SupportBundleInfo"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/experimental/v1/system/support-bundles/{bundle_id}": {
      "get": {
        "summary": "View a support bundle",
        "operationId": "support_bundle_view",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SupportBundleInfo"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "put": {
        "summary": "Update a support bundle",
        "operationId": "support_bundle_update",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SupportBundleUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SupportBundleInfo"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "delete": {
        "summary": "Delete an existing support bundle",
        "description": "May also be used to cancel a support bundle which is currently being collected, or to remove metadata for a support bundle that has failed.",
        "operationId": "support_bundle_delete",
        "parameters": [
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "successful deletion"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/experimental/v1/system/support-bundles/{bundle_id}/download": {
      "get": {
        "summary": "Download the contents of a support bundle",
        "operationId": "support_bundle_download",
        "parameters": [
          {
            "in": "header",
            "name": "range",
            "description": "A request to access a portion of the resource, such as `bytes=0-499`\n\nSee: <https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range>",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      },
      "head": {
        "summary": "Download the metadata of a support bundle",
        "operationId": "support_bundle_head",
        "parameters": [
          {
            "in": "header",
            "name": "range",
            "description": "A request to access a portion of the resource, such as `bytes=0-499`\n\nSee: <https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range>",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/experimental/v1/system/support-bundles/{bundle_id}/download/{file}": {
      "get": {
        "summary": "Download a file within a support bundle",
        "operationId": "support_bundle_download_file",
        "parameters": [
          {
            "in": "header",
            "name": "range",
            "description": "A request to access a portion of the resource, such as `bytes=0-499`\n\nSee: <https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range>",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "file",
            "description": "The file within the bundle to download",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      },
      "head": {
        "summary": "Download the metadata of a file within the support bundle",
        "operationId": "support_bundle_head_file",
        "parameters": [
          {
            "in": "header",
            "name": "range",
            "description": "A request to access a portion of the resource, such as `bytes=0-499`\n\nSee: <https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range>",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "file",
            "description": "The file within the bundle to download",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/experimental/v1/system/support-bundles/{bundle_id}/index": {
      "get": {
        "summary": "Download the index of a support bundle",
        "operationId": "support_bundle_index",
        "parameters": [
          {
            "in": "header",
            "name": "range",
            "description": "A request to access a portion of the resource, such as `bytes=0-499`\n\nSee: <https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Range>",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "bundle_id",
            "description": "ID of the support bundle",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "default": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/instances/{instance_id}/migrate": {
      "post": {
        "operationId": "instance_migrate",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/InstanceUuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceMigrateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Instance"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/mgs-updates": {
      "get": {
        "summary": "Fetch information about ongoing MGS updates",
        "operationId": "mgs_updates",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MgsUpdateDriverStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/oximeter/read-policy": {
      "get": {
        "summary": "Get the current oximeter read policy",
        "operationId": "oximeter_read_policy_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OximeterReadPolicy"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "post": {
        "summary": "Set the new oximeter read policy",
        "operationId": "oximeter_read_policy_set",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OximeterReadPolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/physical-disk/expunge": {
      "post": {
        "summary": "Mark a physical disk as expunged",
        "description": "This is an irreversible process! It should only be called after sufficient warning to the operator.\n\nThis is idempotent.",
        "operationId": "physical_disk_expunge",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PhysicalDiskPath"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/quiesce": {
      "get": {
        "summary": "Check whether Nexus is running normally, quiescing, or fully quiesced.",
        "operationId": "quiesce_get",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuiesceStatus"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      },
      "post": {
        "summary": "Begin quiescing this Nexus instance",
        "description": "This causes no new sagas to be started and eventually causes no database connections to become available.  This is a one-way trip.  There's no unquiescing Nexus.",
        "operationId": "quiesce_start",
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/racks/{rack_id}/initialization-complete": {
      "put": {
        "summary": "Report that the Rack Setup Service initialization is complete",
        "description": "See RFD 278 for more details.",
        "operationId": "rack_initialization_complete",
        "parameters": [
          {
            "in": "path",
            "name": "rack_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RackInitializationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sagas": {
      "get": {
        "summary": "List sagas",
        "operationId": "saga_list",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "description": "Maximum number of items returned by a single call",
            "schema": {
              "nullable": true,
              "type": "integer",
              "format": "uint32",
              "minimum": 1
            }
          },
          {
            "in": "query",
            "name": "page_token",
            "description": "Token returned by previous call to retrieve the subsequent page",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "sort_by",
            "schema": {
              "$ref": "#/components/schemas/IdSortMode"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SagaResultsPage"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        },
        "x-dropshot-pagination": {
          "required": []
        }
      }
    },
    "/sagas/{saga_id}": {
      "get": {
        "summary": "Fetch a saga",
        "operationId": "saga_view",
        "parameters": [
          {
            "in": "path",
            "name": "saga_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Saga"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sleds/add": {
      "post": {
        "summary": "Add sled to initialized rack",
        "operationId": "sled_add",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UninitializedSledId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "successful creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledId"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sleds/expunge": {
      "post": {
        "summary": "Mark a sled as expunged",
        "description": "This is an irreversible process! It should only be called after sufficient warning to the operator.\n\nThis is idempotent, and it returns the old policy of the sled.",
        "operationId": "sled_expunge",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SledSelector"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SledPolicy"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sleds/uninitialized": {
      "get": {
        "summary": "List uninitialized sleds",
        "operationId": "sled_list_uninitialized",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UninitializedSledResultsPage"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/v1/ping": {
      "get": {
        "summary": "Ping API",
        "description": "Always responds with Ok if it responds at all.",
        "operationId": "ping",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Ping"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ActivationReason": {
        "description": "Describes why a background task was activated\n\nThis is only used for debugging.  This is deliberately not made available to the background task itself.  See \"Design notes\" in the module-level documentation for details.",
        "type": "string",
        "enum": [
          "signaled",
          "timeout",
          "dependency"
        ]
      },
      "AllowedSourceIps": {
        "description": "Description of source IPs allowed to reach rack services.",
        "oneOf": [
          {
            "description": "Allow traffic from any external IP address.",
            "type": "object",
            "properties": {
              "allow": {
                "type": "string",
                "enum": [
                  "any"
                ]
              }
            },
            "required": [
              "allow"
            ]
          },
          {
            "description": "Restrict access to a specific set of source IP addresses or subnets.\n\nAll others are prevented from reaching rack services.",
            "type": "object",
            "properties": {
              "allow": {
                "type": "string",
                "enum": [
                  "list"
                ]
              },
              "ips": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IpNet"
                }
              }
            },
            "required": [
              "allow",
              "ips"
            ]
          }
        ]
      },
      "ArtifactVersion": {
        "description": "An artifact version.\n\nThis is a freeform identifier with some basic validation. It may be the serialized form of a semver version, or a custom identifier that uses the same character set as a semver, plus `_`.\n\nThe exact pattern accepted is `^[a-zA-Z0-9._+-]{1,63}$`.\n\n# Ord implementation\n\n`ArtifactVersion`s are not intended to be sorted, just compared for equality. `ArtifactVersion` implements `Ord` only for storage within sorted collections.",
        "type": "string",
        "pattern": "^[a-zA-Z0-9._+-]{1,63}$"
      },
      "BackgroundTask": {
        "description": "Background tasks\n\nThese are currently only intended for observability by developers.  We will eventually want to flesh this out into something more observable for end users.",
        "type": "object",
        "properties": {
          "current": {
            "description": "Describes the current task status",
            "allOf": [
              {
                "$ref": "#/components/schemas/CurrentStatus"
              }
            ]
          },
          "description": {
            "description": "brief summary (for developers) of what this task does",
            "type": "string"
          },
          "last": {
            "description": "Describes the last completed activation",
            "allOf": [
              {
                "$ref": "#/components/schemas/LastResult"
              }
            ]
          },
          "name": {
            "description": "unique identifier for this background task",
            "type": "string"
          },
          "period": {
            "description": "how long after an activation completes before another will be triggered automatically\n\n(activations can also be triggered for other reasons)",
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ]
          }
        },
        "required": [
          "current",
          "description",
          "last",
          "name",
          "period"
        ]
      },
      "BackgroundTasksActivateRequest": {
        "description": "Query parameters for Background Task activation requests.",
        "type": "object",
        "properties": {
          "bgtask_names": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "bgtask_names"
        ]
      },
      "Baseboard": {
        "description": "Properties that uniquely identify an Oxide hardware component",
        "type": "object",
        "properties": {
          "part": {
            "type": "string"
          },
          "revision": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "serial": {
            "type": "string"
          }
        },
        "required": [
          "part",
          "revision",
          "serial"
        ]
      },
      "BaseboardId": {
        "description": "A unique baseboard id found during a collection\n\nBaseboard ids are the keys used to link up information from disparate sources (like a service processor and a sled agent).\n\nThese are normalized in the database.  Each distinct baseboard id is assigned a uuid and shared across the many possible collections that reference it.\n\nUsually, the part number and serial number are combined with a revision number.  We do not include that here.  If we ever did find a baseboard with the same part number and serial number but a new revision number, we'd want to treat that as the same baseboard as one with a different revision number.",
        "type": "object",
        "properties": {
          "part_number": {
            "description": "Oxide Part Number",
            "type": "string"
          },
          "serial_number": {
            "description": "Serial number (unique for a given part number)",
            "type": "string"
          }
        },
        "required": [
          "part_number",
          "serial_number"
        ]
      },
      "BfdMode": {
        "description": "BFD connection mode.",
        "type": "string",
        "enum": [
          "single_hop",
          "multi_hop"
        ]
      },
      "BfdPeerConfig": {
        "type": "object",
        "properties": {
          "detection_threshold": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "local": {
            "nullable": true,
            "type": "string",
            "format": "ip"
          },
          "mode": {
            "$ref": "#/components/schemas/BfdMode"
          },
          "remote": {
            "type": "string",
            "format": "ip"
          },
          "required_rx": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "switch": {
            "$ref": "#/components/schemas/SwitchLocation"
          }
        },
        "required": [
          "detection_threshold",
          "mode",
          "remote",
          "required_rx",
          "switch"
        ]
      },
      "BgpConfig": {
        "type": "object",
        "properties": {
          "asn": {
            "description": "The autonomous system number for the BGP configuration.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "checker": {
            "nullable": true,
            "description": "Checker to apply to incoming messages.",
            "default": null,
            "type": "string"
          },
          "originate": {
            "description": "The set of prefixes for the BGP router to originate.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Ipv4Net"
            }
          },
          "shaper": {
            "nullable": true,
            "description": "Shaper to apply to outgoing messages.",
            "default": null,
            "type": "string"
          }
        },
        "required": [
          "asn",
          "originate"
        ]
      },
      "BgpPeerConfig": {
        "type": "object",
        "properties": {
          "addr": {
            "description": "Address of the peer.",
            "type": "string",
            "format": "ipv4"
          },
          "allowed_export": {
            "description": "Define export policy for a peer.",
            "default": {
              "type": "no_filtering"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportExportPolicy"
              }
            ]
          },
          "allowed_import": {
            "description": "Define import policy for a peer.",
            "default": {
              "type": "no_filtering"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ImportExportPolicy"
              }
            ]
          },
          "asn": {
            "description": "The autonomous system number of the router the peer belongs to.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "communities": {
            "description": "Include the provided communities in updates sent to the peer.",
            "default": [],
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          },
          "connect_retry": {
            "nullable": true,
            "description": "The interval in seconds between peer connection retry attempts.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "delay_open": {
            "nullable": true,
            "description": "How long to delay sending open messages to a peer. In seconds.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "enforce_first_as": {
            "description": "Enforce that the first AS in paths received from this peer is the peer's AS.",
            "default": false,
            "type": "boolean"
          },
          "hold_time": {
            "nullable": true,
            "description": "How long to keep a session alive without a keepalive in seconds. Defaults to 6.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "idle_hold_time": {
            "nullable": true,
            "description": "How long to keep a peer in idle after a state machine reset in seconds.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "keepalive": {
            "nullable": true,
            "description": "The interval to send keepalive messages at.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "local_pref": {
            "nullable": true,
            "description": "Apply a local preference to routes received from this peer.",
            "default": null,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "md5_auth_key": {
            "nullable": true,
            "description": "Use the given key for TCP-MD5 authentication with the peer.",
            "default": null,
            "type": "string"
          },
          "min_ttl": {
            "nullable": true,
            "description": "Require messages from a peer have a minimum IP time to live field.",
            "default": null,
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "multi_exit_discriminator": {
            "nullable": true,
            "description": "Apply the provided multi-exit discriminator (MED) updates sent to the peer.",
            "default": null,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "port": {
            "description": "Switch port the peer is reachable on.",
            "type": "string"
          },
          "remote_asn": {
            "nullable": true,
            "description": "Require that a peer has a specified ASN.",
            "default": null,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "vlan_id": {
            "nullable": true,
            "description": "Associate a VLAN ID with a BGP peer session.",
            "default": null,
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "addr",
          "asn",
          "port"
        ]
      },
      "BlockedMgsUpdate": {
        "type": "object",
        "properties": {
          "baseboard_id": {
            "description": "id of the baseboard that we attempted to update",
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseboardId"
              }
            ]
          },
          "reason": {
            "description": "reason why the update failed",
            "allOf": [
              {
                "$ref": "#/components/schemas/FailedMgsUpdateReason"
              }
            ]
          }
        },
        "required": [
          "baseboard_id",
          "reason"
        ]
      },
      "Blueprint": {
        "description": "Describes a complete set of software and configuration for the system",
        "type": "object",
        "properties": {
          "clickhouse_cluster_config": {
            "nullable": true,
            "description": "Allocation of Clickhouse Servers and Keepers for replicated clickhouse setups. This is set to `None` if replicated clickhouse is not in use.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ClickhouseClusterConfig"
              }
            ]
          },
          "cockroachdb_fingerprint": {
            "description": "CockroachDB state fingerprint when this blueprint was created",
            "type": "string"
          },
          "cockroachdb_setting_preserve_downgrade": {
            "description": "Whether to set `cluster.preserve_downgrade_option` and what to set it to",
            "allOf": [
              {
                "$ref": "#/components/schemas/CockroachDbPreserveDowngrade"
              }
            ]
          },
          "comment": {
            "description": "human-readable string describing why this blueprint was created (for debugging)",
            "type": "string"
          },
          "creator": {
            "description": "identity of the component that generated the blueprint (for debugging) This would generally be the Uuid of a Nexus instance.",
            "type": "string"
          },
          "external_dns_version": {
            "description": "external DNS version when this blueprint was created",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "id": {
            "description": "unique identifier for this blueprint",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "internal_dns_version": {
            "description": "internal DNS version when this blueprint was created",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "nexus_generation": {
            "description": "The generation of the active group of Nexuses\n\nIf a Nexus instance notices it has a nexus_generation less than this value, it will start to quiesce in preparation for handing off control to the newer generation (see: RFD 588).",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "oximeter_read_mode": {
            "description": "Whether oximeter should read from a single node or a cluster",
            "allOf": [
              {
                "$ref": "#/components/schemas/OximeterReadMode"
              }
            ]
          },
          "oximeter_read_version": {
            "description": "Oximeter read policy version when this blueprint was created",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "parent_blueprint_id": {
            "nullable": true,
            "description": "which blueprint this blueprint is based on",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "pending_mgs_updates": {
            "description": "List of pending MGS-mediated updates",
            "allOf": [
              {
                "$ref": "#/components/schemas/PendingMgsUpdates"
              }
            ]
          },
          "sleds": {
            "description": "A map of sled id -> desired configuration of the sled.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/BlueprintSledConfig"
            }
          },
          "source": {
            "description": "Source of this blueprint (can include planning report)",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintSource"
              }
            ]
          },
          "target_release_minimum_generation": {
            "description": "The minimum release generation to accept for target release configuration. Target release configuration with a generation less than this number will be ignored.\n\nFor example, let's say that the current target release generation is 5. Then, when reconfigurator detects a MUPdate:\n\n* the target release is ignored in favor of the install dataset * this field is set to 6\n\nOnce an operator sets a new target release, its generation will be 6 or higher. Reconfigurator will then know that it is back in charge of driving the system to the target release.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "time_created": {
            "description": "when this blueprint was generated (for debugging)",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "cockroachdb_fingerprint",
          "cockroachdb_setting_preserve_downgrade",
          "comment",
          "creator",
          "external_dns_version",
          "id",
          "internal_dns_version",
          "nexus_generation",
          "oximeter_read_mode",
          "oximeter_read_version",
          "pending_mgs_updates",
          "sleds",
          "source",
          "target_release_minimum_generation",
          "time_created"
        ]
      },
      "BlueprintArtifactVersion": {
        "description": "The version of an artifact in a blueprint.\n\nThis is used for debugging output.",
        "oneOf": [
          {
            "description": "A specific version of the image is available.",
            "type": "object",
            "properties": {
              "artifact_version": {
                "type": "string",
                "enum": [
                  "available"
                ]
              },
              "version": {
                "$ref": "#/components/schemas/ArtifactVersion"
              }
            },
            "required": [
              "artifact_version",
              "version"
            ]
          },
          {
            "description": "The version could not be determined. This is non-fatal.",
            "type": "object",
            "properties": {
              "artifact_version": {
                "type": "string",
                "enum": [
                  "unknown"
                ]
              }
            },
            "required": [
              "artifact_version"
            ]
          }
        ]
      },
      "BlueprintDatasetConfig": {
        "description": "Information about a dataset as recorded in a blueprint",
        "type": "object",
        "properties": {
          "address": {
            "nullable": true,
            "type": "string"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionAlgorithm"
          },
          "disposition": {
            "$ref": "#/components/schemas/BlueprintDatasetDisposition"
          },
          "id": {
            "$ref": "#/components/schemas/DatasetUuid"
          },
          "kind": {
            "$ref": "#/components/schemas/DatasetKind"
          },
          "pool": {
            "$ref": "#/components/schemas/ZpoolName"
          },
          "quota": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "reservation": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          }
        },
        "required": [
          "compression",
          "disposition",
          "id",
          "kind",
          "pool"
        ]
      },
      "BlueprintDatasetDisposition": {
        "description": "The desired state of an Omicron-managed dataset in a blueprint.\n\nPart of [`BlueprintDatasetConfig`].",
        "oneOf": [
          {
            "description": "The dataset is in-service.",
            "type": "string",
            "enum": [
              "in_service"
            ]
          },
          {
            "description": "The dataset is permanently gone.",
            "type": "string",
            "enum": [
              "expunged"
            ]
          }
        ]
      },
      "BlueprintHostPhase2DesiredContents": {
        "description": "Describes the desired contents of a host phase 2 slot (i.e., the boot partition on one of the internal M.2 drives).\n\nThis is the blueprint version of [`HostPhase2DesiredContents`].",
        "oneOf": [
          {
            "description": "Do not change the current contents.\n\nWe use this value when we've detected a sled has been mupdated (and we don't want to overwrite phase 2 images until we understand how to recover from that mupdate) and as the default value when reading a blueprint that was ledgered before this concept existed.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "current_contents"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Set the phase 2 slot to the given artifact.\n\nThe artifact will come from an unpacked and distributed TUF repo.",
            "type": "object",
            "properties": {
              "hash": {
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "type": {
                "type": "string",
                "enum": [
                  "artifact"
                ]
              },
              "version": {
                "$ref": "#/components/schemas/BlueprintArtifactVersion"
              }
            },
            "required": [
              "hash",
              "type",
              "version"
            ]
          }
        ]
      },
      "BlueprintHostPhase2DesiredSlots": {
        "description": "Describes the desired contents for both host phase 2 slots.\n\nThis is the blueprint version of [`HostPhase2DesiredSlots`].",
        "type": "object",
        "properties": {
          "slot_a": {
            "$ref": "#/components/schemas/BlueprintHostPhase2DesiredContents"
          },
          "slot_b": {
            "$ref": "#/components/schemas/BlueprintHostPhase2DesiredContents"
          }
        },
        "required": [
          "slot_a",
          "slot_b"
        ]
      },
      "BlueprintMetadata": {
        "description": "Describe high-level metadata about a blueprint",
        "type": "object",
        "properties": {
          "cockroachdb_fingerprint": {
            "description": "CockroachDB state fingerprint when this blueprint was created",
            "type": "string"
          },
          "cockroachdb_setting_preserve_downgrade": {
            "nullable": true,
            "description": "Whether to set `cluster.preserve_downgrade_option` and what to set it to (`None` if this value was retrieved from the database and was invalid)",
            "allOf": [
              {
                "$ref": "#/components/schemas/CockroachDbPreserveDowngrade"
              }
            ]
          },
          "comment": {
            "description": "human-readable string describing why this blueprint was created (for debugging)",
            "type": "string"
          },
          "creator": {
            "description": "identity of the component that generated the blueprint (for debugging) This would generally be the Uuid of a Nexus instance.",
            "type": "string"
          },
          "external_dns_version": {
            "description": "external DNS version when this blueprint was created",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "id": {
            "description": "unique identifier for this blueprint",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "internal_dns_version": {
            "description": "internal DNS version when this blueprint was created",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "nexus_generation": {
            "description": "The Nexus generation number\n\nSee [`Blueprint::nexus_generation`].",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "parent_blueprint_id": {
            "nullable": true,
            "description": "which blueprint this blueprint is based on",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "source": {
            "description": "source of the blueprint (for debugging)",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintSource"
              }
            ]
          },
          "target_release_minimum_generation": {
            "description": "The minimum generation for the target release.\n\nSee [`Blueprint::target_release_minimum_generation`].",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "time_created": {
            "description": "when this blueprint was generated (for debugging)",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "cockroachdb_fingerprint",
          "comment",
          "creator",
          "external_dns_version",
          "id",
          "internal_dns_version",
          "nexus_generation",
          "source",
          "target_release_minimum_generation",
          "time_created"
        ]
      },
      "BlueprintMetadataResultsPage": {
        "description": "A single page of results",
        "type": "object",
        "properties": {
          "items": {
            "description": "list of items on this page of results",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlueprintMetadata"
            }
          },
          "next_page": {
            "nullable": true,
            "description": "token used to fetch the next page of results (if any)",
            "type": "string"
          }
        },
        "required": [
          "items"
        ]
      },
      "BlueprintPhysicalDiskConfig": {
        "description": "Information about an Omicron physical disk as recorded in a bluerprint.",
        "type": "object",
        "properties": {
          "disposition": {
            "$ref": "#/components/schemas/BlueprintPhysicalDiskDisposition"
          },
          "id": {
            "$ref": "#/components/schemas/PhysicalDiskUuid"
          },
          "identity": {
            "$ref": "#/components/schemas/DiskIdentity"
          },
          "pool_id": {
            "$ref": "#/components/schemas/ZpoolUuid"
          }
        },
        "required": [
          "disposition",
          "id",
          "identity",
          "pool_id"
        ]
      },
      "BlueprintPhysicalDiskDisposition": {
        "description": "The desired state of an Omicron-managed physical disk in a blueprint.",
        "oneOf": [
          {
            "description": "The physical disk is in-service.",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "in_service"
                ]
              }
            },
            "required": [
              "kind"
            ]
          },
          {
            "description": "The physical disk is permanently gone.",
            "type": "object",
            "properties": {
              "as_of_generation": {
                "description": "Generation of the parent config in which this disk became expunged.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Generation"
                  }
                ]
              },
              "kind": {
                "type": "string",
                "enum": [
                  "expunged"
                ]
              },
              "ready_for_cleanup": {
                "description": "True if Reconfiguration knows that this disk has been expunged.\n\nIn the current implementation, this means either:\n\na) the sled where the disk was residing has been expunged.\n\nb) the planner has observed an inventory collection where the disk expungement was seen by the sled agent on the sled where the disk was previously in service. This is indicated by the inventory reporting a disk generation at least as high as `as_of_generation`.",
                "type": "boolean"
              }
            },
            "required": [
              "as_of_generation",
              "kind",
              "ready_for_cleanup"
            ]
          }
        ]
      },
      "BlueprintSledConfig": {
        "description": "Information about the configuration of a sled as recorded in a blueprint.\n\nPart of [`Blueprint`].",
        "type": "object",
        "properties": {
          "datasets": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/BlueprintDatasetConfig"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlueprintDatasetConfig"
            },
            "uniqueItems": true
          },
          "disks": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/BlueprintPhysicalDiskConfig"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlueprintPhysicalDiskConfig"
            },
            "uniqueItems": true
          },
          "host_phase_2": {
            "$ref": "#/components/schemas/BlueprintHostPhase2DesiredSlots"
          },
          "remove_mupdate_override": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/MupdateOverrideUuid"
              }
            ]
          },
          "sled_agent_generation": {
            "description": "Generation number used when this type is converted into an `OmicronSledConfig` for use by sled-agent.\n\nThis field is explicitly named `sled_agent_generation` to indicate that it is only required to cover information that changes what Reconfigurator sends to sled agent. For example, changing the sled `state` from `Active` to `Decommissioned` would not require a bump to `sled_agent_generation`, because a `Decommissioned` sled will never be sent an `OmicronSledConfig`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "state": {
            "$ref": "#/components/schemas/SledState"
          },
          "zones": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/BlueprintZoneConfig"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlueprintZoneConfig"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "datasets",
          "disks",
          "host_phase_2",
          "sled_agent_generation",
          "state",
          "zones"
        ]
      },
      "BlueprintSource": {
        "description": "Description of the source of a blueprint.",
        "oneOf": [
          {
            "description": "The initial blueprint created by the rack setup service.",
            "type": "object",
            "properties": {
              "source": {
                "type": "string",
                "enum": [
                  "rss"
                ]
              }
            },
            "required": [
              "source"
            ]
          },
          {
            "description": "A blueprint created by the planner, and we still have the associated planning report.",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/PlanningAddStepReport"
              },
              "cockroachdb_settings": {
                "$ref": "#/components/schemas/PlanningCockroachdbSettingsStepReport"
              },
              "decommission": {
                "$ref": "#/components/schemas/PlanningDecommissionStepReport"
              },
              "expunge": {
                "$ref": "#/components/schemas/PlanningExpungeStepReport"
              },
              "mgs_updates": {
                "$ref": "#/components/schemas/PlanningMgsUpdatesStepReport"
              },
              "nexus_generation_bump": {
                "$ref": "#/components/schemas/PlanningNexusGenerationBumpReport"
              },
              "noop_image_source": {
                "$ref": "#/components/schemas/PlanningNoopImageSourceStepReport"
              },
              "planner_config": {
                "description": "The configuration in effect for this planning run.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PlannerConfig"
                  }
                ]
              },
              "source": {
                "type": "string",
                "enum": [
                  "planner"
                ]
              },
              "zone_updates": {
                "$ref": "#/components/schemas/PlanningZoneUpdatesStepReport"
              }
            },
            "required": [
              "add",
              "cockroachdb_settings",
              "decommission",
              "expunge",
              "mgs_updates",
              "nexus_generation_bump",
              "noop_image_source",
              "planner_config",
              "source",
              "zone_updates"
            ]
          },
          {
            "description": "A blueprint created by the planner but loaded from the database, so we no longer have the associated planning report.",
            "type": "object",
            "properties": {
              "source": {
                "type": "string",
                "enum": [
                  "planner_loaded_from_database"
                ]
              }
            },
            "required": [
              "source"
            ]
          },
          {
            "description": "This blueprint was created by one of `reconfigurator-cli`'s blueprint editing subcommands.",
            "type": "object",
            "properties": {
              "source": {
                "type": "string",
                "enum": [
                  "reconfigurator_cli_edit"
                ]
              }
            },
            "required": [
              "source"
            ]
          },
          {
            "description": "This blueprint was constructed by hand by an automated test.",
            "type": "object",
            "properties": {
              "source": {
                "type": "string",
                "enum": [
                  "test"
                ]
              }
            },
            "required": [
              "source"
            ]
          }
        ]
      },
      "BlueprintTarget": {
        "description": "Describes what blueprint, if any, the system is currently working toward",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "policy: should the system actively work towards this blueprint\n\nThis should generally be left enabled.",
            "type": "boolean"
          },
          "target_id": {
            "description": "id of the blueprint that the system is trying to make real",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "time_made_target": {
            "description": "when this blueprint was made the target",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "enabled",
          "target_id",
          "time_made_target"
        ]
      },
      "BlueprintTargetSet": {
        "description": "Specifies what blueprint, if any, the system should be working toward",
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "target_id": {
            "$ref": "#/components/schemas/BlueprintUuid"
          }
        },
        "required": [
          "enabled",
          "target_id"
        ]
      },
      "BlueprintUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::BlueprintUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "BlueprintZoneConfig": {
        "description": "Describes one Omicron-managed zone in a blueprint.\n\nPart of [`BlueprintSledConfig`].",
        "type": "object",
        "properties": {
          "disposition": {
            "description": "The disposition (desired state) of this zone recorded in the blueprint.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintZoneDisposition"
              }
            ]
          },
          "filesystem_pool": {
            "description": "zpool used for the zone's (transient) root filesystem",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZpoolName"
              }
            ]
          },
          "id": {
            "$ref": "#/components/schemas/OmicronZoneUuid"
          },
          "image_source": {
            "$ref": "#/components/schemas/BlueprintZoneImageSource"
          },
          "zone_type": {
            "$ref": "#/components/schemas/BlueprintZoneType"
          }
        },
        "required": [
          "disposition",
          "filesystem_pool",
          "id",
          "image_source",
          "zone_type"
        ]
      },
      "BlueprintZoneDisposition": {
        "description": "The desired state of an Omicron-managed zone in a blueprint.\n\nPart of [`BlueprintZoneConfig`].",
        "oneOf": [
          {
            "description": "The zone is in-service.",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "in_service"
                ]
              }
            },
            "required": [
              "kind"
            ]
          },
          {
            "description": "The zone is permanently gone.",
            "type": "object",
            "properties": {
              "as_of_generation": {
                "description": "Generation of the parent config in which this zone became expunged.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Generation"
                  }
                ]
              },
              "kind": {
                "type": "string",
                "enum": [
                  "expunged"
                ]
              },
              "ready_for_cleanup": {
                "description": "True if Reconfiguration knows that this zone has been shut down and will not be restarted.\n\nIn the current implementation, this means the planner has observed an inventory collection where the sled on which this zone was running (a) is no longer running the zone and (b) has a config generation at least as high as `as_of_generation`, indicating it will not try to start the zone on a cold boot based on an older config.",
                "type": "boolean"
              }
            },
            "required": [
              "as_of_generation",
              "kind",
              "ready_for_cleanup"
            ]
          }
        ]
      },
      "BlueprintZoneImageSource": {
        "description": "Where the zone's image source is located.\n\nThis is the blueprint version of [`OmicronZoneImageSource`].",
        "oneOf": [
          {
            "description": "This zone's image source is whatever happens to be on the sled's \"install\" dataset.\n\nThis is whatever was put in place at the factory or by the latest MUPdate. The image used here can vary by sled and even over time (if the sled gets MUPdated again).\n\nHistorically, this was the only source for zone images. In an system with automated control-plane-driven update we expect to only use this variant in emergencies where the system had to be recovered via MUPdate.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "install_dataset"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "This zone's image source is the artifact matching this hash from the TUF artifact store (aka \"TUF repo depot\").\n\nThis originates from TUF repos uploaded to Nexus which are then replicated out to all sleds.",
            "type": "object",
            "properties": {
              "hash": {
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "type": {
                "type": "string",
                "enum": [
                  "artifact"
                ]
              },
              "version": {
                "$ref": "#/components/schemas/BlueprintArtifactVersion"
              }
            },
            "required": [
              "hash",
              "type",
              "version"
            ]
          }
        ]
      },
      "BlueprintZoneType": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dns_servers": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "domain": {
                "nullable": true,
                "type": "string"
              },
              "external_ip": {
                "$ref": "#/components/schemas/OmicronZoneExternalSnatIp"
              },
              "nic": {
                "description": "The service vNIC providing outbound connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "ntp_servers": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "boundary_ntp"
                ]
              }
            },
            "required": [
              "address",
              "dns_servers",
              "external_ip",
              "nic",
              "ntp_servers",
              "type"
            ]
          },
          {
            "description": "Used in single-node clickhouse setups",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_keeper"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "description": "Used in replicated clickhouse setups",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_server"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cockroach_db"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible_pantry"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "description": "The address at which the external DNS server is reachable.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OmicronZoneExternalFloatingAddr"
                  }
                ]
              },
              "http_address": {
                "description": "The address at which the external DNS server API is reachable.",
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "external_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "http_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "type": "string"
              },
              "gz_address": {
                "description": "The addresses in the global zone which should be created\n\nFor the DNS service, which exists outside the sleds's typical subnet - adding an address in the GZ is necessary to allow inter-zone traffic routing.",
                "type": "string",
                "format": "ipv6"
              },
              "gz_address_index": {
                "description": "The address is also identified with an auxiliary bit of information to ensure that the created global zone address can have a unique name.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "http_address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "gz_address",
              "gz_address_index",
              "http_address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_ntp"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "external_dns_servers": {
                "description": "External DNS servers Nexus can use to resolve external hosts.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "external_ip": {
                "description": "The address at which the external nexus server is reachable.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/OmicronZoneExternalFloatingIp"
                  }
                ]
              },
              "external_tls": {
                "description": "Whether Nexus's external endpoint should use TLS",
                "type": "boolean"
              },
              "internal_address": {
                "description": "The address at which the internal nexus server is reachable.",
                "type": "string"
              },
              "lockstep_port": {
                "description": "The port at which the lockstep server is reachable. This shares the same IP address with `internal_address`.",
                "type": "integer",
                "format": "uint16",
                "minimum": 0
              },
              "nexus_generation": {
                "description": "Generation number for this Nexus zone. This is used to coordinate handoff between old and new Nexus instances during updates. See RFD 588.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Generation"
                  }
                ]
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "nexus"
                ]
              }
            },
            "required": [
              "external_dns_servers",
              "external_ip",
              "external_tls",
              "internal_address",
              "lockstep_port",
              "nexus_generation",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "oximeter"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          }
        ]
      },
      "ByteCount": {
        "description": "Byte count to express memory or storage capacity.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "CabooseWhich": {
        "description": "Describes which caboose this is (which component, which slot)",
        "type": "string",
        "enum": [
          "sp_slot0",
          "sp_slot1",
          "rot_slot_a",
          "rot_slot_b",
          "stage0",
          "stage0_next"
        ]
      },
      "Certificate": {
        "type": "object",
        "properties": {
          "cert": {
            "type": "string"
          },
          "key": {
            "type": "string"
          }
        },
        "required": [
          "cert",
          "key"
        ]
      },
      "ClickhouseClusterConfig": {
        "description": "Global configuration for all clickhouse servers (replicas) and keepers",
        "type": "object",
        "properties": {
          "cluster_name": {
            "description": "An arbitrary name for the Clickhouse cluster shared by all nodes",
            "type": "string"
          },
          "cluster_secret": {
            "description": "An arbitrary string shared by all nodes used at runtime to determine whether nodes are part of the same cluster.",
            "type": "string"
          },
          "generation": {
            "description": "The last update to the clickhouse cluster configuration\n\nThis is used by `clickhouse-admin` in the clickhouse server and keeper zones to discard old configurations.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "highest_seen_keeper_leader_committed_log_index": {
            "description": "This is used as a marker to tell if the raft configuration in a new inventory collection is newer than the last collection. This serves as a surrogate for the log index of the last committed configuration, which clickhouse keeper doesn't expose.\n\nThis is necesssary because during inventory collection we poll multiple keeper nodes, and each returns their local knowledge of the configuration. But we may reach different nodes in different attempts, and some nodes in a following attempt may reflect stale configuration. Due to timing, we can always query old information. That is just normal polling. However, we never want to use old configuration if we have already seen and acted on newer configuration.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "keepers": {
            "description": "The desired state of the clickhouse keeper cluster\n\nWe decouple deployment of zones that should contain clickhouse keeper processes from actually starting or stopping those processes, adding or removing them to/from the keeper cluster, and reconfiguring other keeper and clickhouse server nodes to reflect the new configuration.\n\nAs part of this decoupling, we keep track of the intended zone deployment in the blueprint, but that is not enough to track the desired state of the keeper cluster. We are only allowed to add or remove one keeper node at a time, and therefore we must track the desired state of the keeper cluster which may change multiple times until the keepers in the cluster match the deployed zones. An example may help:\n\n1. We start with 3 keeper nodes in 3 deployed keeper zones and need to add two to reach our desired policy of 5 keepers 2. The planner adds 2 new keeper zones to the blueprint 3. The planner will also add **one** new keeper to the `keepers` field below that matches one of the deployed zones. 4. The executor will start the new keeper process that was added to the `keepers` field, attempt to add it to the keeper cluster by pushing configuration updates to the other keepers, and then updating the clickhouse server configurations to know about the new keeper. 5. If the keeper is successfully added, as reflected in inventory, then steps 3 and 4 above will be repeated for the next keeper process. 6. If the keeper is not successfully added by the executor it will continue to retry indefinitely. 7. If the zone is expunged while the planner has it as part of its desired state in `keepers`, and the executor is trying to add it, the keeper will be removed from `keepers` in the next blueprint. If it has been added to the actual cluster by an executor in the meantime it will be removed on the next iteration of an executor.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/KeeperId"
            }
          },
          "max_used_keeper_id": {
            "description": "Clickhouse Keeper IDs must be unique and are handed out monotonically. Keep track of the last used one.",
            "allOf": [
              {
                "$ref": "#/components/schemas/KeeperId"
              }
            ]
          },
          "max_used_server_id": {
            "description": "Clickhouse Server IDs must be unique and are handed out monotonically. Keep track of the last used one.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ServerId"
              }
            ]
          },
          "servers": {
            "description": "The desired state of clickhouse server processes on the rack\n\nClickhouse servers do not have the same limitations as keepers and can be deployed all at once.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ServerId"
            }
          }
        },
        "required": [
          "cluster_name",
          "cluster_secret",
          "generation",
          "highest_seen_keeper_leader_committed_log_index",
          "keepers",
          "max_used_keeper_id",
          "max_used_server_id",
          "servers"
        ]
      },
      "ClickhouseMode": {
        "description": "How to deploy clickhouse nodes",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "single_node_only"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "cluster_only"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "target_keepers": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0
                  },
                  "target_servers": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0
                  }
                },
                "required": [
                  "target_keepers",
                  "target_servers"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "both"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "target_keepers": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0
                  },
                  "target_servers": {
                    "type": "integer",
                    "format": "uint8",
                    "minimum": 0
                  }
                },
                "required": [
                  "target_keepers",
                  "target_servers"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "ClickhousePolicy": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/ClickhouseMode"
          },
          "time_created": {
            "type": "string",
            "format": "date-time"
          },
          "version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "mode",
          "time_created",
          "version"
        ]
      },
      "CockroachDbClusterVersion": {
        "description": "CockroachDB cluster versions we are aware of.\n\nCockroachDB can be upgraded from one major version to the next, e.g. v22.1 -> v22.2. Each major version introduces changes in how it stores data on disk to support new features, and each major version has support for reading the previous version's data so that it can perform an upgrade. The version of the data format is called the \"cluster version\", which is distinct from but related to the software version that's being run.\n\nWhile software version v22.2 is using cluster version v22.1, it's possible to downgrade back to v22.1. Once the cluster version is upgraded, there's no going back.\n\nTo give us some time to evaluate new versions of the software while retaining a downgrade path, we currently deploy new versions of CockroachDB across two releases of the Oxide software, in a \"tick-tock\" model:\n\n- In \"tick\" releases, we upgrade the version of the CockroachDB software to a new major version, and update `CockroachDbClusterVersion::NEWLY_INITIALIZED`. On upgraded racks, the new version is running with the previous cluster version; on newly-initialized racks, the new version is running with the new cluser version. - In \"tock\" releases, we change `CockroachDbClusterVersion::POLICY` to the major version we upgraded to in the last \"tick\" release. This results in a new blueprint that upgrades the cluster version, destroying the downgrade path but allowing us to eventually upgrade to the next release.\n\nThese presently describe major versions of CockroachDB. The order of these must be maintained in the correct order (the first variant must be the earliest version).",
        "type": "string",
        "enum": [
          "V22_1"
        ]
      },
      "CockroachDbPreserveDowngrade": {
        "description": "Whether to set `cluster.preserve_downgrade_option` and what to set it to.",
        "oneOf": [
          {
            "description": "Do not modify the setting.",
            "type": "object",
            "properties": {
              "action": {
                "type": "string",
                "enum": [
                  "do_not_modify"
                ]
              }
            },
            "required": [
              "action"
            ]
          },
          {
            "description": "Ensure the setting is set to an empty string.",
            "type": "object",
            "properties": {
              "action": {
                "type": "string",
                "enum": [
                  "allow_upgrade"
                ]
              }
            },
            "required": [
              "action"
            ]
          },
          {
            "description": "Ensure the setting is set to a given cluster version.",
            "type": "object",
            "properties": {
              "action": {
                "type": "string",
                "enum": [
                  "set"
                ]
              },
              "data": {
                "$ref": "#/components/schemas/CockroachDbClusterVersion"
              }
            },
            "required": [
              "action",
              "data"
            ]
          }
        ]
      },
      "CockroachdbUnsafeToShutdown": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "missing_live_nodes_stat"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "missing_underreplicated_stat"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "live_nodes": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "not_enough_live_nodes"
                ]
              }
            },
            "required": [
              "live_nodes",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "not_enough_nodes"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "n": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "underreplicated_ranges"
                ]
              }
            },
            "required": [
              "n",
              "type"
            ]
          }
        ]
      },
      "CompletedAttempt": {
        "description": "externally-exposed status for a completed attempt",
        "type": "object",
        "properties": {
          "elapsed": {
            "$ref": "#/components/schemas/Duration"
          },
          "nattempts_done": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "request": {
            "$ref": "#/components/schemas/PendingMgsUpdate"
          },
          "result": {
            "x-rust-type": {
              "crate": "std",
              "parameters": [
                {
                  "$ref": "#/components/schemas/UpdateCompletedHow"
                },
                {
                  "type": "string"
                }
              ],
              "path": "::std::result::Result",
              "version": "*"
            },
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "ok": {
                    "$ref": "#/components/schemas/UpdateCompletedHow"
                  }
                },
                "required": [
                  "ok"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "err": {
                    "type": "string"
                  }
                },
                "required": [
                  "err"
                ]
              }
            ]
          },
          "time_done": {
            "type": "string",
            "format": "date-time"
          },
          "time_started": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "elapsed",
          "nattempts_done",
          "request",
          "result",
          "time_done",
          "time_started"
        ]
      },
      "CompressionAlgorithm": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "on"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "off"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "gzip"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "level": {
                "$ref": "#/components/schemas/GzipLevel"
              },
              "type": {
                "type": "string",
                "enum": [
                  "gzip_n"
                ]
              }
            },
            "required": [
              "level",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lz4"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lzjb"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "zle"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "CrucibleDatasetCreateRequest": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "dataset_id": {
            "$ref": "#/components/schemas/DatasetUuid"
          },
          "zpool_id": {
            "$ref": "#/components/schemas/ZpoolUuid"
          }
        },
        "required": [
          "address",
          "dataset_id",
          "zpool_id"
        ]
      },
      "CurrentStatus": {
        "description": "Describes the current status of a background task",
        "oneOf": [
          {
            "description": "The background task is not running\n\nTypically, the task would be waiting for its next activation, which would happen after a timeout or some other event that triggers activation",
            "type": "object",
            "properties": {
              "current_status": {
                "type": "string",
                "enum": [
                  "idle"
                ]
              }
            },
            "required": [
              "current_status"
            ]
          },
          {
            "description": "The background task is currently running\n\nMore precisely, the task has been activated and has not yet finished this activation",
            "type": "object",
            "properties": {
              "current_status": {
                "type": "string",
                "enum": [
                  "running"
                ]
              },
              "details": {
                "$ref": "#/components/schemas/CurrentStatusRunning"
              }
            },
            "required": [
              "current_status",
              "details"
            ]
          }
        ]
      },
      "CurrentStatusRunning": {
        "type": "object",
        "properties": {
          "iteration": {
            "description": "which iteration this was (counter)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "reason": {
            "description": "what kind of event triggered this activation",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivationReason"
              }
            ]
          },
          "start_time": {
            "description": "wall-clock time when the current activation started",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "iteration",
          "reason",
          "start_time"
        ]
      },
      "DatasetKind": {
        "description": "The kind of dataset. See the `DatasetKind` enum in omicron-common for possible values.",
        "type": "string"
      },
      "DatasetUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::DatasetUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "DemoSaga": {
        "description": "Identifies an instance of the demo saga",
        "type": "object",
        "properties": {
          "demo_saga_id": {
            "$ref": "#/components/schemas/DemoSagaUuid"
          },
          "saga_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "demo_saga_id",
          "saga_id"
        ]
      },
      "DemoSagaUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::DemoSagaUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "DiscretionaryZonePlacement": {
        "type": "object",
        "properties": {
          "kind": {
            "type": "string"
          },
          "source": {
            "type": "string"
          }
        },
        "required": [
          "kind",
          "source"
        ]
      },
      "DiskIdentity": {
        "description": "Uniquely identifies a disk.",
        "type": "object",
        "properties": {
          "model": {
            "type": "string"
          },
          "serial": {
            "type": "string"
          },
          "vendor": {
            "type": "string"
          }
        },
        "required": [
          "model",
          "serial",
          "vendor"
        ]
      },
      "DnsConfigParams": {
        "type": "object",
        "properties": {
          "generation": {
            "$ref": "#/components/schemas/Generation"
          },
          "serial": {
            "description": "See [`DnsConfig`]'s `serial` field for how this is different from `generation`",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "time_created": {
            "type": "string",
            "format": "date-time"
          },
          "zones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DnsConfigZone"
            }
          }
        },
        "required": [
          "generation",
          "serial",
          "time_created",
          "zones"
        ]
      },
      "DnsConfigZone": {
        "description": "Configuration for a specific DNS zone, as opposed to illumos zones in which the services described by these records run.\n\nThe name `@` is special: it describes records that should be provided for queries about `zone_name`. This is used in favor of the empty string as `@` is the name used for this purpose in zone files for most DNS configurations. It also avoids potentially-confusing debug output from naively printing out records and their names - if you've seen an `@` record and tools are unclear about what that means, hopefully you've arrived here!",
        "type": "object",
        "properties": {
          "records": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/DnsRecord"
              }
            }
          },
          "zone_name": {
            "type": "string"
          }
        },
        "required": [
          "records",
          "zone_name"
        ]
      },
      "DnsRecord": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "data": {
                "type": "string",
                "format": "ipv4"
              },
              "type": {
                "type": "string",
                "enum": [
                  "A"
                ]
              }
            },
            "required": [
              "data",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "data": {
                "type": "string",
                "format": "ipv6"
              },
              "type": {
                "type": "string",
                "enum": [
                  "AAAA"
                ]
              }
            },
            "required": [
              "data",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "data": {
                "$ref": "#/components/schemas/Srv"
              },
              "type": {
                "type": "string",
                "enum": [
                  "SRV"
                ]
              }
            },
            "required": [
              "data",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "data": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "NS"
                ]
              }
            },
            "required": [
              "data",
              "type"
            ]
          }
        ]
      },
      "Duration": {
        "type": "object",
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "nanos",
          "secs"
        ]
      },
      "Error": {
        "description": "Error information from a response.",
        "type": "object",
        "properties": {
          "error_code": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "request_id"
        ]
      },
      "ExpectedActiveRotSlot": {
        "description": "Describes the expected active RoT slot, and the version we expect to find for it",
        "type": "object",
        "properties": {
          "slot": {
            "$ref": "#/components/schemas/RotSlot"
          },
          "version": {
            "$ref": "#/components/schemas/ArtifactVersion"
          }
        },
        "required": [
          "slot",
          "version"
        ]
      },
      "ExpectedVersion": {
        "description": "Describes the version that we expect to find in some firmware slot",
        "oneOf": [
          {
            "description": "We expect to find _no_ valid caboose in this slot",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "no_valid_version"
                ]
              }
            },
            "required": [
              "kind"
            ]
          },
          {
            "description": "We expect to find the specified version in this slot",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "version"
                ]
              },
              "version": {
                "$ref": "#/components/schemas/ArtifactVersion"
              }
            },
            "required": [
              "kind",
              "version"
            ]
          }
        ]
      },
      "ExternalIpUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::ExternalIpUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "ExternalPortDiscovery": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "auto": {
                "type": "object",
                "additionalProperties": {
                  "type": "string",
                  "format": "ipv6"
                }
              }
            },
            "required": [
              "auto"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "static": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Name"
                  }
                }
              }
            },
            "required": [
              "static"
            ],
            "additionalProperties": false
          }
        ]
      },
      "FailedHostOsUpdateReason": {
        "description": "Describes the reason why a Host OS failed to update",
        "oneOf": [
          {
            "description": "The active host phase 1 slot does not match the boot disk",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "active_host_phase1_slot_boot_disk_mismatch"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/M2Slot"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The active host phase 1 hash was not found in inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "active_host_phase1_hash_not_in_inventory"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/M2Slot"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The active host phase 1 slot was not found in inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "active_host_phase1_slot_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The component's caboose was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "caboose_not_in_inventory"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/CabooseWhich"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The version in the caboose or artifact was not able to be parsed",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "failed_version_parse"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "caboose": {
                    "$ref": "#/components/schemas/CabooseWhich"
                  },
                  "err": {
                    "type": "string"
                  }
                },
                "required": [
                  "caboose",
                  "err"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The inactive host phase 1 hash was not found in inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "inactive_host_phase1_hash_not_in_inventory"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/M2Slot"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "Last reconciliation details were not found in inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "last_reconciliation_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "No artifacts with the required conditions for the component were found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_matching_artifacts_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "No artifact with the required conditions for phase 1 was found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_matching_phase1_artifact_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "No artifact with the required conditions for phase 2 was found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_matching_phase2_artifact_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Sled agent info was not found in inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sled_agent_info_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The component's corresponding SP was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sp_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Too many artifacts with the required conditions for the component were found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "too_many_matching_artifacts"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The sled agent reported an error determining the boot disk",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unable_to_determine_boot_disk"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The sled agent reported an error retrieving boot disk phase 2 image details",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unable_to_retrieve_boot_disk_phase2_image"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The component's corresponding sled contains zones that are unsafe to shut down",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unsafe_zone_found"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "FailedMgsUpdateReason": {
        "description": "Describes the reason why an SP component failed to update",
        "oneOf": [
          {
            "description": "There was a failed attempt to plan a Host OS update",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "host_os"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/FailedHostOsUpdateReason"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "There was a failed attempt to plan an RoT update",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "rot"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/FailedRotUpdateReason"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "There was a failed attempt to plan an RoT bootloader update",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "rot_bootloader"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/FailedRotBootloaderUpdateReason"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "There was a failed attempt to plan an SP update",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sp"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/FailedSpUpdateReason"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "FailedRotBootloaderUpdateReason": {
        "description": "Describes the reason why an RoT bootloader failed to update",
        "oneOf": [
          {
            "description": "The component's caboose was missing a value for \"sign\"",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "caboose_missing_sign"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/CabooseWhich"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The component's caboose was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "caboose_not_in_inventory"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/CabooseWhich"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The version in the caboose or artifact was not able to be parsed",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "failed_version_parse"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "caboose": {
                    "$ref": "#/components/schemas/CabooseWhich"
                  },
                  "err": {
                    "type": "string"
                  }
                },
                "required": [
                  "caboose",
                  "err"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "No artifact with the required conditions for the component was found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_matching_artifact_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The component's corresponding SP was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sp_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "FailedRotUpdateReason": {
        "description": "Describes the reason why an RoT failed to update",
        "oneOf": [
          {
            "description": "The component's caboose was missing a value for \"sign\"",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "caboose_missing_sign"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/CabooseWhich"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The component's caboose was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "caboose_not_in_inventory"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/CabooseWhich"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The version in the caboose or artifact was not able to be parsed",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "failed_version_parse"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "caboose": {
                    "$ref": "#/components/schemas/CabooseWhich"
                  },
                  "err": {
                    "type": "string"
                  }
                },
                "required": [
                  "caboose",
                  "err"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "No artifact with the required conditions for the component was found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_matching_artifact_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "RoT state was not found in inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "rot_state_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The component's corresponding SP was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sp_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "FailedSpUpdateReason": {
        "description": "Describes the reason why an SP failed to update",
        "oneOf": [
          {
            "description": "The component's caboose was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "caboose_not_in_inventory"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/CabooseWhich"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "The version in the caboose or artifact was not able to be parsed",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "failed_version_parse"
                ]
              },
              "value": {
                "type": "object",
                "properties": {
                  "caboose": {
                    "$ref": "#/components/schemas/CabooseWhich"
                  },
                  "err": {
                    "type": "string"
                  }
                },
                "required": [
                  "caboose",
                  "err"
                ]
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "description": "No artifact with the required conditions for the component was found",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_matching_artifact_found"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The component's corresponding SP was not found in the inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sp_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "The component's corresponding sled contains zones that are unsafe to shut down",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unsafe_zone_found"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "Generation": {
        "description": "Generation numbers stored in the database, used for optimistic concurrency control",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "GzipLevel": {
        "type": "integer",
        "format": "uint8",
        "minimum": 0
      },
      "HeldDbClaimInfo": {
        "description": "Describes an outstanding database claim (for debugging why quiesce is stuck)",
        "type": "object",
        "properties": {
          "debug": {
            "type": "string"
          },
          "held_since": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "debug",
          "held_since",
          "id"
        ]
      },
      "HostPhase1Status": {
        "oneOf": [
          {
            "description": "This device has no host phase 1 status because it is not a sled (e.g., it's a PSC or switch).",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "not_a_sled"
                ]
              }
            },
            "required": [
              "kind"
            ]
          },
          {
            "type": "object",
            "properties": {
              "active_slot": {
                "nullable": true,
                "allOf": [
                  {
                    "$ref": "#/components/schemas/M2Slot"
                  }
                ]
              },
              "kind": {
                "type": "string",
                "enum": [
                  "sled"
                ]
              },
              "sled_id": {
                "$ref": "#/components/schemas/SledUuid"
              },
              "slot_a_version": {
                "$ref": "#/components/schemas/TufRepoVersion"
              },
              "slot_b_version": {
                "$ref": "#/components/schemas/TufRepoVersion"
              }
            },
            "required": [
              "kind",
              "sled_id",
              "slot_a_version",
              "slot_b_version"
            ]
          }
        ]
      },
      "HostPhase2Status": {
        "type": "object",
        "properties": {
          "boot_disk": {
            "x-rust-type": {
              "crate": "std",
              "parameters": [
                {
                  "$ref": "#/components/schemas/M2Slot"
                },
                {
                  "type": "string"
                }
              ],
              "path": "::std::result::Result",
              "version": "*"
            },
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "ok": {
                    "$ref": "#/components/schemas/M2Slot"
                  }
                },
                "required": [
                  "ok"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "err": {
                    "type": "string"
                  }
                },
                "required": [
                  "err"
                ]
              }
            ]
          },
          "slot_a_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          },
          "slot_b_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          }
        },
        "required": [
          "boot_disk",
          "slot_a_version",
          "slot_b_version"
        ]
      },
      "ImportExportPolicy": {
        "description": "Define policy relating to the import and export of prefixes from a BGP peer.",
        "oneOf": [
          {
            "description": "Do not perform any filtering.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "no_filtering"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "allow"
                ]
              },
              "value": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IpNet"
                }
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "InProgressUpdateStatus": {
        "description": "externally-exposed status for each in-progress update",
        "type": "object",
        "properties": {
          "baseboard_id": {
            "$ref": "#/components/schemas/BaseboardId"
          },
          "nattempts_done": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "status": {
            "$ref": "#/components/schemas/UpdateAttemptStatus"
          },
          "time_started": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "baseboard_id",
          "nattempts_done",
          "status",
          "time_started"
        ]
      },
      "Instance": {
        "description": "View of an Instance",
        "type": "object",
        "properties": {
          "auto_restart_cooldown_expiration": {
            "nullable": true,
            "description": "The time at which the auto-restart cooldown period for this instance completes, permitting it to be automatically restarted again. If the instance enters the `Failed` state, it will not be restarted until after this time.\n\nIf this is not present, then either the instance has never been automatically restarted, or the cooldown period has already expired, allowing the instance to be restarted immediately if it fails.",
            "type": "string",
            "format": "date-time"
          },
          "auto_restart_enabled": {
            "description": "`true` if this instance's auto-restart policy will permit the control plane to automatically restart it if it enters the `Failed` state.",
            "type": "boolean"
          },
          "auto_restart_policy": {
            "nullable": true,
            "description": "The auto-restart policy configured for this instance, or `null` if no explicit policy has been configured.\n\nThis policy determines whether the instance should be automatically restarted by the control plane on failure. If this is `null`, the control plane will use the default policy when determining whether or not to automatically restart this instance, which may or may not allow it to be restarted. The value of the `auto_restart_enabled` field indicates whether the instance will be auto-restarted, based on its current policy or the default if it has no configured policy.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceAutoRestartPolicy"
              }
            ]
          },
          "boot_disk_id": {
            "nullable": true,
            "description": "the ID of the disk used to boot this Instance, if a specific one is assigned.",
            "type": "string",
            "format": "uuid"
          },
          "cpu_platform": {
            "nullable": true,
            "description": "The CPU platform for this instance. If this is `null`, the instance requires no particular CPU platform.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceCpuPlatform"
              }
            ]
          },
          "description": {
            "description": "human-readable free-form text about a resource",
            "type": "string"
          },
          "hostname": {
            "description": "RFC1035-compliant hostname for the Instance.",
            "type": "string"
          },
          "id": {
            "description": "unique, immutable, system-controlled identifier for each resource",
            "type": "string",
            "format": "uuid"
          },
          "memory": {
            "description": "memory allocated for this Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "name": {
            "description": "unique, mutable, user-controlled identifier for each resource",
            "allOf": [
              {
                "$ref": "#/components/schemas/Name"
              }
            ]
          },
          "ncpus": {
            "description": "number of CPUs allocated for this Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceCpuCount"
              }
            ]
          },
          "project_id": {
            "description": "id for the project containing this Instance",
            "type": "string",
            "format": "uuid"
          },
          "run_state": {
            "$ref": "#/components/schemas/InstanceState"
          },
          "time_created": {
            "description": "timestamp when this resource was created",
            "type": "string",
            "format": "date-time"
          },
          "time_last_auto_restarted": {
            "nullable": true,
            "description": "The timestamp of the most recent time this instance was automatically restarted by the control plane.\n\nIf this is not present, then this instance has not been automatically restarted.",
            "type": "string",
            "format": "date-time"
          },
          "time_modified": {
            "description": "timestamp when this resource was last modified",
            "type": "string",
            "format": "date-time"
          },
          "time_run_state_updated": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "auto_restart_enabled",
          "description",
          "hostname",
          "id",
          "memory",
          "name",
          "ncpus",
          "project_id",
          "run_state",
          "time_created",
          "time_modified",
          "time_run_state_updated"
        ]
      },
      "InstanceAutoRestartPolicy": {
        "description": "A policy determining when an instance should be automatically restarted by the control plane.",
        "oneOf": [
          {
            "description": "The instance should not be automatically restarted by the control plane if it fails.",
            "type": "string",
            "enum": [
              "never"
            ]
          },
          {
            "description": "If this instance is running and unexpectedly fails (e.g. due to a host software crash or unexpected host reboot), the control plane will make a best-effort attempt to restart it. The control plane may choose not to restart the instance to preserve the overall availability of the system.",
            "type": "string",
            "enum": [
              "best_effort"
            ]
          }
        ]
      },
      "InstanceCpuCount": {
        "description": "The number of CPUs in an Instance",
        "type": "integer",
        "format": "uint16",
        "minimum": 0
      },
      "InstanceCpuPlatform": {
        "description": "A required CPU platform for an instance.\n\nWhen an instance specifies a required CPU platform:\n\n- The system may expose (to the VM) new CPU features that are only present on that platform (or on newer platforms of the same lineage that also support those features). - The instance must run on hosts that have CPUs that support all the features of the supplied platform.\n\nThat is, the instance is restricted to hosts that have the CPUs which support all features of the required platform, but in exchange the CPU features exposed by the platform are available for the guest to use. Note that this may prevent an instance from starting (if the hosts that could run it are full but there is capacity on other incompatible hosts).\n\nIf an instance does not specify a required CPU platform, then when it starts, the control plane selects a host for the instance and then supplies the guest with the \"minimum\" CPU platform supported by that host. This maximizes the number of hosts that can run the VM if it later needs to migrate to another host.\n\nIn all cases, the CPU features presented by a given CPU platform are a subset of what the corresponding hardware may actually support; features which cannot be used from a virtual environment or do not have full hypervisor support may be masked off. See RFD 314 for specific CPU features in a CPU platform.",
        "oneOf": [
          {
            "description": "An AMD Milan-like CPU platform.",
            "type": "string",
            "enum": [
              "amd_milan"
            ]
          },
          {
            "description": "An AMD Turin-like CPU platform.",
            "type": "string",
            "enum": [
              "amd_turin"
            ]
          }
        ]
      },
      "InstanceMigrateRequest": {
        "description": "Parameters used when migrating an instance.",
        "type": "object",
        "properties": {
          "dst_sled_id": {
            "description": "The ID of the sled to which to migrate the target instance.",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "dst_sled_id"
        ]
      },
      "InstanceState": {
        "description": "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle",
        "oneOf": [
          {
            "description": "The instance is being created.",
            "type": "string",
            "enum": [
              "creating"
            ]
          },
          {
            "description": "The instance is currently starting up.",
            "type": "string",
            "enum": [
              "starting"
            ]
          },
          {
            "description": "The instance is currently running.",
            "type": "string",
            "enum": [
              "running"
            ]
          },
          {
            "description": "The instance has been requested to stop and a transition to \"Stopped\" is imminent.",
            "type": "string",
            "enum": [
              "stopping"
            ]
          },
          {
            "description": "The instance is currently stopped.",
            "type": "string",
            "enum": [
              "stopped"
            ]
          },
          {
            "description": "The instance is in the process of rebooting - it will remain in the \"rebooting\" state until the VM is starting once more.",
            "type": "string",
            "enum": [
              "rebooting"
            ]
          },
          {
            "description": "The instance is in the process of migrating - it will remain in the \"migrating\" state until the migration process is complete and the destination propolis is ready to continue execution.",
            "type": "string",
            "enum": [
              "migrating"
            ]
          },
          {
            "description": "The instance is attempting to recover from a failure.",
            "type": "string",
            "enum": [
              "repairing"
            ]
          },
          {
            "description": "The instance has encountered a failure.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "The instance has been deleted.",
            "type": "string",
            "enum": [
              "destroyed"
            ]
          }
        ]
      },
      "IpNet": {
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::IpNet",
          "version": "0.1.0"
        },
        "oneOf": [
          {
            "title": "v4",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv4Net"
              }
            ]
          },
          {
            "title": "v6",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv6Net"
              }
            ]
          }
        ]
      },
      "IpRange": {
        "oneOf": [
          {
            "title": "v4",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv4Range"
              }
            ]
          },
          {
            "title": "v6",
            "allOf": [
              {
                "$ref": "#/components/schemas/Ipv6Range"
              }
            ]
          }
        ]
      },
      "Ipv4Net": {
        "example": "192.168.1.0/24",
        "title": "An IPv4 subnet",
        "description": "An IPv4 subnet, including prefix and prefix length",
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::Ipv4Net",
          "version": "0.1.0"
        },
        "type": "string",
        "pattern": "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|1[0-9]|2[0-9]|3[0-2])$"
      },
      "Ipv4Range": {
        "description": "A non-decreasing IPv4 address range, inclusive of both ends.\n\nThe first address must be less than or equal to the last address.",
        "type": "object",
        "properties": {
          "first": {
            "type": "string",
            "format": "ipv4"
          },
          "last": {
            "type": "string",
            "format": "ipv4"
          }
        },
        "required": [
          "first",
          "last"
        ]
      },
      "Ipv6Net": {
        "example": "fd12:3456::/64",
        "title": "An IPv6 subnet",
        "description": "An IPv6 subnet, including prefix and subnet mask",
        "x-rust-type": {
          "crate": "oxnet",
          "path": "oxnet::Ipv6Net",
          "version": "0.1.0"
        },
        "type": "string",
        "pattern": "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
      },
      "Ipv6Range": {
        "description": "A non-decreasing IPv6 address range, inclusive of both ends.\n\nThe first address must be less than or equal to the last address.",
        "type": "object",
        "properties": {
          "first": {
            "type": "string",
            "format": "ipv6"
          },
          "last": {
            "type": "string",
            "format": "ipv6"
          }
        },
        "required": [
          "first",
          "last"
        ]
      },
      "KeeperId": {
        "description": "A unique ID for a ClickHouse Keeper",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "LastResult": {
        "oneOf": [
          {
            "description": "The task has never completed an activation",
            "type": "object",
            "properties": {
              "last_result": {
                "type": "string",
                "enum": [
                  "never_completed"
                ]
              }
            },
            "required": [
              "last_result"
            ]
          },
          {
            "description": "The task has completed at least one activation",
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/LastResultCompleted"
              },
              "last_result": {
                "type": "string",
                "enum": [
                  "completed"
                ]
              }
            },
            "required": [
              "details",
              "last_result"
            ]
          }
        ]
      },
      "LastResultCompleted": {
        "type": "object",
        "properties": {
          "details": {
            "description": "arbitrary datum emitted by the background task"
          },
          "elapsed": {
            "description": "total time elapsed during the activation",
            "allOf": [
              {
                "$ref": "#/components/schemas/Duration"
              }
            ]
          },
          "iteration": {
            "description": "which iteration this was (counter)",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "reason": {
            "description": "what kind of event triggered this activation",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivationReason"
              }
            ]
          },
          "start_time": {
            "description": "wall-clock time when the activation started",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "details",
          "elapsed",
          "iteration",
          "reason",
          "start_time"
        ]
      },
      "LldpAdminStatus": {
        "description": "To what extent should this port participate in LLDP",
        "type": "string",
        "enum": [
          "enabled",
          "disabled",
          "rx_only",
          "tx_only"
        ]
      },
      "LldpPortConfig": {
        "description": "Per-port LLDP configuration settings.  Only the \"status\" setting is mandatory.  All other fields have natural defaults or may be inherited from the switch.",
        "type": "object",
        "properties": {
          "chassis_id": {
            "nullable": true,
            "description": "Chassis ID to advertise.  If this is set, it will be advertised as a LocallyAssigned ID type.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "string"
          },
          "management_addrs": {
            "nullable": true,
            "description": "Management IP addresses to advertise.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "ip"
            }
          },
          "port_description": {
            "nullable": true,
            "description": "Port description to advertise.  If this is not set, no description will be advertised.",
            "type": "string"
          },
          "port_id": {
            "nullable": true,
            "description": "Port ID to advertise.  If this is set, it will be advertised as a LocallyAssigned ID type.  If this is not set, it will be set to the port name. e.g., qsfp0/0.",
            "type": "string"
          },
          "status": {
            "description": "To what extent should this port participate in LLDP",
            "allOf": [
              {
                "$ref": "#/components/schemas/LldpAdminStatus"
              }
            ]
          },
          "system_description": {
            "nullable": true,
            "description": "System description to advertise.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "string"
          },
          "system_name": {
            "nullable": true,
            "description": "System name to advertise.  If this is not set, it will be inherited from the switch-level settings.",
            "type": "string"
          }
        },
        "required": [
          "status"
        ]
      },
      "M2Slot": {
        "description": "Describes an M.2 slot, often in the context of writing a system image to it.",
        "type": "string",
        "enum": [
          "A",
          "B"
        ]
      },
      "MacAddr": {
        "example": "ff:ff:ff:ff:ff:ff",
        "title": "A MAC address",
        "description": "A Media Access Control address, in EUI-48 format",
        "type": "string",
        "pattern": "^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$",
        "minLength": 5,
        "maxLength": 17
      },
      "MgsDrivenUpdateStatus": {
        "type": "object",
        "properties": {
          "baseboard_description": {
            "type": "string"
          },
          "host_os_phase_1": {
            "$ref": "#/components/schemas/HostPhase1Status"
          },
          "rot": {
            "$ref": "#/components/schemas/RotStatus"
          },
          "rot_bootloader": {
            "$ref": "#/components/schemas/RotBootloaderStatus"
          },
          "sp": {
            "$ref": "#/components/schemas/SpStatus"
          }
        },
        "required": [
          "baseboard_description",
          "host_os_phase_1",
          "rot",
          "rot_bootloader",
          "sp"
        ]
      },
      "MgsUpdateDriverStatus": {
        "description": "Status of ongoing update attempts, recently completed attempts, and update requests that are waiting for retry.",
        "type": "object",
        "properties": {
          "in_progress": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/InProgressUpdateStatus"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InProgressUpdateStatus"
            },
            "uniqueItems": true
          },
          "recent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompletedAttempt"
            }
          },
          "waiting": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/WaitingStatus"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WaitingStatus"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "in_progress",
          "recent",
          "waiting"
        ]
      },
      "MupdateOverrideUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::MupdateOverrideUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "Name": {
        "title": "A name unique within the parent collection",
        "description": "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID, but they may contain a UUID. They can be at most 63 characters long.",
        "type": "string",
        "pattern": "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$",
        "minLength": 1,
        "maxLength": 63
      },
      "NetworkInterface": {
        "description": "Information required to construct a virtual network interface",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "ip": {
            "type": "string",
            "format": "ip"
          },
          "kind": {
            "$ref": "#/components/schemas/NetworkInterfaceKind"
          },
          "mac": {
            "$ref": "#/components/schemas/MacAddr"
          },
          "name": {
            "$ref": "#/components/schemas/Name"
          },
          "primary": {
            "type": "boolean"
          },
          "slot": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "subnet": {
            "$ref": "#/components/schemas/IpNet"
          },
          "transit_ips": {
            "default": [],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IpNet"
            }
          },
          "vni": {
            "$ref": "#/components/schemas/Vni"
          }
        },
        "required": [
          "id",
          "ip",
          "kind",
          "mac",
          "name",
          "primary",
          "slot",
          "subnet",
          "vni"
        ]
      },
      "NetworkInterfaceKind": {
        "description": "The type of network interface",
        "oneOf": [
          {
            "description": "A vNIC attached to a guest instance",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "instance"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          },
          {
            "description": "A vNIC associated with an internal service",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "service"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          },
          {
            "description": "A vNIC associated with a probe",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "probe"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          }
        ]
      },
      "NewPasswordHash": {
        "title": "A password hash in PHC string format",
        "description": "Password hashes must be in PHC (Password Hashing Competition) string format.  Passwords must be hashed with Argon2id.  Password hashes may be rejected if the parameters appear not to be secure enough.",
        "type": "string"
      },
      "NexusGenerationBumpWaitingOn": {
        "oneOf": [
          {
            "description": "Waiting for the planner to finish updating all non-Nexus zones",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "found_old_non_nexus_zones"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting for the planner to deploy new-generation Nexus zones",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "missing_new_nexus_in_blueprint"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting for `db_metadata_nexus` records to be deployed for new-generation Nexus zones",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "missing_nexus_database_access_records"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting for newly deployed Nexus zones to appear to inventory",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "missing_new_nexus_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "NodeName": {
        "description": "Unique name for a saga [`Node`]\n\nEach node requires a string name that's unique within its DAG.  The name is used to identify its output.  Nodes that depend on a given node (either directly or indirectly) can access the node's output using its name.",
        "type": "string"
      },
      "OmicronZoneDataset": {
        "description": "Describes a persistent ZFS dataset associated with an Omicron zone",
        "type": "object",
        "properties": {
          "pool_name": {
            "$ref": "#/components/schemas/ZpoolName"
          }
        },
        "required": [
          "pool_name"
        ]
      },
      "OmicronZoneExternalFloatingAddr": {
        "description": "Floating external address with port allocated to an Omicron-managed zone.",
        "type": "object",
        "properties": {
          "addr": {
            "type": "string"
          },
          "id": {
            "$ref": "#/components/schemas/ExternalIpUuid"
          }
        },
        "required": [
          "addr",
          "id"
        ]
      },
      "OmicronZoneExternalFloatingIp": {
        "description": "Floating external IP allocated to an Omicron-managed zone.\n\nThis is a slimmer `nexus_db_model::ExternalIp` that only stores the fields necessary for blueprint planning, and requires that the zone have a single IP.",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ExternalIpUuid"
          },
          "ip": {
            "type": "string",
            "format": "ip"
          }
        },
        "required": [
          "id",
          "ip"
        ]
      },
      "OmicronZoneExternalSnatIp": {
        "description": "SNAT (outbound) external IP allocated to an Omicron-managed zone.\n\nThis is a slimmer `nexus_db_model::ExternalIp` that only stores the fields necessary for blueprint planning, and requires that the zone have a single IP.",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ExternalIpUuid"
          },
          "snat_cfg": {
            "$ref": "#/components/schemas/SourceNatConfig"
          }
        },
        "required": [
          "id",
          "snat_cfg"
        ]
      },
      "OmicronZoneType": {
        "description": "Describes what kind of zone this is (i.e., what component is running in it) as well as any type-specific configuration",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dns_servers": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "domain": {
                "nullable": true,
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing outbound connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "ntp_servers": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "snat_cfg": {
                "description": "The SNAT configuration for outbound connections.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SourceNatConfig"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "boundary_ntp"
                ]
              }
            },
            "required": [
              "address",
              "dns_servers",
              "nic",
              "ntp_servers",
              "snat_cfg",
              "type"
            ]
          },
          {
            "description": "Type of clickhouse zone used for a single node clickhouse deployment",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "description": "A zone used to run a Clickhouse Keeper node\n\nKeepers are only used in replicated clickhouse setups",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_keeper"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "description": "A zone used to run a Clickhouse Server in a replicated deployment",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "clickhouse_server"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cockroach_db"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible"
                ]
              }
            },
            "required": [
              "address",
              "dataset",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "crucible_pantry"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "description": "The address at which the external DNS server is reachable.",
                "type": "string"
              },
              "http_address": {
                "description": "The address at which the external DNS server API is reachable.",
                "type": "string"
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "external_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "http_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "dataset": {
                "$ref": "#/components/schemas/OmicronZoneDataset"
              },
              "dns_address": {
                "type": "string"
              },
              "gz_address": {
                "description": "The addresses in the global zone which should be created\n\nFor the DNS service, which exists outside the sleds's typical subnet - adding an address in the GZ is necessary to allow inter-zone traffic routing.",
                "type": "string",
                "format": "ipv6"
              },
              "gz_address_index": {
                "description": "The address is also identified with an auxiliary bit of information to ensure that the created global zone address can have a unique name.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0
              },
              "http_address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_dns"
                ]
              }
            },
            "required": [
              "dataset",
              "dns_address",
              "gz_address",
              "gz_address_index",
              "http_address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_ntp"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "external_dns_servers": {
                "description": "External DNS servers Nexus can use to resolve external hosts.",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "ip"
                }
              },
              "external_ip": {
                "description": "The address at which the external nexus server is reachable.",
                "type": "string",
                "format": "ip"
              },
              "external_tls": {
                "description": "Whether Nexus's external endpoint should use TLS",
                "type": "boolean"
              },
              "internal_address": {
                "description": "The address at which the internal nexus server is reachable.",
                "type": "string"
              },
              "lockstep_port": {
                "description": "The port at which the internal lockstep server is reachable. This shares the same IP address with `internal_address`.",
                "default": 12232,
                "type": "integer",
                "format": "uint16",
                "minimum": 0
              },
              "nic": {
                "description": "The service vNIC providing external connectivity using OPTE.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NetworkInterface"
                  }
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "nexus"
                ]
              }
            },
            "required": [
              "external_dns_servers",
              "external_ip",
              "external_tls",
              "internal_address",
              "nic",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "oximeter"
                ]
              }
            },
            "required": [
              "address",
              "type"
            ]
          }
        ]
      },
      "OmicronZoneUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::OmicronZoneUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "OximeterReadMode": {
        "description": "Where oximeter should read from",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "single_node"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "cluster"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "OximeterReadPolicy": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/OximeterReadMode"
          },
          "time_created": {
            "type": "string",
            "format": "date-time"
          },
          "version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "mode",
          "time_created",
          "version"
        ]
      },
      "PendingMgsUpdate": {
        "type": "object",
        "properties": {
          "artifact_hash": {
            "description": "which artifact to apply to this device",
            "type": "string",
            "format": "hex string (32 bytes)"
          },
          "artifact_version": {
            "$ref": "#/components/schemas/ArtifactVersion"
          },
          "baseboard_id": {
            "description": "id of the baseboard that we're going to update",
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseboardId"
              }
            ]
          },
          "details": {
            "description": "component-specific details of the pending update",
            "allOf": [
              {
                "$ref": "#/components/schemas/PendingMgsUpdateDetails"
              }
            ]
          },
          "slot_id": {
            "description": "last known MGS slot (cubby number) of the baseboard",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "sp_type": {
            "description": "what type of baseboard this is",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpType"
              }
            ]
          }
        },
        "required": [
          "artifact_hash",
          "artifact_version",
          "baseboard_id",
          "details",
          "slot_id",
          "sp_type"
        ]
      },
      "PendingMgsUpdateDetails": {
        "description": "Describes the component-specific details of a PendingMgsUpdate",
        "oneOf": [
          {
            "description": "the SP itself is being updated",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "sp"
                ]
              },
              "expected_active_version": {
                "description": "expected contents of the active slot",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ArtifactVersion"
                  }
                ]
              },
              "expected_inactive_version": {
                "description": "expected contents of the inactive slot",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExpectedVersion"
                  }
                ]
              }
            },
            "required": [
              "component",
              "expected_active_version",
              "expected_inactive_version"
            ]
          },
          {
            "description": "the RoT is being updated",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "rot"
                ]
              },
              "expected_active_slot": {
                "$ref": "#/components/schemas/ExpectedActiveRotSlot"
              },
              "expected_inactive_version": {
                "$ref": "#/components/schemas/ExpectedVersion"
              },
              "expected_pending_persistent_boot_preference": {
                "nullable": true,
                "description": "the persistent boot preference written into the CFPA scratch page that will become the persistent boot preference in the authoritative CFPA page upon reboot, unless CFPA update of the authoritative page fails for some reason.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RotSlot"
                  }
                ]
              },
              "expected_persistent_boot_preference": {
                "description": "the persistent boot preference written into the current authoritative CFPA page (ping or pong)",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RotSlot"
                  }
                ]
              },
              "expected_transient_boot_preference": {
                "nullable": true,
                "description": "override persistent preference selection for a single boot",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RotSlot"
                  }
                ]
              }
            },
            "required": [
              "component",
              "expected_active_slot",
              "expected_inactive_version",
              "expected_persistent_boot_preference"
            ]
          },
          {
            "description": "the RoT bootloader is being updated",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "rot_bootloader"
                ]
              },
              "expected_stage0_next_version": {
                "description": "expected contents of the stage 0 next",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExpectedVersion"
                  }
                ]
              },
              "expected_stage0_version": {
                "description": "expected contents of the stage 0",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ArtifactVersion"
                  }
                ]
              }
            },
            "required": [
              "component",
              "expected_stage0_next_version",
              "expected_stage0_version"
            ]
          },
          {
            "description": "the host OS is being updated\n\nWe write the phase 1 via MGS, and have a precheck condition that sled-agent has already written the matching phase 2.",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "host_phase1"
                ]
              },
              "expected_active_phase_1_hash": {
                "description": "The hash of the phase 1 slot specified by `expected_active_phase_1_hash`.\n\nWe should always be able to fetch this. Even if the phase 1 contents themselves have been corrupted (very scary for the active slot!), the SP can still hash those contents.",
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "expected_active_phase_1_slot": {
                "description": "Which slot is currently active according to the SP.\n\nThis controls which slot will be used the next time the sled boots; it will _usually_ match `boot_disk`, but differs in the window of time between telling the SP to change which slot to use and the host OS rebooting to actually use that slot.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/M2Slot"
                  }
                ]
              },
              "expected_active_phase_2_hash": {
                "description": "The hash of the currently-active phase 2 artifact.\n\nIt's possible sled-agent won't be able to report this value, but that would indicate that we don't know the version currently running. The planner wouldn't stage an update without knowing the current version, so if something has gone wrong in the meantime we won't proceede either.",
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "expected_boot_disk": {
                "description": "Which slot the host OS most recently booted from.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/M2Slot"
                  }
                ]
              },
              "expected_inactive_phase_1_hash": {
                "description": "The hash of the phase 1 slot specified by toggling `expected_active_phase_1_slot` to the other slot.\n\nWe should always be able to fetch this. Even if the phase 1 contents of the inactive slot are entirely bogus, the SP can still hash those contents.",
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "expected_inactive_phase_2_hash": {
                "description": "The hash of the currently-inactive phase 2 artifact.\n\nIt's entirely possible that a sled needing a host OS update has no valid artifact in its inactive slot. However, a precondition for us performing a phase 1 update is that `sled-agent` on the target sled has already written the paired phase 2 artifact to the inactive slot; therefore, we don't need to be able to represent an invalid inactive slot.",
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "sled_agent_address": {
                "description": "Address for contacting sled-agent to check phase 2 contents.",
                "type": "string"
              }
            },
            "required": [
              "component",
              "expected_active_phase_1_hash",
              "expected_active_phase_1_slot",
              "expected_active_phase_2_hash",
              "expected_boot_disk",
              "expected_inactive_phase_1_hash",
              "expected_inactive_phase_2_hash",
              "sled_agent_address"
            ]
          }
        ]
      },
      "PendingMgsUpdates": {
        "type": "object",
        "properties": {
          "by_baseboard": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/PendingMgsUpdate"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingMgsUpdate"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "by_baseboard"
        ]
      },
      "PendingRecovery": {
        "description": "Snapshot of reassignment state when a recovery pass started",
        "type": "object",
        "properties": {
          "blueprint_id": {
            "nullable": true,
            "description": "which blueprint id we'd be fully caught up to upon completion",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "generation": {
            "description": "what `reassignment_generation` was when this recovery started",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          }
        },
        "required": [
          "generation"
        ]
      },
      "PendingSagaInfo": {
        "description": "Describes a pending saga (for debugging why quiesce is stuck)",
        "type": "object",
        "properties": {
          "recovered": {
            "description": "If true, we know the saga needs to be recovered.  It may or may not be running already.\n\nIf false, this saga was created in this Nexus process's lifetime.  It's still running.",
            "type": "boolean"
          },
          "saga_id": {
            "type": "string",
            "format": "uuid"
          },
          "saga_name": {
            "type": "string"
          },
          "time_pending": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "recovered",
          "saga_id",
          "saga_name",
          "time_pending"
        ]
      },
      "PhysicalDiskKind": {
        "description": "Describes the form factor of physical disks.",
        "type": "string",
        "enum": [
          "m2",
          "u2"
        ]
      },
      "PhysicalDiskPath": {
        "type": "object",
        "properties": {
          "disk_id": {
            "description": "ID of the physical disk",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "disk_id"
        ]
      },
      "PhysicalDiskPutRequest": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/PhysicalDiskUuid"
          },
          "model": {
            "type": "string"
          },
          "serial": {
            "type": "string"
          },
          "sled_id": {
            "type": "string",
            "format": "uuid"
          },
          "variant": {
            "$ref": "#/components/schemas/PhysicalDiskKind"
          },
          "vendor": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "model",
          "serial",
          "sled_id",
          "variant",
          "vendor"
        ]
      },
      "PhysicalDiskUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::PhysicalDiskUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "Ping": {
        "type": "object",
        "properties": {
          "status": {
            "description": "Whether the external API is reachable. Will always be Ok if the endpoint returns anything at all.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PingStatus"
              }
            ]
          }
        },
        "required": [
          "status"
        ]
      },
      "PingStatus": {
        "type": "string",
        "enum": [
          "ok"
        ]
      },
      "PlannerConfig": {
        "type": "object",
        "properties": {
          "add_zones_with_mupdate_override": {
            "description": "Whether to add zones even if a mupdate override is present.\n\nOnce Nexus-driven update is active on a customer system, we must not add new zones while the system is recovering from a MUPdate.\n\nThis setting, which is off by default, allows us to add zones even if we've detected a recent MUPdate on the system.",
            "type": "boolean"
          }
        },
        "required": [
          "add_zones_with_mupdate_override"
        ]
      },
      "PlanningAddOutOfEligibleSleds": {
        "description": "How many discretionary zones we actually placed out of how many we wanted to place.",
        "type": "object",
        "properties": {
          "placed": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "wanted_to_place": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "placed",
          "wanted_to_place"
        ]
      },
      "PlanningAddStepReport": {
        "type": "object",
        "properties": {
          "add_update_blocked_reasons": {
            "description": "Reasons why zone adds and any updates are blocked.\n\nThis is typically a list of MUPdate-related reasons.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "add_zones_with_mupdate_override": {
            "description": "The value of the homonymous planner config. (What this really means is that zone adds happen despite being blocked by one or more MUPdate-related reasons.)",
            "type": "boolean"
          },
          "discretionary_zones_placed": {
            "description": "Sled ID  kinds of discretionary zones placed there",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/DiscretionaryZonePlacement"
              }
            }
          },
          "out_of_eligible_sleds": {
            "description": "Discretionary zone kind  (placed, wanted to place)",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PlanningAddOutOfEligibleSleds"
            }
          },
          "sleds_getting_ntp_and_discretionary_zones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          },
          "sleds_missing_crucible_zone": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ZpoolUuid"
              }
            }
          },
          "sleds_missing_ntp_zone": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          },
          "sleds_waiting_for_ntp_zone": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          },
          "sleds_without_ntp_zones_in_inventory": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          },
          "sleds_without_zpools_for_ntp_zones": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          },
          "sufficient_zones_exist": {
            "description": "Discretionary zone kind  (wanted to place, num existing)",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PlanningAddSufficientZonesExist"
            }
          },
          "target_release_generation_is_one": {
            "description": "Set to true if the target release generation is 1, which would allow zones to be added.",
            "type": "boolean"
          },
          "waiting_on": {
            "nullable": true,
            "description": "What are we waiting on to start zone additions?",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZoneAddWaitingOn"
              }
            ]
          }
        },
        "required": [
          "add_update_blocked_reasons",
          "add_zones_with_mupdate_override",
          "discretionary_zones_placed",
          "out_of_eligible_sleds",
          "sleds_getting_ntp_and_discretionary_zones",
          "sleds_missing_crucible_zone",
          "sleds_missing_ntp_zone",
          "sleds_waiting_for_ntp_zone",
          "sleds_without_ntp_zones_in_inventory",
          "sleds_without_zpools_for_ntp_zones",
          "sufficient_zones_exist",
          "target_release_generation_is_one"
        ]
      },
      "PlanningAddSufficientZonesExist": {
        "description": "We have at least the minimum required number of zones of a given kind.",
        "type": "object",
        "properties": {
          "num_existing": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "target_count": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "num_existing",
          "target_count"
        ]
      },
      "PlanningCockroachdbSettingsStepReport": {
        "type": "object",
        "properties": {
          "preserve_downgrade": {
            "$ref": "#/components/schemas/CockroachDbPreserveDowngrade"
          }
        },
        "required": [
          "preserve_downgrade"
        ]
      },
      "PlanningDecommissionStepReport": {
        "type": "object",
        "properties": {
          "zombie_sleds": {
            "description": "Decommissioned sleds that unexpectedly appeared as commissioned.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            }
          }
        },
        "required": [
          "zombie_sleds"
        ]
      },
      "PlanningExpungeStepReport": {
        "type": "object",
        "properties": {
          "orphan_disks": {
            "description": "Expunged disks not present in the parent blueprint.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PhysicalDiskUuid"
            }
          }
        },
        "required": [
          "orphan_disks"
        ]
      },
      "PlanningMgsUpdatesStepReport": {
        "type": "object",
        "properties": {
          "blocked_mgs_updates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlockedMgsUpdate"
            }
          },
          "pending_mgs_updates": {
            "$ref": "#/components/schemas/PendingMgsUpdates"
          }
        },
        "required": [
          "blocked_mgs_updates",
          "pending_mgs_updates"
        ]
      },
      "PlanningNexusGenerationBumpReport": {
        "oneOf": [
          {
            "description": "We have no reason to bump the Nexus generation number.",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "nothing_to_report"
                ]
              }
            },
            "required": [
              "component"
            ]
          },
          {
            "description": "We are waiting on some condition before we can bump the Nexus generation.",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "waiting_on"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/NexusGenerationBumpWaitingOn"
              }
            },
            "required": [
              "component",
              "value"
            ]
          },
          {
            "description": "We are bumping the Nexus generation number to this value.",
            "type": "object",
            "properties": {
              "component": {
                "type": "string",
                "enum": [
                  "bumping_generation"
                ]
              },
              "value": {
                "$ref": "#/components/schemas/Generation"
              }
            },
            "required": [
              "component",
              "value"
            ]
          }
        ]
      },
      "PlanningNoopImageSourceConverted": {
        "description": "How many of the total install-dataset zones and/or host phase 2 slots were noop-converted to use the artifact store on a particular sled.",
        "type": "object",
        "properties": {
          "host_phase_2_slot_a_eligible": {
            "type": "boolean"
          },
          "host_phase_2_slot_b_eligible": {
            "type": "boolean"
          },
          "num_dataset": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          },
          "num_eligible": {
            "type": "integer",
            "format": "uint",
            "minimum": 0
          }
        },
        "required": [
          "host_phase_2_slot_a_eligible",
          "host_phase_2_slot_b_eligible",
          "num_dataset",
          "num_eligible"
        ]
      },
      "PlanningNoopImageSourceSkipSledHostPhase2Reason": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sled_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "PlanningNoopImageSourceSkipSledZonesReason": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sled_not_in_inventory"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "error_retrieving_zone_manifest"
                ]
              }
            },
            "required": [
              "error",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/MupdateOverrideUuid"
              },
              "type": {
                "type": "string",
                "enum": [
                  "remove_mupdate_override"
                ]
              }
            },
            "required": [
              "id",
              "type"
            ]
          }
        ]
      },
      "PlanningNoopImageSourceSkipZoneReason": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "file_name": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "zone_not_in_manifest"
                ]
              },
              "zone_kind": {
                "type": "string"
              }
            },
            "required": [
              "file_name",
              "type",
              "zone_kind"
            ]
          },
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string"
              },
              "file_name": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "invalid_artifact"
                ]
              },
              "zone_kind": {
                "type": "string"
              }
            },
            "required": [
              "error",
              "file_name",
              "type",
              "zone_kind"
            ]
          },
          {
            "type": "object",
            "properties": {
              "artifact_hash": {
                "type": "string",
                "format": "hex string (32 bytes)"
              },
              "file_name": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "artifact_not_in_repo"
                ]
              },
              "zone_kind": {
                "type": "string"
              }
            },
            "required": [
              "artifact_hash",
              "file_name",
              "type",
              "zone_kind"
            ]
          }
        ]
      },
      "PlanningNoopImageSourceStepReport": {
        "type": "object",
        "properties": {
          "converted": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PlanningNoopImageSourceConverted"
            }
          },
          "no_target_release": {
            "type": "boolean"
          },
          "skipped_sled_host_phase_2": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PlanningNoopImageSourceSkipSledHostPhase2Reason"
            }
          },
          "skipped_sled_zones": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PlanningNoopImageSourceSkipSledZonesReason"
            }
          },
          "skipped_zones": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PlanningNoopImageSourceSkipZoneReason"
            }
          },
          "sled_host_phase_2_both_already_artifact": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          },
          "sled_zones_all_already_artifact": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledUuid"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "converted",
          "no_target_release",
          "skipped_sled_host_phase_2",
          "skipped_sled_zones",
          "skipped_zones",
          "sled_host_phase_2_both_already_artifact",
          "sled_zones_all_already_artifact"
        ]
      },
      "PlanningOutOfDateZone": {
        "description": "We have at least the minimum required number of zones of a given kind.",
        "type": "object",
        "properties": {
          "desired_image_source": {
            "$ref": "#/components/schemas/BlueprintZoneImageSource"
          },
          "zone": {
            "$ref": "#/components/schemas/PlanningReportBlueprintZone"
          }
        },
        "required": [
          "desired_image_source",
          "zone"
        ]
      },
      "PlanningReportBlueprintZone": {
        "description": "Reduced form of a `BlueprintZoneConfig` stored in a [`PlanningReport`].",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/OmicronZoneUuid"
          },
          "kind": {
            "$ref": "#/components/schemas/ZoneKind"
          }
        },
        "required": [
          "id",
          "kind"
        ]
      },
      "PlanningZoneUpdatesStepReport": {
        "type": "object",
        "properties": {
          "expunged_zones": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/PlanningReportBlueprintZone"
              }
            }
          },
          "out_of_date_zones": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/PlanningOutOfDateZone"
              }
            }
          },
          "unsafe_zones": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ZoneUnsafeToShutdown"
            }
          },
          "updated_zones": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/PlanningReportBlueprintZone"
              }
            }
          },
          "waiting_on": {
            "nullable": true,
            "description": "What are we waiting on to start zone updates?",
            "allOf": [
              {
                "$ref": "#/components/schemas/ZoneUpdatesWaitingOn"
              }
            ]
          },
          "waiting_zones": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ZoneWaitingToExpunge"
            }
          }
        },
        "required": [
          "expunged_zones",
          "out_of_date_zones",
          "unsafe_zones",
          "updated_zones",
          "waiting_zones"
        ]
      },
      "PortConfigV2": {
        "type": "object",
        "properties": {
          "addresses": {
            "description": "This port's addresses and optional vlan IDs",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UplinkAddressConfig"
            }
          },
          "autoneg": {
            "description": "Whether or not to set autonegotiation",
            "default": false,
            "type": "boolean"
          },
          "bgp_peers": {
            "description": "BGP peers on this port",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BgpPeerConfig"
            }
          },
          "lldp": {
            "nullable": true,
            "description": "LLDP configuration for this port",
            "allOf": [
              {
                "$ref": "#/components/schemas/LldpPortConfig"
              }
            ]
          },
          "port": {
            "description": "Nmae of the port this config applies to.",
            "type": "string"
          },
          "routes": {
            "description": "The set of routes associated with this port.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RouteConfig"
            }
          },
          "switch": {
            "description": "Switch the port belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SwitchLocation"
              }
            ]
          },
          "tx_eq": {
            "nullable": true,
            "description": "TX-EQ configuration for this port",
            "allOf": [
              {
                "$ref": "#/components/schemas/TxEqConfig"
              }
            ]
          },
          "uplink_port_fec": {
            "nullable": true,
            "description": "Port forward error correction type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortFec"
              }
            ]
          },
          "uplink_port_speed": {
            "description": "Port speed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortSpeed"
              }
            ]
          }
        },
        "required": [
          "addresses",
          "bgp_peers",
          "port",
          "routes",
          "switch",
          "uplink_port_speed"
        ]
      },
      "PortFec": {
        "description": "Switchport FEC options",
        "type": "string",
        "enum": [
          "firecode",
          "none",
          "rs"
        ]
      },
      "PortSpeed": {
        "description": "Switchport Speed options",
        "type": "string",
        "enum": [
          "speed0_g",
          "speed1_g",
          "speed10_g",
          "speed25_g",
          "speed40_g",
          "speed50_g",
          "speed100_g",
          "speed200_g",
          "speed400_g"
        ]
      },
      "QuiesceState": {
        "description": "See [`QuiesceStatus`] for more on Nexus quiescing.\n\nAt any given time, Nexus is always in one of these states:\n\n```text Undetermined        (have not loaded persistent state; don't know yet) | | load persistent state and find we're not quiescing v Running             (normal operation) | | quiesce starts v DrainingSagas       (no new sagas are allowed, but some are still running) | | no more sagas running v DrainingDb          (no sagas running; no new db connections may be |                  acquired by Nexus at-large, but some are still held) | | no more database connections held v RecordingQuiesce    (everything is quiesced aside from one connection being |                  used to record our final quiesced state) | | finish recording quiesce state in database v Quiesced            (no sagas running, no database connections in use) ```\n\nQuiescing is (currently) a one-way trip: once a Nexus process starts quiescing, it will never go back to normal operation.  It will never go back to an earlier stage, either.",
        "oneOf": [
          {
            "description": "We have not yet determined based on persistent state if we're supposed to be quiesced or not",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "undetermined"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Normal operation",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "running"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "New sagas disallowed, but some are still running on some Nexus instances",
            "type": "object",
            "properties": {
              "quiesce_details": {
                "type": "object",
                "properties": {
                  "time_requested": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "required": [
                  "time_requested"
                ]
              },
              "state": {
                "type": "string",
                "enum": [
                  "draining_sagas"
                ]
              }
            },
            "required": [
              "quiesce_details",
              "state"
            ]
          },
          {
            "description": "No sagas running on any Nexus instances\n\nNo new database connections may be claimed, but some database connections are still held.",
            "type": "object",
            "properties": {
              "quiesce_details": {
                "type": "object",
                "properties": {
                  "duration_draining_sagas": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "time_requested": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "required": [
                  "duration_draining_sagas",
                  "time_requested"
                ]
              },
              "state": {
                "type": "string",
                "enum": [
                  "draining_db"
                ]
              }
            },
            "required": [
              "quiesce_details",
              "state"
            ]
          },
          {
            "description": "No database connections in use except to record the final \"quiesced\" state",
            "type": "object",
            "properties": {
              "quiesce_details": {
                "type": "object",
                "properties": {
                  "duration_draining_db": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "duration_draining_sagas": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "time_requested": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "required": [
                  "duration_draining_db",
                  "duration_draining_sagas",
                  "time_requested"
                ]
              },
              "state": {
                "type": "string",
                "enum": [
                  "recording_quiesce"
                ]
              }
            },
            "required": [
              "quiesce_details",
              "state"
            ]
          },
          {
            "description": "Nexus has no sagas running and is not using the database",
            "type": "object",
            "properties": {
              "quiesce_details": {
                "type": "object",
                "properties": {
                  "duration_draining_db": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "duration_draining_sagas": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "duration_recording_quiesce": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "duration_total": {
                    "$ref": "#/components/schemas/Duration"
                  },
                  "time_quiesced": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "time_requested": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "required": [
                  "duration_draining_db",
                  "duration_draining_sagas",
                  "duration_recording_quiesce",
                  "duration_total",
                  "time_quiesced",
                  "time_requested"
                ]
              },
              "state": {
                "type": "string",
                "enum": [
                  "quiesced"
                ]
              }
            },
            "required": [
              "quiesce_details",
              "state"
            ]
          }
        ]
      },
      "QuiesceStatus": {
        "description": "Describes whether Nexus is quiescing or quiesced and what, if anything, is blocking the quiesce process\n\n**Quiescing** is the process of draining Nexus of running sagas and stopping all use of the database in preparation for upgrade.  See [`QuiesceState`] for more on the stages involved.",
        "type": "object",
        "properties": {
          "db_claims": {
            "title": "IdOrdMap",
            "description": "what database claims are currently held (by any part of Nexus)\n\nEntries here prevent transitioning from `WaitingForDb` to `Quiesced`.",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/HeldDbClaimInfo"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HeldDbClaimInfo"
            },
            "uniqueItems": true
          },
          "sagas": {
            "description": "information about saga quiescing",
            "allOf": [
              {
                "$ref": "#/components/schemas/SagaQuiesceStatus"
              }
            ]
          },
          "state": {
            "description": "what stage of quiescing is Nexus at",
            "allOf": [
              {
                "$ref": "#/components/schemas/QuiesceState"
              }
            ]
          }
        },
        "required": [
          "db_claims",
          "sagas",
          "state"
        ]
      },
      "RackInitializationRequest": {
        "type": "object",
        "properties": {
          "allowed_source_ips": {
            "description": "IPs or subnets allowed to make requests to user-facing services",
            "allOf": [
              {
                "$ref": "#/components/schemas/AllowedSourceIps"
              }
            ]
          },
          "blueprint": {
            "description": "Blueprint describing services initialized by RSS.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Blueprint"
              }
            ]
          },
          "certs": {
            "description": "x.509 Certificates used to encrypt communication with the external API.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Certificate"
            }
          },
          "crucible_datasets": {
            "description": "Crucible datasets on the rack which have been provisioned by RSS.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CrucibleDatasetCreateRequest"
            }
          },
          "external_dns_zone_name": {
            "description": "delegated DNS name for external DNS",
            "type": "string"
          },
          "external_port_count": {
            "description": "The external qsfp ports per sidecar",
            "allOf": [
              {
                "$ref": "#/components/schemas/ExternalPortDiscovery"
              }
            ]
          },
          "internal_dns_zone_config": {
            "description": "initial internal DNS config",
            "allOf": [
              {
                "$ref": "#/components/schemas/DnsConfigParams"
              }
            ]
          },
          "internal_services_ip_pool_ranges": {
            "description": "Ranges of the service IP pool which may be used for internal services, such as Nexus.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IpRange"
            }
          },
          "physical_disks": {
            "description": "\"Managed\" physical disks owned by the control plane",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PhysicalDiskPutRequest"
            }
          },
          "rack_network_config": {
            "description": "Initial rack network configuration",
            "allOf": [
              {
                "$ref": "#/components/schemas/RackNetworkConfigV2"
              }
            ]
          },
          "recovery_silo": {
            "description": "configuration for the initial (recovery) Silo",
            "allOf": [
              {
                "$ref": "#/components/schemas/RecoverySiloConfig"
              }
            ]
          },
          "zpools": {
            "description": "Zpools created within the physical disks created by the control plane.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ZpoolPutRequest"
            }
          }
        },
        "required": [
          "allowed_source_ips",
          "blueprint",
          "certs",
          "crucible_datasets",
          "external_dns_zone_name",
          "external_port_count",
          "internal_dns_zone_config",
          "internal_services_ip_pool_ranges",
          "physical_disks",
          "rack_network_config",
          "recovery_silo",
          "zpools"
        ]
      },
      "RackNetworkConfigV2": {
        "description": "Initial network configuration",
        "type": "object",
        "properties": {
          "bfd": {
            "description": "BFD configuration for connecting the rack to external networks",
            "default": [],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BfdPeerConfig"
            }
          },
          "bgp": {
            "description": "BGP configurations for connecting the rack to external networks",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BgpConfig"
            }
          },
          "infra_ip_first": {
            "description": "First ip address to be used for configuring network infrastructure",
            "type": "string",
            "format": "ipv4"
          },
          "infra_ip_last": {
            "description": "Last ip address to be used for configuring network infrastructure",
            "type": "string",
            "format": "ipv4"
          },
          "ports": {
            "description": "Uplinks for connecting the rack to external networks",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PortConfigV2"
            }
          },
          "rack_subnet": {
            "$ref": "#/components/schemas/Ipv6Net"
          }
        },
        "required": [
          "bgp",
          "infra_ip_first",
          "infra_ip_last",
          "ports",
          "rack_subnet"
        ]
      },
      "ReconfiguratorConfig": {
        "type": "object",
        "properties": {
          "planner_config": {
            "$ref": "#/components/schemas/PlannerConfig"
          },
          "planner_enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "planner_config",
          "planner_enabled"
        ]
      },
      "ReconfiguratorConfigParam": {
        "type": "object",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ReconfiguratorConfig"
          },
          "version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "config",
          "version"
        ]
      },
      "ReconfiguratorConfigView": {
        "type": "object",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ReconfiguratorConfig"
          },
          "time_modified": {
            "type": "string",
            "format": "date-time"
          },
          "version": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          }
        },
        "required": [
          "config",
          "time_modified",
          "version"
        ]
      },
      "RecoverySiloConfig": {
        "type": "object",
        "properties": {
          "silo_name": {
            "$ref": "#/components/schemas/Name"
          },
          "user_name": {
            "$ref": "#/components/schemas/UserId"
          },
          "user_password_hash": {
            "$ref": "#/components/schemas/NewPasswordHash"
          }
        },
        "required": [
          "silo_name",
          "user_name",
          "user_password_hash"
        ]
      },
      "RotBootloaderStatus": {
        "type": "object",
        "properties": {
          "stage0_next_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          },
          "stage0_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          }
        },
        "required": [
          "stage0_next_version",
          "stage0_version"
        ]
      },
      "RotSlot": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "slot": {
                "type": "string",
                "enum": [
                  "a"
                ]
              }
            },
            "required": [
              "slot"
            ]
          },
          {
            "type": "object",
            "properties": {
              "slot": {
                "type": "string",
                "enum": [
                  "b"
                ]
              }
            },
            "required": [
              "slot"
            ]
          }
        ]
      },
      "RotStatus": {
        "type": "object",
        "properties": {
          "active_slot": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/RotSlot"
              }
            ]
          },
          "slot_a_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          },
          "slot_b_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          }
        },
        "required": [
          "slot_a_version",
          "slot_b_version"
        ]
      },
      "RouteConfig": {
        "type": "object",
        "properties": {
          "destination": {
            "description": "The destination of the route.",
            "allOf": [
              {
                "$ref": "#/components/schemas/IpNet"
              }
            ]
          },
          "nexthop": {
            "description": "The nexthop/gateway address.",
            "type": "string",
            "format": "ip"
          },
          "rib_priority": {
            "nullable": true,
            "description": "The RIB priority (i.e. Admin Distance) associated with this route.",
            "default": null,
            "type": "integer",
            "format": "uint8",
            "minimum": 0
          },
          "vlan_id": {
            "nullable": true,
            "description": "The VLAN id associated with this route.",
            "default": null,
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "destination",
          "nexthop"
        ]
      },
      "Saga": {
        "description": "Sagas\n\nThese are currently only intended for observability by developers.  We will eventually want to flesh this out into something more observable for end users.",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "state": {
            "$ref": "#/components/schemas/SagaState"
          }
        },
        "required": [
          "id",
          "state"
        ]
      },
      "SagaErrorInfo": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string",
                "enum": [
                  "action_failed"
                ]
              },
              "source_error": {}
            },
            "required": [
              "error",
              "source_error"
            ]
          },
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string",
                "enum": [
                  "deserialize_failed"
                ]
              },
              "message": {
                "type": "string"
              }
            },
            "required": [
              "error",
              "message"
            ]
          },
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string",
                "enum": [
                  "injected_error"
                ]
              }
            },
            "required": [
              "error"
            ]
          },
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string",
                "enum": [
                  "serialize_failed"
                ]
              },
              "message": {
                "type": "string"
              }
            },
            "required": [
              "error",
              "message"
            ]
          },
          {
            "type": "object",
            "properties": {
              "error": {
                "type": "string",
                "enum": [
                  "subsaga_create_failed"
                ]
              },
              "message": {
                "type": "string"
              }
            },
            "required": [
              "error",
              "message"
            ]
          }
        ]
      },
      "SagaQuiesceStatus": {
        "type": "object",
        "properties": {
          "drained_blueprint_id": {
            "nullable": true,
            "description": "blueprint id that we're \"fully drained up to\"\n\nIf this value is non-`None`, that means that:\n\n- saga creation is disallowed - no sagas are running - we have re-assigned sagas from other Nexus instances expunged in this blueprint or earlier - we have finished recovery for all those sagas (that had been assigned to us as of the re-assignment pass for this blueprint id)\n\nThis means that the only way we can wind up running another saga is if there's a new blueprint that expunges a different Nexus zone.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "first_recovery_complete": {
            "description": "whether at least one recovery pass has successfully completed\n\nWe have to track this because we can't quiesce until we know we've recovered all outstanding sagas.",
            "type": "boolean"
          },
          "new_sagas_allowed": {
            "description": "current policy: are we allowed to *create* new sagas?\n\nThis also affects re-assigning sagas from expunged Nexus instances to ourselves.  It does **not** affect saga recovery.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SagasAllowed"
              }
            ]
          },
          "reassignment_blueprint_id": {
            "nullable": true,
            "description": "blueprint id associated with last successful saga reassignment\n\nSimilar to the generation number, this is used to track whether we've accounted for all sagas for all expungements up through this target blueprint.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "reassignment_generation": {
            "description": "generation number for the saga reassignment\n\nThis gets bumped whenever a saga reassignment operation completes that may have re-assigned us some sagas.  It's used to keep track of when we've recovered all sagas that could be assigned to us.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "reassignment_pending": {
            "description": "whether there is a saga reassignment operation happening\n\nThese operatinos may assign new sagas to Nexus that must be recovered and completed before quiescing can finish.",
            "type": "boolean"
          },
          "recovered_blueprint_id": {
            "nullable": true,
            "description": "blueprint id that saga recovery has \"caught up to\"\n\nThis means that we have finished recovering any sagas that were re-assigned to us due to expungements of other Nexus zones up through this blueprint.  Put differently: we know that we will never be assigned more sagas due to expungement unless the target blueprint changes past this one.\n\nThis does not mean that we've fully drained all sagas up through this blueprint.  There may still be sagas running.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BlueprintUuid"
              }
            ]
          },
          "recovered_reassignment_generation": {
            "description": "\"saga reassignment generation number\" that was \"caught up to\" by the last recovery pass\n\nThis is used with `reassignment_generation` to help us know when we've recovered all the sagas that may have been assigned to us during a given reassignment pass.  See `reassignment_done()` for details.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "recovery_pending": {
            "nullable": true,
            "description": "If a recovery pass is ongoing, a snapshot of reassignment state when it started (which reflects what we'll be caught up to when it finishes)",
            "allOf": [
              {
                "$ref": "#/components/schemas/PendingRecovery"
              }
            ]
          },
          "sagas_pending": {
            "title": "IdOrdMap",
            "description": "list of sagas we need to wait to complete before quiescing\n\nThese are basically running sagas.  They may have been created in this Nexus process lifetime or created in another process and then recovered in this one.",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/PendingSagaInfo"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingSagaInfo"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "first_recovery_complete",
          "new_sagas_allowed",
          "reassignment_generation",
          "reassignment_pending",
          "recovered_reassignment_generation",
          "sagas_pending"
        ]
      },
      "SagaResultsPage": {
        "description": "A single page of results",
        "type": "object",
        "properties": {
          "items": {
            "description": "list of items on this page of results",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Saga"
            }
          },
          "next_page": {
            "nullable": true,
            "description": "token used to fetch the next page of results (if any)",
            "type": "string"
          }
        },
        "required": [
          "items"
        ]
      },
      "SagaState": {
        "oneOf": [
          {
            "description": "Saga is currently executing",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "running"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Saga completed successfully",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "succeeded"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "One or more saga actions failed and the saga was successfully unwound (i.e., undo actions were executed for any actions that were completed). The saga is no longer running.",
            "type": "object",
            "properties": {
              "error_info": {
                "$ref": "#/components/schemas/SagaErrorInfo"
              },
              "error_node_name": {
                "$ref": "#/components/schemas/NodeName"
              },
              "state": {
                "type": "string",
                "enum": [
                  "failed"
                ]
              }
            },
            "required": [
              "error_info",
              "error_node_name",
              "state"
            ]
          },
          {
            "description": "One or more saga actions failed, *and* one or more undo actions failed during unwinding.  State managed by the saga may now be inconsistent. Support may be required to repair the state.  The saga is no longer running.",
            "type": "object",
            "properties": {
              "error_info": {
                "$ref": "#/components/schemas/SagaErrorInfo"
              },
              "error_node_name": {
                "$ref": "#/components/schemas/NodeName"
              },
              "state": {
                "type": "string",
                "enum": [
                  "stuck"
                ]
              },
              "undo_error_node_name": {
                "$ref": "#/components/schemas/NodeName"
              },
              "undo_source_error": {}
            },
            "required": [
              "error_info",
              "error_node_name",
              "state",
              "undo_error_node_name",
              "undo_source_error"
            ]
          }
        ]
      },
      "SagasAllowed": {
        "description": "Policy determining whether new sagas are allowed to be started\n\nThis is used by Nexus quiesce to disallow creation of new sagas when we're trying to quiesce Nexus.",
        "oneOf": [
          {
            "description": "New sagas may be started (normal condition)",
            "type": "string",
            "enum": [
              "allowed"
            ]
          },
          {
            "description": "New sagas may not be started because we're quiescing or quiesced",
            "type": "string",
            "enum": [
              "disallowed_quiesce"
            ]
          },
          {
            "description": "New sagas may not be started because we just started up and haven't determined if we're quiescing yet",
            "type": "string",
            "enum": [
              "disallowed_unknown"
            ]
          }
        ]
      },
      "ServerId": {
        "description": "A unique ID for a Clickhouse Server",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "SledAgentUpdateStatus": {
        "type": "object",
        "properties": {
          "host_phase_2": {
            "$ref": "#/components/schemas/HostPhase2Status"
          },
          "sled_id": {
            "$ref": "#/components/schemas/SledUuid"
          },
          "zones": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/ZoneStatus"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ZoneStatus"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "host_phase_2",
          "sled_id",
          "zones"
        ]
      },
      "SledId": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/SledUuid"
          }
        },
        "required": [
          "id"
        ]
      },
      "SledPolicy": {
        "description": "The operator-defined policy of a sled.",
        "oneOf": [
          {
            "description": "The operator has indicated that the sled is in-service.",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "in_service"
                ]
              },
              "provision_policy": {
                "description": "Determines whether new resources can be provisioned onto the sled.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SledProvisionPolicy"
                  }
                ]
              }
            },
            "required": [
              "kind",
              "provision_policy"
            ]
          },
          {
            "description": "The operator has indicated that the sled has been permanently removed from service.\n\nThis is a terminal state: once a particular sled ID is expunged, it will never return to service. (The actual hardware may be reused, but it will be treated as a brand-new sled.)\n\nAn expunged sled is always non-provisionable.",
            "type": "object",
            "properties": {
              "kind": {
                "type": "string",
                "enum": [
                  "expunged"
                ]
              }
            },
            "required": [
              "kind"
            ]
          }
        ]
      },
      "SledProvisionPolicy": {
        "description": "The operator-defined provision policy of a sled.\n\nThis controls whether new resources are going to be provisioned on this sled.",
        "oneOf": [
          {
            "description": "New resources will be provisioned on this sled.",
            "type": "string",
            "enum": [
              "provisionable"
            ]
          },
          {
            "description": "New resources will not be provisioned on this sled. However, if the sled is currently in service, existing resources will continue to be on this sled unless manually migrated off.",
            "type": "string",
            "enum": [
              "non_provisionable"
            ]
          }
        ]
      },
      "SledSelector": {
        "type": "object",
        "properties": {
          "sled": {
            "description": "ID of the sled",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "sled"
        ]
      },
      "SledState": {
        "description": "The current state of the sled.",
        "oneOf": [
          {
            "description": "The sled is currently active, and has resources allocated on it.",
            "type": "string",
            "enum": [
              "active"
            ]
          },
          {
            "description": "The sled has been permanently removed from service.\n\nThis is a terminal state: once a particular sled ID is decommissioned, it will never return to service. (The actual hardware may be reused, but it will be treated as a brand-new sled.)",
            "type": "string",
            "enum": [
              "decommissioned"
            ]
          }
        ]
      },
      "SledUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::SledUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "SourceNatConfig": {
        "description": "An IP address and port range used for source NAT, i.e., making outbound network connections from guests or services.",
        "type": "object",
        "properties": {
          "first_port": {
            "description": "The first port used for source NAT, inclusive.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "ip": {
            "description": "The external address provided to the instance or service.",
            "type": "string",
            "format": "ip"
          },
          "last_port": {
            "description": "The last port used for source NAT, also inclusive.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "first_port",
          "ip",
          "last_port"
        ]
      },
      "SpStatus": {
        "type": "object",
        "properties": {
          "slot0_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          },
          "slot1_version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          }
        },
        "required": [
          "slot0_version",
          "slot1_version"
        ]
      },
      "SpType": {
        "type": "string",
        "enum": [
          "sled",
          "power",
          "switch"
        ]
      },
      "Srv": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "prio": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "target": {
            "type": "string"
          },
          "weight": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "port",
          "prio",
          "target",
          "weight"
        ]
      },
      "SupportBundleCreate": {
        "type": "object",
        "properties": {
          "user_comment": {
            "nullable": true,
            "description": "User comment for the support bundle",
            "type": "string"
          }
        }
      },
      "SupportBundleInfo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "reason_for_creation": {
            "type": "string"
          },
          "reason_for_failure": {
            "nullable": true,
            "type": "string"
          },
          "state": {
            "$ref": "#/components/schemas/SupportBundleState"
          },
          "time_created": {
            "type": "string",
            "format": "date-time"
          },
          "user_comment": {
            "nullable": true,
            "type": "string"
          }
        },
        "required": [
          "id",
          "reason_for_creation",
          "state",
          "time_created"
        ]
      },
      "SupportBundleInfoResultsPage": {
        "description": "A single page of results",
        "type": "object",
        "properties": {
          "items": {
            "description": "list of items on this page of results",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SupportBundleInfo"
            }
          },
          "next_page": {
            "nullable": true,
            "description": "token used to fetch the next page of results (if any)",
            "type": "string"
          }
        },
        "required": [
          "items"
        ]
      },
      "SupportBundleState": {
        "oneOf": [
          {
            "description": "Support Bundle still actively being collected.\n\nThis is the initial state for a Support Bundle, and it will automatically transition to either \"Failing\" or \"Active\".\n\nIf a user no longer wants to access a Support Bundle, they can request cancellation, which will transition to the \"Destroying\" state.",
            "type": "string",
            "enum": [
              "collecting"
            ]
          },
          {
            "description": "Support Bundle is being destroyed.\n\nOnce backing storage has been freed, this bundle is destroyed.",
            "type": "string",
            "enum": [
              "destroying"
            ]
          },
          {
            "description": "Support Bundle was not created successfully, or was created and has lost backing storage.\n\nThe record of the bundle still exists for readability, but the only valid operation on these bundles is to destroy them.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "Support Bundle has been processed, and is ready for usage.",
            "type": "string",
            "enum": [
              "active"
            ]
          }
        ]
      },
      "SupportBundleUpdate": {
        "type": "object",
        "properties": {
          "user_comment": {
            "nullable": true,
            "description": "User comment for the support bundle",
            "type": "string"
          }
        }
      },
      "SwitchLocation": {
        "description": "Identifies switch physical location",
        "oneOf": [
          {
            "description": "Switch in upper slot",
            "type": "string",
            "enum": [
              "switch0"
            ]
          },
          {
            "description": "Switch in lower slot",
            "type": "string",
            "enum": [
              "switch1"
            ]
          }
        ]
      },
      "TufRepoVersion": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "zone_status_version": {
                "type": "string",
                "enum": [
                  "unknown"
                ]
              }
            },
            "required": [
              "zone_status_version"
            ]
          },
          {
            "type": "object",
            "properties": {
              "zone_status_version": {
                "type": "string",
                "enum": [
                  "install_dataset"
                ]
              }
            },
            "required": [
              "zone_status_version"
            ]
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "type": "string",
                "pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
              },
              "zone_status_version": {
                "type": "string",
                "enum": [
                  "version"
                ]
              }
            },
            "required": [
              "details",
              "zone_status_version"
            ]
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "type": "string"
              },
              "zone_status_version": {
                "type": "string",
                "enum": [
                  "error"
                ]
              }
            },
            "required": [
              "details",
              "zone_status_version"
            ]
          }
        ]
      },
      "TxEqConfig": {
        "description": "Per-port tx-eq overrides.  This can be used to fine-tune the transceiver equalization settings to improve signal integrity.",
        "type": "object",
        "properties": {
          "main": {
            "nullable": true,
            "description": "Main tap",
            "type": "integer",
            "format": "int32"
          },
          "post1": {
            "nullable": true,
            "description": "Post-cursor tap1",
            "type": "integer",
            "format": "int32"
          },
          "post2": {
            "nullable": true,
            "description": "Post-cursor tap2",
            "type": "integer",
            "format": "int32"
          },
          "pre1": {
            "nullable": true,
            "description": "Pre-cursor tap1",
            "type": "integer",
            "format": "int32"
          },
          "pre2": {
            "nullable": true,
            "description": "Pre-cursor tap2",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "UninitializedSled": {
        "description": "A sled that has not been added to an initialized rack yet",
        "type": "object",
        "properties": {
          "baseboard": {
            "$ref": "#/components/schemas/Baseboard"
          },
          "cubby": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          },
          "rack_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "baseboard",
          "cubby",
          "rack_id"
        ]
      },
      "UninitializedSledId": {
        "description": "The unique hardware ID for a sled",
        "type": "object",
        "properties": {
          "part": {
            "type": "string"
          },
          "serial": {
            "type": "string"
          }
        },
        "required": [
          "part",
          "serial"
        ]
      },
      "UninitializedSledResultsPage": {
        "description": "A single page of results",
        "type": "object",
        "properties": {
          "items": {
            "description": "list of items on this page of results",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UninitializedSled"
            }
          },
          "next_page": {
            "nullable": true,
            "description": "token used to fetch the next page of results (if any)",
            "type": "string"
          }
        },
        "required": [
          "items"
        ]
      },
      "UpdateAttemptStatus": {
        "description": "status of a single update attempt",
        "type": "string",
        "enum": [
          "not_started",
          "fetching_artifact",
          "precheck",
          "updating",
          "update_waiting",
          "post_update",
          "post_update_wait",
          "done"
        ]
      },
      "UpdateCompletedHow": {
        "type": "string",
        "enum": [
          "found_no_changes_needed",
          "completed_update",
          "waited_for_concurrent_update",
          "took_over_concurrent_update"
        ]
      },
      "UpdateStatus": {
        "type": "object",
        "properties": {
          "mgs_driven": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/MgsDrivenUpdateStatus"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MgsDrivenUpdateStatus"
            },
            "uniqueItems": true
          },
          "sleds": {
            "title": "IdOrdMap",
            "x-rust-type": {
              "crate": "iddqd",
              "parameters": [
                {
                  "$ref": "#/components/schemas/SledAgentUpdateStatus"
                }
              ],
              "path": "iddqd::IdOrdMap",
              "version": "*"
            },
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SledAgentUpdateStatus"
            },
            "uniqueItems": true
          }
        },
        "required": [
          "mgs_driven",
          "sleds"
        ]
      },
      "UplinkAddressConfig": {
        "type": "object",
        "properties": {
          "address": {
            "$ref": "#/components/schemas/IpNet"
          },
          "vlan_id": {
            "nullable": true,
            "description": "The VLAN id (if any) associated with this address.",
            "default": null,
            "type": "integer",
            "format": "uint16",
            "minimum": 0
          }
        },
        "required": [
          "address"
        ]
      },
      "UserId": {
        "title": "A username for a local-only user",
        "description": "Usernames must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Usernames cannot be a UUID, but they may contain a UUID. They can be at most 63 characters long.",
        "type": "string",
        "pattern": "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$",
        "minLength": 1,
        "maxLength": 63
      },
      "Vni": {
        "description": "A Geneve Virtual Network Identifier",
        "type": "integer",
        "format": "uint32",
        "minimum": 0
      },
      "WaitingStatus": {
        "description": "externally-exposed status for waiting updates",
        "type": "object",
        "properties": {
          "baseboard_id": {
            "$ref": "#/components/schemas/BaseboardId"
          },
          "nattempts_done": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "next_attempt_time": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "baseboard_id",
          "nattempts_done",
          "next_attempt_time"
        ]
      },
      "ZoneAddWaitingOn": {
        "oneOf": [
          {
            "description": "Waiting on one or more blockers (typically MUPdate-related reasons) to clear.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "blockers"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "ZoneKind": {
        "description": "Like [`OmicronZoneType`], but without any associated data.\n\nThis enum is meant to correspond exactly 1:1 with `OmicronZoneType`.\n\n# String representations of this type\n\nThere are no fewer than six string representations for this type, all slightly different from each other.\n\n1. [`Self::zone_prefix`]: Used to construct zone names. 2. [`Self::service_prefix`]: Used to construct SMF service names. 3. [`Self::name_prefix`]: Used to construct `Name` instances. 4. [`Self::report_str`]: Used for reporting and testing. 5. [`Self::artifact_id_name`]: Used to match TUF artifact IDs. 6. [`Self::artifact_in_install_dataset`]: Used to match zone image tarballs in the install dataset. (This method is equivalent to appending `.tar.gz` to the result of [`Self::zone_prefix`].)\n\nThere is no `Display` impl to ensure that users explicitly choose the representation they want. (Please play close attention to this! The functions are all similar but different, and we don't currently have great type safety around the choice.)\n\n## Adding new representations\n\nIf you have a new use case for a string representation, please reuse one of the six representations if at all possible. If you must add a new one, please add it here rather than doing something ad-hoc in the calling code so it's more legible.",
        "type": "string",
        "enum": [
          "boundary_ntp",
          "clickhouse",
          "clickhouse_keeper",
          "clickhouse_server",
          "cockroach_db",
          "crucible",
          "crucible_pantry",
          "external_dns",
          "internal_dns",
          "internal_ntp",
          "nexus",
          "oximeter"
        ]
      },
      "ZoneStatus": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/TufRepoVersion"
          },
          "zone_id": {
            "$ref": "#/components/schemas/OmicronZoneUuid"
          },
          "zone_type": {
            "$ref": "#/components/schemas/OmicronZoneType"
          }
        },
        "required": [
          "version",
          "zone_id",
          "zone_type"
        ]
      },
      "ZoneUnsafeToShutdown": {
        "description": "Zones which should not be shut down, because their lack of availability could be problematic for the successful functioning of the deployed system.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "reason": {
                "$ref": "#/components/schemas/CockroachdbUnsafeToShutdown"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cockroachdb"
                ]
              }
            },
            "required": [
              "reason",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "synchronized_count": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "total_boundary_ntp_zones": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "boundary_ntp"
                ]
              }
            },
            "required": [
              "synchronized_count",
              "total_boundary_ntp_zones",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "synchronized_count": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "total_internal_dns_zones": {
                "type": "integer",
                "format": "uint",
                "minimum": 0
              },
              "type": {
                "type": "string",
                "enum": [
                  "internal_dns"
                ]
              }
            },
            "required": [
              "synchronized_count",
              "total_internal_dns_zones",
              "type"
            ]
          }
        ]
      },
      "ZoneUpdatesWaitingOn": {
        "oneOf": [
          {
            "description": "Waiting on blocked updates to RoT bootloader / RoT / SP / Host OS.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "blocked_mgs_updates"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting on discretionary zone placement.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "discretionary_zones"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting on zones to propagate to inventory.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "inventory_propagation"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting on updates to RoT bootloader / RoT / SP / Host OS.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pending_mgs_updates"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "Waiting on the same set of blockers zone adds are waiting on.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "zone_add_blockers"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "ZoneWaitingToExpunge": {
        "description": "Out-of-date zones which are not yet ready to be expunged.\n\nFor example, out-of-date Nexus zones should not be expunged until handoff has completed.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "nexus"
                ]
              },
              "zone_generation": {
                "$ref": "#/components/schemas/Generation"
              }
            },
            "required": [
              "type",
              "zone_generation"
            ]
          }
        ]
      },
      "ZpoolName": {
        "title": "The name of a Zpool",
        "description": "Zpool names are of the format ox{i,p}_<UUID>. They are either Internal or External, and should be unique",
        "type": "string",
        "pattern": "^ox[ip]_[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
      },
      "ZpoolPutRequest": {
        "description": "Identifies information about a Zpool that should be part of the control plane.",
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "physical_disk_id": {
            "$ref": "#/components/schemas/PhysicalDiskUuid"
          },
          "sled_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "id",
          "physical_disk_id",
          "sled_id"
        ]
      },
      "ZpoolUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::ZpoolUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      },
      "IdSortMode": {
        "description": "Supported set of sort modes for scanning by id only.\n\nCurrently, we only support scanning in ascending order.",
        "oneOf": [
          {
            "description": "sort in increasing order of \"id\"",
            "type": "string",
            "enum": [
              "id_ascending"
            ]
          }
        ]
      },
      "TimeAndIdSortMode": {
        "description": "Supported set of sort modes for scanning by timestamp and ID",
        "oneOf": [
          {
            "description": "sort in increasing order of timestamp and ID, i.e., earliest first",
            "type": "string",
            "enum": [
              "time_and_id_ascending"
            ]
          },
          {
            "description": "sort in increasing order of timestamp and ID, i.e., most recent first",
            "type": "string",
            "enum": [
              "time_and_id_descending"
            ]
          }
        ]
      },
      "InstanceUuid": {
        "x-rust-type": {
          "crate": "omicron-uuid-kinds",
          "path": "omicron_uuid_kinds::InstanceUuid",
          "version": "*"
        },
        "type": "string",
        "format": "uuid"
      }
    },
    "responses": {
      "Error": {
        "description": "Error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      }
    }
  }
}
