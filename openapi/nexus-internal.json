{
  "openapi": "3.0.3",
  "info": {
    "title": "Nexus internal API",
    "description": "Nexus internal API",
    "contact": {
      "url": "https://oxide.computer",
      "email": "api@oxide.computer"
    },
    "version": "0.0.1"
  },
  "paths": {
    "/disks/{disk_id}": {
      "put": {
        "summary": "Report updated state for a disk.",
        "operationId": "cpapi_disks_put",
        "parameters": [
          {
            "in": "path",
            "name": "disk_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiskRuntimeState"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          }
        }
      }
    },
    "/instances/{instance_id}": {
      "put": {
        "summary": "Report updated state for an instance.",
        "operationId": "cpapi_instances_put",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceRuntimeState"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          }
        }
      }
    },
    "/metrics/collect/{producer_id}": {
      "get": {
        "summary": "Endpoint for oximeter to collect nexus server metrics.",
        "operationId": "cpapi_metrics_collect",
        "parameters": [
          {
            "in": "path",
            "name": "producer_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ProducerResultsItem",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ProducerResultsItem"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/metrics/collectors": {
      "post": {
        "summary": "Accept a notification of a new oximeter collection server.",
        "operationId": "cpapi_collectors_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OximeterInfo"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          }
        }
      }
    },
    "/metrics/producers": {
      "post": {
        "summary": "Accept a registration from a new metric producer",
        "operationId": "cpapi_producers_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProducerEndpoint"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          }
        }
      }
    },
    "/sled_agents/{sled_id}": {
      "post": {
        "summary": "Report that the sled agent for the specified sled has come online.",
        "operationId": "cpapi_sled_agents_post",
        "parameters": [
          {
            "in": "path",
            "name": "sled_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SledAgentStartupInfo"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          }
        }
      }
    },
    "/sled_agents/{sled_id}/zpools/{zpool_id}": {
      "put": {
        "summary": "Report that a pool for a specified sled has come online.",
        "operationId": "zpool_put",
        "parameters": [
          {
            "in": "path",
            "name": "sled_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "zpool_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZpoolPutRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZpoolPutResponse"
                }
              }
            }
          }
        }
      }
    },
    "/zpools/{zpool_id}/dataset/{dataset_id}": {
      "put": {
        "summary": "Report that a dataset within a pool has come online.",
        "operationId": "dataset_put",
        "parameters": [
          {
            "in": "path",
            "name": "dataset_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "zpool_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatasetPutRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetPutResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "BinRangedouble": {
        "description": "A type storing a range over `T`.\n\nThis type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.",
        "oneOf": [
          {
            "description": "A range unbounded below and exclusively above, `..end`.",
            "type": "object",
            "properties": {
              "RangeTo": {
                "type": "number",
                "format": "double"
              }
            },
            "required": [
              "RangeTo"
            ],
            "additionalProperties": false
          },
          {
            "description": "A range bounded inclusively below and exclusively above, `start..end`.",
            "type": "object",
            "properties": {
              "Range": {
                "type": "object",
                "properties": {
                  "end": {
                    "type": "number",
                    "format": "double"
                  },
                  "start": {
                    "type": "number",
                    "format": "double"
                  }
                },
                "required": [
                  "end",
                  "start"
                ]
              }
            },
            "required": [
              "Range"
            ],
            "additionalProperties": false
          },
          {
            "description": "A range bounded inclusively below and unbouned above, `start..`.",
            "type": "object",
            "properties": {
              "RangeFrom": {
                "type": "number",
                "format": "double"
              }
            },
            "required": [
              "RangeFrom"
            ],
            "additionalProperties": false
          }
        ]
      },
      "BinRangeint64": {
        "description": "A type storing a range over `T`.\n\nThis type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.",
        "oneOf": [
          {
            "description": "A range unbounded below and exclusively above, `..end`.",
            "type": "object",
            "properties": {
              "RangeTo": {
                "type": "integer",
                "format": "int64"
              }
            },
            "required": [
              "RangeTo"
            ],
            "additionalProperties": false
          },
          {
            "description": "A range bounded inclusively below and exclusively above, `start..end`.",
            "type": "object",
            "properties": {
              "Range": {
                "type": "object",
                "properties": {
                  "end": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "start": {
                    "type": "integer",
                    "format": "int64"
                  }
                },
                "required": [
                  "end",
                  "start"
                ]
              }
            },
            "required": [
              "Range"
            ],
            "additionalProperties": false
          },
          {
            "description": "A range bounded inclusively below and unbouned above, `start..`.",
            "type": "object",
            "properties": {
              "RangeFrom": {
                "type": "integer",
                "format": "int64"
              }
            },
            "required": [
              "RangeFrom"
            ],
            "additionalProperties": false
          }
        ]
      },
      "Bindouble": {
        "description": "Type storing bin edges and a count of samples within it.",
        "type": "object",
        "properties": {
          "count": {
            "description": "The total count of samples in this bin.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "range": {
            "description": "The range of the support covered by this bin.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BinRangedouble"
              }
            ]
          }
        },
        "required": [
          "count",
          "range"
        ]
      },
      "Binint64": {
        "description": "Type storing bin edges and a count of samples within it.",
        "type": "object",
        "properties": {
          "count": {
            "description": "The total count of samples in this bin.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "range": {
            "description": "The range of the support covered by this bin.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BinRangeint64"
              }
            ]
          }
        },
        "required": [
          "count",
          "range"
        ]
      },
      "ByteCount": {
        "description": "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "Cumulativedouble": {
        "description": "A cumulative or counter data type.",
        "type": "object",
        "properties": {
          "start_time": {
            "type": "string",
            "format": "date-time"
          },
          "value": {
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "start_time",
          "value"
        ]
      },
      "Cumulativeint64": {
        "description": "A cumulative or counter data type.",
        "type": "object",
        "properties": {
          "start_time": {
            "type": "string",
            "format": "date-time"
          },
          "value": {
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "start_time",
          "value"
        ]
      },
      "DatasetKind": {
        "description": "Describes the purpose of the dataset.",
        "type": "string",
        "enum": [
          "Crucible",
          "Cockroach",
          "Clickhouse"
        ]
      },
      "DatasetPutRequest": {
        "description": "Describes a dataset within a pool.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address on which a service is responding to requests for the dataset.",
            "type": "string"
          },
          "kind": {
            "description": "Type of dataset being inserted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetKind"
              }
            ]
          }
        },
        "required": [
          "address",
          "kind"
        ]
      },
      "DatasetPutResponse": {
        "description": "Describes which ZFS properties should be set for a particular allocated dataset.",
        "type": "object",
        "properties": {
          "quota": {
            "nullable": true,
            "description": "A maximum quota on filesystem usage. Refer to ZFS native properties for more detail.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "reservation": {
            "nullable": true,
            "description": "A minimum reservation size for a filesystem. Refer to ZFS native properties for more detail.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          }
        }
      },
      "Datum": {
        "description": "A `Datum` is a single sampled data point from a metric.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "Bool": {
                "type": "boolean"
              }
            },
            "required": [
              "Bool"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "I64": {
                "type": "integer",
                "format": "int64"
              }
            },
            "required": [
              "I64"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "F64": {
                "type": "number",
                "format": "double"
              }
            },
            "required": [
              "F64"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "String": {
                "type": "string"
              }
            },
            "required": [
              "String"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "Bytes": {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint8",
                  "minimum": 0
                }
              }
            },
            "required": [
              "Bytes"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "CumulativeI64": {
                "$ref": "#/components/schemas/Cumulativeint64"
              }
            },
            "required": [
              "CumulativeI64"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "CumulativeF64": {
                "$ref": "#/components/schemas/Cumulativedouble"
              }
            },
            "required": [
              "CumulativeF64"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "HistogramI64": {
                "$ref": "#/components/schemas/Histogramint64"
              }
            },
            "required": [
              "HistogramI64"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "HistogramF64": {
                "$ref": "#/components/schemas/Histogramdouble"
              }
            },
            "required": [
              "HistogramF64"
            ],
            "additionalProperties": false
          }
        ]
      },
      "DiskRuntimeState": {
        "description": "Runtime state of the Disk, which includes its attach state and some minimal metadata",
        "type": "object",
        "properties": {
          "disk_state": {
            "description": "runtime state of the Disk",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskState"
              }
            ]
          },
          "gen": {
            "description": "generation number for this state",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "time_updated": {
            "description": "timestamp for this information",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "disk_state",
          "gen",
          "time_updated"
        ]
      },
      "DiskState": {
        "description": "State of a Disk (primarily: attached or not)",
        "oneOf": [
          {
            "description": "Disk is being initialized",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "creating"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is ready but detached from any Instance",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "detached"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is being attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attached"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is being detached from the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "detaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk has been destroyed",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "destroyed"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is unavailable",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "faulted"
                ]
              }
            },
            "required": [
              "state"
            ]
          }
        ]
      },
      "Duration": {
        "type": "object",
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "nanos",
          "secs"
        ]
      },
      "Error": {
        "description": "Errors related to the generation or collection of metrics.",
        "oneOf": [
          {
            "description": "An error related to generating metric data points",
            "type": "object",
            "properties": {
              "content": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "DatumError"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "An error running an `Oximeter` server",
            "type": "object",
            "properties": {
              "content": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "OximeterServer"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "An error related to creating or sampling a [`histogram::Histogram`] metric.",
            "type": "object",
            "properties": {
              "content": {
                "$ref": "#/components/schemas/HistogramError"
              },
              "type": {
                "type": "string",
                "enum": [
                  "HistogramError"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "An error parsing a field or measurement from a string.",
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "src": {
                    "type": "string"
                  },
                  "typ": {
                    "type": "string"
                  }
                },
                "required": [
                  "src",
                  "typ"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "ParseError"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          }
        ]
      },
      "Field": {
        "description": "A `Field` is a named aspect of a target or metric.",
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/FieldValue"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "FieldSet": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            }
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "fields",
          "name"
        ]
      },
      "FieldValue": {
        "description": "The `FieldValue` contains the value of a target or metric field.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "String": {
                "type": "string"
              }
            },
            "required": [
              "String"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "I64": {
                "type": "integer",
                "format": "int64"
              }
            },
            "required": [
              "I64"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "IpAddr": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "IpAddr"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "Uuid": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "Uuid"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "Bool": {
                "type": "boolean"
              }
            },
            "required": [
              "Bool"
            ],
            "additionalProperties": false
          }
        ]
      },
      "Generation": {
        "description": "Generation numbers stored in the database, used for optimistic concurrency control",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "HistogramError": {
        "description": "Errors related to constructing histograms or adding samples into them.",
        "oneOf": [
          {
            "description": "An attempt to construct a histogram with an empty set of bins.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "EmptyBins"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "An attempt to construct a histogram with non-monotonic bins.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "NonmonotonicBins"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "A non-finite was encountered, either as a bin edge or a sample.",
            "type": "object",
            "properties": {
              "content": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "NonFiniteValue"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "Error returned when two neighboring bins are not adjoining (there's space between them)",
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "left": {
                    "type": "string"
                  },
                  "right": {
                    "type": "string"
                  }
                },
                "required": [
                  "left",
                  "right"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "NonAdjoiningBins"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "Bin and count arrays are of different sizes.",
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "n_bins": {
                    "type": "integer",
                    "format": "uint",
                    "minimum": 0
                  },
                  "n_counts": {
                    "type": "integer",
                    "format": "uint",
                    "minimum": 0
                  }
                },
                "required": [
                  "n_bins",
                  "n_counts"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "ArraySizeMismatch"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          }
        ]
      },
      "Histogramdouble": {
        "description": "A simple type for managing a histogram metric.\n\nA histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any \"gaps\" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.\n\nNote that any gaps, unsorted bins, or non-finite values will result in an error.\n\nExample ------- ```rust use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64, 10, 20]; let mut hist = Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..) assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);\n\nlet data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range, BinRange::range(i64::MIN, 0)); // An additional bin for `..0` assert_eq!(data[0].count, 0); // Nothing is in this bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```\n\nNotes -----\n\nHistograms may be constructed either from their left bin edges, or from a sequence of ranges. In either case, the left-most bin may be converted upon construction. In particular, if the left-most value is not equal to the minimum of the support, a new bin will be added from the minimum to that provided value. If the left-most value _is_ the support's minimum, because the provided bin was unbounded below, such as `(..0)`, then that bin will be converted into one bounded below, `(MIN..0)` in this case.\n\nThe short of this is that, most of the time, it shouldn't matter. If one specifies the extremes of the support as their bins, be aware that the left-most may be converted from a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the first bin of a histogram is _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In fact, every bin is one of those variants, the `BinRange::RangeTo` is only provided as a convenience during construction.",
        "type": "object",
        "properties": {
          "bins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Bindouble"
            }
          },
          "n_samples": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "start_time": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "bins",
          "n_samples",
          "start_time"
        ]
      },
      "Histogramint64": {
        "description": "A simple type for managing a histogram metric.\n\nA histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any \"gaps\" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.\n\nNote that any gaps, unsorted bins, or non-finite values will result in an error.\n\nExample ------- ```rust use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64, 10, 20]; let mut hist = Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..) assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);\n\nlet data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range, BinRange::range(i64::MIN, 0)); // An additional bin for `..0` assert_eq!(data[0].count, 0); // Nothing is in this bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```\n\nNotes -----\n\nHistograms may be constructed either from their left bin edges, or from a sequence of ranges. In either case, the left-most bin may be converted upon construction. In particular, if the left-most value is not equal to the minimum of the support, a new bin will be added from the minimum to that provided value. If the left-most value _is_ the support's minimum, because the provided bin was unbounded below, such as `(..0)`, then that bin will be converted into one bounded below, `(MIN..0)` in this case.\n\nThe short of this is that, most of the time, it shouldn't matter. If one specifies the extremes of the support as their bins, be aware that the left-most may be converted from a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the first bin of a histogram is _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In fact, every bin is one of those variants, the `BinRange::RangeTo` is only provided as a convenience during construction.",
        "type": "object",
        "properties": {
          "bins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Binint64"
            }
          },
          "n_samples": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "start_time": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "bins",
          "n_samples",
          "start_time"
        ]
      },
      "InstanceCpuCount": {
        "description": "The number of CPUs in an Instance",
        "type": "integer",
        "format": "uint16",
        "minimum": 0
      },
      "InstanceRuntimeState": {
        "description": "Runtime state of the Instance, including the actual running state and minimal metadata\n\nThis state is owned by the sled agent running that Instance.",
        "type": "object",
        "properties": {
          "dst_propolis_uuid": {
            "nullable": true,
            "description": "the target propolis-server during a migration of this Instance",
            "type": "string",
            "format": "uuid"
          },
          "gen": {
            "description": "generation number for this state",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "hostname": {
            "description": "RFC1035-compliant hostname for the Instance.",
            "type": "string"
          },
          "memory": {
            "description": "memory allocated for this Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "migration_uuid": {
            "nullable": true,
            "description": "migration id (if one in process)",
            "type": "string",
            "format": "uuid"
          },
          "ncpus": {
            "description": "number of CPUs allocated for this Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceCpuCount"
              }
            ]
          },
          "propolis_addr": {
            "nullable": true,
            "description": "address of propolis-server running this Instance",
            "type": "string"
          },
          "propolis_uuid": {
            "description": "which propolis-server is running this Instance",
            "type": "string",
            "format": "uuid"
          },
          "run_state": {
            "description": "runtime state of the Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceState"
              }
            ]
          },
          "sled_uuid": {
            "description": "which sled is running this Instance",
            "type": "string",
            "format": "uuid"
          },
          "time_updated": {
            "description": "timestamp for this information",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "hostname",
          "memory",
          "ncpus",
          "propolis_uuid",
          "run_state",
          "sled_uuid",
          "time_updated"
        ]
      },
      "InstanceState": {
        "description": "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle",
        "type": "string",
        "enum": [
          "creating",
          "starting",
          "running",
          "stopping",
          "stopped",
          "rebooting",
          "migrating",
          "repairing",
          "failed",
          "destroyed"
        ]
      },
      "Measurement": {
        "description": "A `Measurement` is a timestamped datum from a single metric",
        "type": "object",
        "properties": {
          "datum": {
            "$ref": "#/components/schemas/Datum"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "datum",
          "timestamp"
        ]
      },
      "OximeterInfo": {
        "description": "Message used to notify Nexus that this oximeter instance is up and running.",
        "type": "object",
        "properties": {
          "address": {
            "description": "The address on which this oximeter instance listens for requests",
            "type": "string"
          },
          "collector_id": {
            "description": "The ID for this oximeter instance.",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "address",
          "collector_id"
        ]
      },
      "ProducerEndpoint": {
        "description": "Information announced by a metric server, used so that clients can contact it and collect available metric data from it.",
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "base_route": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "interval": {
            "$ref": "#/components/schemas/Duration"
          }
        },
        "required": [
          "address",
          "base_route",
          "id",
          "interval"
        ]
      },
      "ProducerResultsItem": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "Ok": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Sample"
                }
              }
            },
            "required": [
              "Ok"
            ],
            "additionalProperties": false
          },
          {
            "type": "object",
            "properties": {
              "Err": {
                "$ref": "#/components/schemas/Error"
              }
            },
            "required": [
              "Err"
            ],
            "additionalProperties": false
          }
        ]
      },
      "Sample": {
        "description": "A concrete type representing a single, timestamped measurement from a timeseries.",
        "type": "object",
        "properties": {
          "measurement": {
            "description": "The measured value of the metric at this sample",
            "allOf": [
              {
                "$ref": "#/components/schemas/Measurement"
              }
            ]
          },
          "metric": {
            "$ref": "#/components/schemas/FieldSet"
          },
          "target": {
            "$ref": "#/components/schemas/FieldSet"
          },
          "timeseries_name": {
            "description": "The name of the timeseries this sample belongs to",
            "type": "string"
          }
        },
        "required": [
          "measurement",
          "metric",
          "target",
          "timeseries_name"
        ]
      },
      "SledAgentStartupInfo": {
        "description": "Sent by a sled agent on startup to Nexus to request further instruction",
        "type": "object",
        "properties": {
          "sa_address": {
            "description": "the address of the sled agent's API endpoint",
            "type": "string"
          }
        },
        "required": [
          "sa_address"
        ]
      },
      "ZpoolPutRequest": {
        "description": "Sent by a sled agent on startup to Nexus to request further instruction",
        "type": "object",
        "properties": {
          "size": {
            "description": "Total size of the pool.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          }
        },
        "required": [
          "size"
        ]
      },
      "ZpoolPutResponse": {
        "type": "object"
      }
    }
  }
}