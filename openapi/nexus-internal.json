{
  "openapi": "3.0.3",
  "info": {
    "title": "Nexus internal API",
    "description": "Nexus internal API",
    "contact": {
      "url": "https://oxide.computer",
      "email": "api@oxide.computer"
    },
    "version": "0.0.1"
  },
  "paths": {
    "/artifacts/{kind}/{name}/{version}": {
      "get": {
        "summary": "Endpoint used by Sled Agents to download cached artifacts.",
        "operationId": "cpapi_artifact_download",
        "parameters": [
          {
            "in": "path",
            "name": "kind",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/UpdateArtifactKind"
            }
          },
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {}
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/disks/{disk_id}": {
      "put": {
        "summary": "Report updated state for a disk.",
        "operationId": "cpapi_disks_put",
        "parameters": [
          {
            "in": "path",
            "name": "disk_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiskRuntimeState"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/instances/{instance_id}": {
      "put": {
        "summary": "Report updated state for an instance.",
        "operationId": "cpapi_instances_put",
        "parameters": [
          {
            "in": "path",
            "name": "instance_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceRuntimeState"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/metrics/collect/{producer_id}": {
      "get": {
        "summary": "Endpoint for oximeter to collect nexus server metrics.",
        "operationId": "cpapi_metrics_collect",
        "parameters": [
          {
            "in": "path",
            "name": "producer_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Array_of_ProducerResultsItem",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ProducerResultsItem"
                  }
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/metrics/collectors": {
      "post": {
        "summary": "Accept a notification of a new oximeter collection server.",
        "operationId": "cpapi_collectors_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OximeterInfo"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/metrics/producers": {
      "post": {
        "summary": "Accept a registration from a new metric producer",
        "operationId": "cpapi_producers_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProducerEndpoint"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/racks/{rack_id}/initialization-complete": {
      "put": {
        "summary": "Report that the Rack Setup Service initialization is complete",
        "description": "See RFD 278 for more details.",
        "operationId": "rack_initialization_complete",
        "parameters": [
          {
            "in": "path",
            "name": "rack_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RackInitializationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sled-agents/{sled_id}": {
      "post": {
        "summary": "Report that the sled agent for the specified sled has come online.",
        "operationId": "sled_agent_put",
        "parameters": [
          {
            "in": "path",
            "name": "sled_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SledAgentStartupInfo"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/sled-agents/{sled_id}/zpools/{zpool_id}": {
      "put": {
        "summary": "Report that a pool for a specified sled has come online.",
        "operationId": "zpool_put",
        "parameters": [
          {
            "in": "path",
            "name": "sled_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "path",
            "name": "zpool_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ZpoolPutRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ZpoolPutResponse"
                }
              }
            }
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    },
    "/volume/{volume_id}/remove-read-only-parent": {
      "post": {
        "summary": "Request removal of a read_only_parent from a volume",
        "description": "A volume can be created with the source data for that volume being another volume that attached as a \"read_only_parent\". In the background there exists a scrubber that will copy the data from the read_only_parent into the volume. When that scrubber has completed copying the data, this endpoint can be called to update the database that the read_only_parent is no longer needed for a volume and future attachments of this volume should not include that read_only_parent.",
        "operationId": "cpapi_volume_remove_read_only_parent",
        "parameters": [
          {
            "in": "path",
            "name": "volume_id",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "resource updated"
          },
          "4XX": {
            "$ref": "#/components/responses/Error"
          },
          "5XX": {
            "$ref": "#/components/responses/Error"
          }
        }
      }
    }
  },
  "components": {
    "responses": {
      "Error": {
        "description": "Error",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      }
    },
    "schemas": {
      "BinRangedouble": {
        "description": "A type storing a range over `T`.\n\nThis type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.",
        "oneOf": [
          {
            "description": "A range unbounded below and exclusively above, `..end`.",
            "type": "object",
            "properties": {
              "end": {
                "type": "number",
                "format": "double"
              },
              "type": {
                "type": "string",
                "enum": [
                  "range_to"
                ]
              }
            },
            "required": [
              "end",
              "type"
            ]
          },
          {
            "description": "A range bounded inclusively below and exclusively above, `start..end`.",
            "type": "object",
            "properties": {
              "end": {
                "type": "number",
                "format": "double"
              },
              "start": {
                "type": "number",
                "format": "double"
              },
              "type": {
                "type": "string",
                "enum": [
                  "range"
                ]
              }
            },
            "required": [
              "end",
              "start",
              "type"
            ]
          },
          {
            "description": "A range bounded inclusively below and unbounded above, `start..`.",
            "type": "object",
            "properties": {
              "start": {
                "type": "number",
                "format": "double"
              },
              "type": {
                "type": "string",
                "enum": [
                  "range_from"
                ]
              }
            },
            "required": [
              "start",
              "type"
            ]
          }
        ]
      },
      "BinRangeint64": {
        "description": "A type storing a range over `T`.\n\nThis type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.",
        "oneOf": [
          {
            "description": "A range unbounded below and exclusively above, `..end`.",
            "type": "object",
            "properties": {
              "end": {
                "type": "integer",
                "format": "int64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "range_to"
                ]
              }
            },
            "required": [
              "end",
              "type"
            ]
          },
          {
            "description": "A range bounded inclusively below and exclusively above, `start..end`.",
            "type": "object",
            "properties": {
              "end": {
                "type": "integer",
                "format": "int64"
              },
              "start": {
                "type": "integer",
                "format": "int64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "range"
                ]
              }
            },
            "required": [
              "end",
              "start",
              "type"
            ]
          },
          {
            "description": "A range bounded inclusively below and unbounded above, `start..`.",
            "type": "object",
            "properties": {
              "start": {
                "type": "integer",
                "format": "int64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "range_from"
                ]
              }
            },
            "required": [
              "start",
              "type"
            ]
          }
        ]
      },
      "Bindouble": {
        "description": "Type storing bin edges and a count of samples within it.",
        "type": "object",
        "properties": {
          "count": {
            "description": "The total count of samples in this bin.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "range": {
            "description": "The range of the support covered by this bin.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BinRangedouble"
              }
            ]
          }
        },
        "required": [
          "count",
          "range"
        ]
      },
      "Binint64": {
        "description": "Type storing bin edges and a count of samples within it.",
        "type": "object",
        "properties": {
          "count": {
            "description": "The total count of samples in this bin.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "range": {
            "description": "The range of the support covered by this bin.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BinRangeint64"
              }
            ]
          }
        },
        "required": [
          "count",
          "range"
        ]
      },
      "ByteCount": {
        "description": "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "Certificate": {
        "type": "object",
        "properties": {
          "cert": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            }
          },
          "key": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            }
          }
        },
        "required": [
          "cert",
          "key"
        ]
      },
      "Cumulativedouble": {
        "description": "A cumulative or counter data type.",
        "type": "object",
        "properties": {
          "start_time": {
            "type": "string",
            "format": "date-time"
          },
          "value": {
            "type": "number",
            "format": "double"
          }
        },
        "required": [
          "start_time",
          "value"
        ]
      },
      "Cumulativeint64": {
        "description": "A cumulative or counter data type.",
        "type": "object",
        "properties": {
          "start_time": {
            "type": "string",
            "format": "date-time"
          },
          "value": {
            "type": "integer",
            "format": "int64"
          }
        },
        "required": [
          "start_time",
          "value"
        ]
      },
      "DatasetCreateRequest": {
        "type": "object",
        "properties": {
          "dataset_id": {
            "type": "string",
            "format": "uuid"
          },
          "request": {
            "$ref": "#/components/schemas/DatasetPutRequest"
          },
          "zpool_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "dataset_id",
          "request",
          "zpool_id"
        ]
      },
      "DatasetKind": {
        "description": "Describes the purpose of the dataset.",
        "type": "string",
        "enum": [
          "crucible",
          "cockroach",
          "clickhouse"
        ]
      },
      "DatasetPutRequest": {
        "description": "Describes a dataset within a pool.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address on which a service is responding to requests for the dataset.",
            "type": "string"
          },
          "kind": {
            "description": "Type of dataset being inserted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DatasetKind"
              }
            ]
          }
        },
        "required": [
          "address",
          "kind"
        ]
      },
      "Datum": {
        "description": "A `Datum` is a single sampled data point from a metric.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "datum": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "bool"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "type": "integer",
                "format": "int64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "i64"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "type": "number",
                "format": "double"
              },
              "type": {
                "type": "string",
                "enum": [
                  "f64"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "string"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "uint8",
                  "minimum": 0
                }
              },
              "type": {
                "type": "string",
                "enum": [
                  "bytes"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "$ref": "#/components/schemas/Cumulativeint64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cumulative_i64"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "$ref": "#/components/schemas/Cumulativedouble"
              },
              "type": {
                "type": "string",
                "enum": [
                  "cumulative_f64"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "$ref": "#/components/schemas/Histogramint64"
              },
              "type": {
                "type": "string",
                "enum": [
                  "histogram_i64"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "datum": {
                "$ref": "#/components/schemas/Histogramdouble"
              },
              "type": {
                "type": "string",
                "enum": [
                  "histogram_f64"
                ]
              }
            },
            "required": [
              "datum",
              "type"
            ]
          }
        ]
      },
      "DiskRuntimeState": {
        "description": "Runtime state of the Disk, which includes its attach state and some minimal metadata",
        "type": "object",
        "properties": {
          "disk_state": {
            "description": "runtime state of the Disk",
            "allOf": [
              {
                "$ref": "#/components/schemas/DiskState"
              }
            ]
          },
          "gen": {
            "description": "generation number for this state",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "time_updated": {
            "description": "timestamp for this information",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "disk_state",
          "gen",
          "time_updated"
        ]
      },
      "DiskState": {
        "description": "State of a Disk (primarily: attached or not)",
        "oneOf": [
          {
            "description": "Disk is being initialized",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "creating"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is ready but detached from any Instance",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "detached"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is being attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is attached to the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "attached"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk is being detached from the given Instance",
            "type": "object",
            "properties": {
              "instance": {
                "type": "string",
                "format": "uuid"
              },
              "state": {
                "type": "string",
                "enum": [
                  "detaching"
                ]
              }
            },
            "required": [
              "instance",
              "state"
            ]
          },
          {
            "description": "Disk has been destroyed",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "destroyed"
                ]
              }
            },
            "required": [
              "state"
            ]
          },
          {
            "description": "Disk is unavailable",
            "type": "object",
            "properties": {
              "state": {
                "type": "string",
                "enum": [
                  "faulted"
                ]
              }
            },
            "required": [
              "state"
            ]
          }
        ]
      },
      "Duration": {
        "type": "object",
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          }
        },
        "required": [
          "nanos",
          "secs"
        ]
      },
      "Error": {
        "description": "Error information from a response.",
        "type": "object",
        "properties": {
          "error_code": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "request_id": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "request_id"
        ]
      },
      "Field": {
        "description": "A `Field` is a named aspect of a target or metric.",
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/FieldValue"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "FieldSet": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            }
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "fields",
          "name"
        ]
      },
      "FieldValue": {
        "description": "The `FieldValue` contains the value of a target or metric field.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "string"
                ]
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "i64"
                ]
              },
              "value": {
                "type": "integer",
                "format": "int64"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ip_addr"
                ]
              },
              "value": {
                "type": "string",
                "format": "ip"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "uuid"
                ]
              },
              "value": {
                "type": "string",
                "format": "uuid"
              }
            },
            "required": [
              "type",
              "value"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "bool"
                ]
              },
              "value": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "value"
            ]
          }
        ]
      },
      "Generation": {
        "description": "Generation numbers stored in the database, used for optimistic concurrency control",
        "type": "integer",
        "format": "uint64",
        "minimum": 0
      },
      "HistogramError": {
        "description": "Errors related to constructing histograms or adding samples into them.",
        "oneOf": [
          {
            "description": "An attempt to construct a histogram with an empty set of bins.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "empty_bins"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "An attempt to construct a histogram with non-monotonic bins.",
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "nonmonotonic_bins"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "description": "A non-finite was encountered, either as a bin edge or a sample.",
            "type": "object",
            "properties": {
              "content": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "non_finite_value"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "Error returned when two neighboring bins are not adjoining (there's space between them)",
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "left": {
                    "type": "string"
                  },
                  "right": {
                    "type": "string"
                  }
                },
                "required": [
                  "left",
                  "right"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "non_adjoining_bins"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "Bin and count arrays are of different sizes.",
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "n_bins": {
                    "type": "integer",
                    "format": "uint",
                    "minimum": 0
                  },
                  "n_counts": {
                    "type": "integer",
                    "format": "uint",
                    "minimum": 0
                  }
                },
                "required": [
                  "n_bins",
                  "n_counts"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "array_size_mismatch"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          }
        ]
      },
      "Histogramdouble": {
        "description": "A simple type for managing a histogram metric.\n\nA histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any \"gaps\" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.\n\nNote that any gaps, unsorted bins, or non-finite values will result in an error.\n\nExample ------- ```rust use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64, 10, 20]; let mut hist = Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..) assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);\n\nlet data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range, BinRange::range(i64::MIN, 0)); // An additional bin for `..0` assert_eq!(data[0].count, 0); // Nothing is in this bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```\n\nNotes -----\n\nHistograms may be constructed either from their left bin edges, or from a sequence of ranges. In either case, the left-most bin may be converted upon construction. In particular, if the left-most value is not equal to the minimum of the support, a new bin will be added from the minimum to that provided value. If the left-most value _is_ the support's minimum, because the provided bin was unbounded below, such as `(..0)`, then that bin will be converted into one bounded below, `(MIN..0)` in this case.\n\nThe short of this is that, most of the time, it shouldn't matter. If one specifies the extremes of the support as their bins, be aware that the left-most may be converted from a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the first bin of a histogram is _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In fact, every bin is one of those variants, the `BinRange::RangeTo` is only provided as a convenience during construction.",
        "type": "object",
        "properties": {
          "bins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Bindouble"
            }
          },
          "n_samples": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "start_time": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "bins",
          "n_samples",
          "start_time"
        ]
      },
      "Histogramint64": {
        "description": "A simple type for managing a histogram metric.\n\nA histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any \"gaps\" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.\n\nNote that any gaps, unsorted bins, or non-finite values will result in an error.\n\nExample ------- ```rust use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64, 10, 20]; let mut hist = Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..) assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);\n\nlet data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range, BinRange::range(i64::MIN, 0)); // An additional bin for `..0` assert_eq!(data[0].count, 0); // Nothing is in this bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```\n\nNotes -----\n\nHistograms may be constructed either from their left bin edges, or from a sequence of ranges. In either case, the left-most bin may be converted upon construction. In particular, if the left-most value is not equal to the minimum of the support, a new bin will be added from the minimum to that provided value. If the left-most value _is_ the support's minimum, because the provided bin was unbounded below, such as `(..0)`, then that bin will be converted into one bounded below, `(MIN..0)` in this case.\n\nThe short of this is that, most of the time, it shouldn't matter. If one specifies the extremes of the support as their bins, be aware that the left-most may be converted from a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the first bin of a histogram is _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In fact, every bin is one of those variants, the `BinRange::RangeTo` is only provided as a convenience during construction.",
        "type": "object",
        "properties": {
          "bins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Binint64"
            }
          },
          "n_samples": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0
          },
          "start_time": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "bins",
          "n_samples",
          "start_time"
        ]
      },
      "InstanceCpuCount": {
        "description": "The number of CPUs in an Instance",
        "type": "integer",
        "format": "uint16",
        "minimum": 0
      },
      "InstanceRuntimeState": {
        "description": "Runtime state of the Instance, including the actual running state and minimal metadata\n\nThis state is owned by the sled agent running that Instance.",
        "type": "object",
        "properties": {
          "dst_propolis_id": {
            "nullable": true,
            "description": "the target propolis-server during a migration of this Instance",
            "type": "string",
            "format": "uuid"
          },
          "gen": {
            "description": "generation number for this state",
            "allOf": [
              {
                "$ref": "#/components/schemas/Generation"
              }
            ]
          },
          "hostname": {
            "description": "RFC1035-compliant hostname for the Instance.",
            "type": "string"
          },
          "memory": {
            "description": "memory allocated for this Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          },
          "migration_id": {
            "nullable": true,
            "description": "migration id (if one in process)",
            "type": "string",
            "format": "uuid"
          },
          "ncpus": {
            "description": "number of CPUs allocated for this Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceCpuCount"
              }
            ]
          },
          "propolis_addr": {
            "nullable": true,
            "description": "address of propolis-server running this Instance",
            "type": "string"
          },
          "propolis_id": {
            "description": "which propolis-server is running this Instance",
            "type": "string",
            "format": "uuid"
          },
          "run_state": {
            "description": "runtime state of the Instance",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceState"
              }
            ]
          },
          "sled_id": {
            "description": "which sled is running this Instance",
            "type": "string",
            "format": "uuid"
          },
          "time_updated": {
            "description": "timestamp for this information",
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "gen",
          "hostname",
          "memory",
          "ncpus",
          "propolis_id",
          "run_state",
          "sled_id",
          "time_updated"
        ]
      },
      "InstanceState": {
        "description": "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle",
        "oneOf": [
          {
            "description": "The instance is being created.",
            "type": "string",
            "enum": [
              "creating"
            ]
          },
          {
            "description": "The instance is currently starting up.",
            "type": "string",
            "enum": [
              "starting"
            ]
          },
          {
            "description": "The instance is currently running.",
            "type": "string",
            "enum": [
              "running"
            ]
          },
          {
            "description": "The instance has been requested to stop and a transition to \"Stopped\" is imminent.",
            "type": "string",
            "enum": [
              "stopping"
            ]
          },
          {
            "description": "The instance is currently stopped.",
            "type": "string",
            "enum": [
              "stopped"
            ]
          },
          {
            "description": "The instance is in the process of rebooting - it will remain in the \"rebooting\" state until the VM is starting once more.",
            "type": "string",
            "enum": [
              "rebooting"
            ]
          },
          {
            "description": "The instance is in the process of migrating - it will remain in the \"migrating\" state until the migration process is complete and the destination propolis is ready to continue execution.",
            "type": "string",
            "enum": [
              "migrating"
            ]
          },
          {
            "description": "The instance is attempting to recover from a failure.",
            "type": "string",
            "enum": [
              "repairing"
            ]
          },
          {
            "description": "The instance has encountered a failure.",
            "type": "string",
            "enum": [
              "failed"
            ]
          },
          {
            "description": "The instance has been deleted.",
            "type": "string",
            "enum": [
              "destroyed"
            ]
          }
        ]
      },
      "Measurement": {
        "description": "A `Measurement` is a timestamped datum from a single metric",
        "type": "object",
        "properties": {
          "datum": {
            "$ref": "#/components/schemas/Datum"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "datum",
          "timestamp"
        ]
      },
      "MetricsError": {
        "description": "Errors related to the generation or collection of metrics.",
        "oneOf": [
          {
            "description": "An error related to generating metric data points",
            "type": "object",
            "properties": {
              "content": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "datum_error"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "An error running an `Oximeter` server",
            "type": "object",
            "properties": {
              "content": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "oximeter_server"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "An error related to creating or sampling a [`histogram::Histogram`] metric.",
            "type": "object",
            "properties": {
              "content": {
                "$ref": "#/components/schemas/HistogramError"
              },
              "type": {
                "type": "string",
                "enum": [
                  "histogram_error"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "description": "An error parsing a field or measurement from a string.",
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "src": {
                    "type": "string"
                  },
                  "typ": {
                    "type": "string"
                  }
                },
                "required": [
                  "src",
                  "typ"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "parse_error"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          }
        ]
      },
      "OximeterInfo": {
        "description": "Message used to notify Nexus that this oximeter instance is up and running.",
        "type": "object",
        "properties": {
          "address": {
            "description": "The address on which this oximeter instance listens for requests",
            "type": "string"
          },
          "collector_id": {
            "description": "The ID for this oximeter instance.",
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "address",
          "collector_id"
        ]
      },
      "ProducerEndpoint": {
        "description": "Information announced by a metric server, used so that clients can contact it and collect available metric data from it.",
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "base_route": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "interval": {
            "$ref": "#/components/schemas/Duration"
          }
        },
        "required": [
          "address",
          "base_route",
          "id",
          "interval"
        ]
      },
      "ProducerResultsItem": {
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "info": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Sample"
                }
              },
              "status": {
                "type": "string",
                "enum": [
                  "ok"
                ]
              }
            },
            "required": [
              "info",
              "status"
            ]
          },
          {
            "type": "object",
            "properties": {
              "info": {
                "$ref": "#/components/schemas/MetricsError"
              },
              "status": {
                "type": "string",
                "enum": [
                  "err"
                ]
              }
            },
            "required": [
              "info",
              "status"
            ]
          }
        ]
      },
      "RackInitializationRequest": {
        "type": "object",
        "properties": {
          "certs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Certificate"
            }
          },
          "datasets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DatasetCreateRequest"
            }
          },
          "services": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ServicePutRequest"
            }
          }
        },
        "required": [
          "certs",
          "datasets",
          "services"
        ]
      },
      "Sample": {
        "description": "A concrete type representing a single, timestamped measurement from a timeseries.",
        "type": "object",
        "properties": {
          "measurement": {
            "description": "The measured value of the metric at this sample",
            "allOf": [
              {
                "$ref": "#/components/schemas/Measurement"
              }
            ]
          },
          "metric": {
            "$ref": "#/components/schemas/FieldSet"
          },
          "target": {
            "$ref": "#/components/schemas/FieldSet"
          },
          "timeseries_name": {
            "description": "The name of the timeseries this sample belongs to",
            "type": "string"
          }
        },
        "required": [
          "measurement",
          "metric",
          "target",
          "timeseries_name"
        ]
      },
      "ServiceKind": {
        "description": "Describes the purpose of the service.",
        "oneOf": [
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "internal_d_n_s"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "content": {
                "type": "object",
                "properties": {
                  "external_address": {
                    "type": "string",
                    "format": "ip"
                  }
                },
                "required": [
                  "external_address"
                ]
              },
              "type": {
                "type": "string",
                "enum": [
                  "nexus"
                ]
              }
            },
            "required": [
              "content",
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "oximeter"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "dendrite"
                ]
              }
            },
            "required": [
              "type"
            ]
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "tfport"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "ServicePutRequest": {
        "description": "Describes a service on a sled",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address on which a service is responding to requests.",
            "type": "string",
            "format": "ipv6"
          },
          "kind": {
            "description": "Type of service being inserted.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ServiceKind"
              }
            ]
          },
          "service_id": {
            "type": "string",
            "format": "uuid"
          },
          "sled_id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "required": [
          "address",
          "kind",
          "service_id",
          "sled_id"
        ]
      },
      "SledAgentStartupInfo": {
        "description": "Sent by a sled agent on startup to Nexus to request further instruction",
        "type": "object",
        "properties": {
          "role": {
            "description": "Describes the responsibilities of the sled",
            "allOf": [
              {
                "$ref": "#/components/schemas/SledRole"
              }
            ]
          },
          "sa_address": {
            "description": "The address of the sled agent's API endpoint",
            "type": "string"
          }
        },
        "required": [
          "role",
          "sa_address"
        ]
      },
      "SledRole": {
        "description": "Describes the role of the sled within the rack.\n\nNote that this may change if the sled is physically moved within the rack.",
        "oneOf": [
          {
            "description": "The sled is a general compute sled.",
            "type": "string",
            "enum": [
              "gimlet"
            ]
          },
          {
            "description": "The sled is attached to the network switch, and has additional responsibilities.",
            "type": "string",
            "enum": [
              "scrimlet"
            ]
          }
        ]
      },
      "ZpoolPutRequest": {
        "description": "Sent by a sled agent on startup to Nexus to request further instruction",
        "type": "object",
        "properties": {
          "size": {
            "description": "Total size of the pool.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ByteCount"
              }
            ]
          }
        },
        "required": [
          "size"
        ]
      },
      "ZpoolPutResponse": {
        "type": "object"
      },
      "UpdateArtifactKind": {
        "description": "Kinds of update artifacts, as used by Nexus to determine what updates are available and by sled-agent to determine how to apply an update when asked.",
        "type": "string",
        "enum": [
          "zone"
        ]
      }
    }
  }
}