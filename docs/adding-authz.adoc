= Adding Authorization for Resources
:toc: left
:toclevels: 3

== Overview

This document explains how to add authorization (authz) support for new resources in Nexus. Authorization is based on role-based access control (RBAC) using the Oso policy engine.

Before implementing authz for a new resource, read the module comments in `nexus/auth/src/authz/mod.rs` and `nexus/auth/src/authz/api_resources.rs` to understand the basic concepts.

The most important thing to know is that every authz check we have today boils down to asking:

* is this **actor** (a silo user or internal system user)
* allowed to perform this **action**
* on this **resource**

It usually looks like this:

```rust
opctx.authorize(authz::Action::Modify, &authz::INVENTORY)
```

Here:

- `opctx` identifies the actor.  This object is ubiquitous in Nexus and constructing it requires authenticating the user.
- `authz::Action` is an enum with just a handful of standard actions.
- `authz::Inventory` is the resource.  It's an **authz type** (or **authz object**).

`opctx.authorize()` checks the system **policy**, which is the set of rules that produces a boolean answer to the question "can this actor perform this action on this resource?".  Our policy is defined in a language called Polar in a file called `omicron.polar`.

Altogether, the authz subsystem comprises:

* `omicron.polar`, the policy rules that define who can do what
* the authz types (Rust types that correspond with resources -- these also correspond directly with types in the Polar file)
* the authz checks scattered throughout the code base, all in terms of the authz types
* the implementation of `authorize()` (you can ignore this for the purposes of this document):
** storage and queries for accessing role assignments in the database
** evaluation of Polar policy

=== Authz types, synthetic resources

Authz types are Rust types that represent **resources** on which we do authz checks.  They're exported from the `authz` module.  As local variables, we usually prefix them with `authz`, as in `authz_instance` to distinguish it from other representations (like `db_instance` for the database record for an instance).

Many authz types correspond directly with API resources and database types that you already know: `authz::Project`, `authz::Instance`, etc.

Others are called **synthetic resources**: these are Rust types that we've defined to represent something we want to do authz checks on, but that don't correspond to anything in the database.  For example, `authz::FLEET` represents "the whole control plane".footnote:["Fleet" here is probably something of a misnomer.]  `authz::SiloCertificateList(SiloUuid)` represents "the list of TLS certificates for a _given_ Silo.

Synthetic resources help us **separate policy from implementation**.  Suppose we're adding authz to the API endpoint that lists the items in an IP pool.  What should the authz check be?  By defining a synthetic resource, the answer is simple: it's just:

```rust
opctx.authorize(authz::Action::ListChildren, &authz::IP_POOL_LIST).await;
```

This is almost a literal translation of what we're doing: we're (listing the children) of the (IP pool list).  This is by design.  The question of _who is allowed to list the children of the IP pool list_ is a question of policy.  That doesn't belong in the code doing the authz checks.

It's tempting to take shortcuts like: "people can operate on my thing if they can operate on the Fleet.  I'll just use `authz::FLEET` ".  That's encoding the policy directly in the implementation.  Instead, prefer creating a synthetic resource whose policy (in the Polar file) reflects that it's equivalent to `Fleet`, while the authz check itself remains almost a literal translation of the action you're taking.  For example, rather than checking Fleet authorization when modifying inventory, we define an `Inventory` resource whose Polar policy says that Fleet admins have modify permissions on Inventory. The code just checks `authorize(Action::Modify, &INVENTORY)` without knowing anything about the Fleet.

This can sound like make-work, but this principle (separating policy from implementation) is very powerful:

* Writing, modifying, and reviewing implementation code is easy because all the authz checks just check exactly the thing you're doing.  You don't have to reason about the authz policy while looking at the implementation.
* Writing, modifying, and reviewing the policy is also easier without having to consider the implementation.
* We're able to write xref:../nexus/db-queries/src/policy_test/mod.rs[totally comprehensive tests] on the policy without having to exercise every single code path in Nexus.
* From the xref:../nexus/db-queries/tests/output/authz-roles.out[output of that test], readers (including non-engineers) are able to answer policy questions (like "what actions can a silo collaborator perform on a project in their silo") without having to look at any code.
* It allows us to change the policy and potentially even the entire user model and `authz.authorize()` implementation without changing any of the authz checks in the system.

== Adding new authz resources

Although there's some boilerplate in adding new resources, it should be pretty easy.  authz resources generally fall into one of a few categories, each with a slightly different implementation pattern:

* <<_dynamic_resources>> generally correspond with API resources and database objects.  This includes `Silo`, `Project`, etc.
* <<_static_resources>> are generally synthetic resources that represent either some broad concept (like `Inventory`, which is "all the information we have about the system's current hardware and software configuration") or a made-up collection (like `SiloCertificateList`, which is "the list of TLS certificates in a particular Silo").  They can either be at the top level (like `Inventory`) or nested under some dynamic resource (the way `SiloCertificateList` is nested under a _specific_ Silo).

NOTE: There's another explanation for why we have synthetic resources: it allows us to have a uniform set of just a handful of actions: `read`, `modify`, etc.  The alternative would be to define a lot of different and heterogenous actions.  For example, instead of having `SiloCertificateList` and `SiloUserList` on which you can `list_children`, we'd have just `Silo` on which you could `list_certificates` and `list_users`, etc.  For various reasons it's been very helpful to have a small, uniform set of actions.

=== Adding New Dynamic Resources

These are resources with multiple instances that correspond to database entities. This is the most common case.  We'll look at how the `IpPool` resource is defined as a template.

==== Example: IpPool (fleet-level resource)

In `nexus/auth/src/authz/api_resources.rs`, we define the authz type with:

[source,rust]
----
authz_resource! {
    name = "IpPool",
    parent = "Fleet",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = FleetChild,
}
----

In `nexus/auth/src/authz/oso_generic.rs`, the authz type is added to the `generated_inits` array in `make_omicron_oso()`:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    IpPool::init(),
    // ... more resources ...
];

for init in generated_inits {
    oso_builder = oso_builder.register_class_with_snippet(init)?;
}
----

In `nexus/db-queries/src/policy_test/resources.rs`, the test defines instances of the authz type in order to test what permissions different roles have on it.

==== Example: Disk (project-level resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "Disk",
    parent = "Project",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectLimited,
}
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `generated_inits` array:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    Disk::init(),
    // ... more resources ...
];

for init in generated_inits {
    oso_builder = oso_builder.register_class_with_snippet(init)?;
}
----

**In nexus/db-queries/src/policy_test/resources.rs,** add instances in the parent's helper:

[source,rust]
----
async fn make_project(/* ... */) {
    let project = authz::Project::new(/* ... */);
    // ...
    builder.new_resource(authz::Disk::new(
        project.clone(),
        Uuid::new_v4(),
        LookupType::ByName(format!("{}-disk1", project_name)),
    ));
}
----

==== Example: VpcSubnet (project networking resource, nested under Vpc)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "VpcSubnet",
    parent = "Vpc",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectFull,
}
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `generated_inits` array:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    VpcSubnet::init(),
    // ... more resources ...
];

for init in generated_inits {
    oso_builder = oso_builder.register_class_with_snippet(init)?;
}
----

**In nexus/db-queries/src/policy_test/resources.rs,** add instances in the parent's helper.

==== Choosing the Right Polar Snippet

The `polar_snippet` parameter controls what Polar policy is generated:

* `FleetChild`: For fleet-level resources. Grants `read` and `list_children` to `fleet.viewer`, and `modify` and `create_child` to `fleet.admin`.  Examples: `IpPool`, `Rack`, `Sled`, `Blueprint`, `AddressLot`, `SwitchPort`, `Service`.
* `InSilo`: For Silo-scoped resources. Grants permissions based on Silo roles.  Examples: `SiloImage`, `Image`.
* `InProjectLimited`: For Project compute resources (instances, disks, snapshots, images, floating IPs). Users with `limited-collaborator` can create and modify these.  Examples: `Disk`, `Instance`, `Snapshot`, `ProjectImage`, `FloatingIp`, `AffinityGroup`.
* `InProjectFull`: For Project networking infrastructure (VPCs, subnets, routers, internet gateways). Requires full `collaborator` role.  Examples: `Vpc`, `VpcSubnet`, `VpcRouter`, `RouterRoute`, `InternetGateway`, `ExternalSubnet`.
* `Custom`: No generated policy. You write the entire Polar policy manually in `omicron.polar`. Examples: `Silo`, `Project`, `SshKey`, `Certificate`, `SiloUser`, `IdentityProvider`, `MulticastGroup`

The distinction between `InProjectLimited` and `InProjectFull` allows organizations to give users access to compute resources while restricting who can reconfigure networking.

==== App Layer Usage

For dynamic resources, use `LookupPath` to look up the resource:

[source,rust]
----
use nexus_db_queries::db::lookup::LookupPath;

// Top-level resource
let (.., authz_ip_pool) = LookupPath::new(&opctx, &datastore)
    .ip_pool_id(pool_id)
    .fetch()
    .await?;

opctx.authorize(authz::Action::Read, &authz_ip_pool).await?;

// Nested resource
let (.., authz_disk) = LookupPath::new(&opctx, &datastore)
    .disk_id(disk_id)
    .fetch()
    .await?;

opctx.authorize(authz::Action::Read, &authz_disk).await?;

// Multi-level nested resource
let (.., authz_subnet) = LookupPath::new(&opctx, &datastore)
    .project_id(project_id)
    .vpc_id(vpc_id)
    .vpc_subnet_id(subnet_id)
    .fetch()
    .await?;

opctx.authorize(authz::Action::Modify, &authz_subnet).await?;
----



=== Static Resources

Singleton resources representing system-wide concepts or synthetic collections. These are almost always synthetic resources that don't correspond to database entities.

**Static top-level examples:** `Fleet`, `Inventory`, `DnsConfig`, `BlueprintConfig`, `QuiesceState`, `AuditLog`, `IpPoolList`, `DeviceAuthRequestList`

**Static child examples:** `SiloCertificateList`, `SiloUserList`, `SiloGroupList`, `SiloIdentityProviderList`, `VpcList`

==== Example: Inventory (static top-level resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
/// Synthetic resource used for modeling access to low-level hardware inventory
/// data
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct Inventory;
pub const INVENTORY: Inventory = Inventory {};

impl oso::PolarClass for Inventory {
    fn get_polar_class_builder() -> oso::ClassBuilder<Self> {
        oso::Class::builder()
            .with_equality_check()
            .add_method(
                "has_role",
                |_: &Inventory, _actor: AuthenticatedActor, _role: String| {
                    false
                },
            )
            .add_attribute_getter("fleet", |_| FLEET)
    }
}

impl AuthorizedResource for Inventory {
    fn load_roles<'fut>(
        &'fut self,
        opctx: &'fut OpContext,
        authn: &'fut authn::Context,
        roleset: &'fut mut RoleSet,
    ) -> futures::future::BoxFuture<'fut, Result<(), Error>> {
        load_roles_for_resource_tree(&FLEET, opctx, authn, roleset).boxed()
    }

    fn on_unauthorized(
        &self,
        _: &Authz,
        error: Error,
        _: AnyActor,
        _: Action,
    ) -> Error {
        error
    }

    fn polar_class(&self) -> oso::Class {
        Self::get_polar_class()
    }
}
----

**In nexus/auth/src/authz/omicron.polar:**

[source,polar]
----
resource Inventory {
    permissions = [ "read", "modify" ];
    relations = { parent_fleet: Fleet };
    "read" if "viewer" on "parent_fleet";
    "modify" if "admin" on "parent_fleet";
}
has_relation(fleet: Fleet, "parent_fleet", inventory: Inventory)
    if inventory.fleet = fleet;
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `classes` array in `make_omicron_oso()`:

[source,rust]
----
let classes = [
    // ... existing classes ...
    Inventory::get_polar_class(),
    // ... more classes ...
];
----

**In nexus/db-queries/src/policy_test/resources.rs,** add to `make_resources()`:

[source,rust]
----
builder.new_resource(authz::INVENTORY);
----

==== Example: SiloCertificateList (static child resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
/// Synthetic resource describing the list of Certificates associated with a
/// Silo
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SiloCertificateList(Silo);

impl SiloCertificateList {
    pub fn new(silo: Silo) -> SiloCertificateList {
        SiloCertificateList(silo)
    }

    pub fn silo(&self) -> &Silo {
        &self.0
    }
}

impl oso::PolarClass for SiloCertificateList {
    fn get_polar_class_builder() -> oso::ClassBuilder<Self> {
        oso::Class::builder()
            .with_equality_check()
            .add_attribute_getter("silo", |list: &SiloCertificateList| {
                list.0.clone()
            })
    }
}

impl AuthorizedResource for SiloCertificateList {
    fn load_roles<'fut>(
        &'fut self,
        opctx: &'fut OpContext,
        authn: &'fut authn::Context,
        roleset: &'fut mut RoleSet,
    ) -> futures::future::BoxFuture<'fut, Result<(), Error>> {
        self.silo().load_roles(opctx, authn, roleset)
    }

    fn on_unauthorized(
        &self,
        _: &Authz,
        error: Error,
        _: AnyActor,
        _: Action,
    ) -> Error {
        error
    }

    fn polar_class(&self) -> oso::Class {
        Self::get_polar_class()
    }
}
----

**In nexus/auth/src/authz/omicron.polar:**

[source,polar]
----
resource SiloCertificateList {
    permissions = [ "list_children", "create_child" ];

    relations = { parent_silo: Silo, parent_fleet: Fleet };

    "list_children" if "admin" on "parent_silo";
    "list_children" if "admin" on "parent_fleet";
    "create_child" if "admin" on "parent_silo";
    "create_child" if "admin" on "parent_fleet";
}

has_relation(silo: Silo, "parent_silo", collection: SiloCertificateList)
    if collection.silo = silo;
has_relation(fleet: Fleet, "parent_fleet", collection: SiloCertificateList)
    if collection.silo.fleet = fleet;
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `classes` array in `make_omicron_oso()`:

[source,rust]
----
let classes = [
    // ... existing classes ...
    SiloCertificateList::get_polar_class(),
    // ... more classes ...
];
----

**In nexus/db-queries/src/policy_test/resources.rs,** instantiate in the parent's helper function:

[source,rust]
----
async fn make_silo(/* ... */) {
    let silo = authz::Silo::new(/* ... */);
    // ...
    builder.new_resource(authz::SiloCertificateList::new(silo.clone()));
}
----

==== App Layer Usage

For static top-level resources, use the global constant directly:

[source,rust]
----
// Authorize the action on the global resource
opctx.authorize(authz::Action::Modify, &authz::INVENTORY).await?;
----

For static child resources, construct the collection by hand after looking up the parent:

[source,rust]
----
use nexus_db_queries::db::lookup::LookupPath;

let (.., authz_silo) = LookupPath::new(&opctx, &datastore)
    .silo_id(silo_id)
    .fetch()
    .await?;

// Construct the collection resource manually
let authz_cert_list = authz::SiloCertificateList::new(authz_silo);

opctx.authorize(authz::Action::CreateChild, &authz_cert_list).await?;
----

== Supporting roles on resources

**Roles** are constructs within our policy.  We say that Fleet, Silo, and Project each have a handful of roles (like `viewer`, `collaborator`, and `admin`).  Permissions in our system flow from those roles.  Although the authz system supports dozens of different resources, authz checks ultimately boil down to checking whether a user has one of a few roles on these three resources.

Most of the time when you're adding a new resource, you'll define the policy for that resource in terms of these existing roles and you can ignore this whole section.

**1. Define the roles enum** in `nexus/types/src/external_api/shared.rs`:

[source,rust]
----
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Display,
    EnumIter,
    Eq,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
)]
#[serde(rename_all = "snake_case")]
pub enum YourResourceRole {
    Admin,
    Collaborator,
    Viewer,
}

impl DatabaseString for YourResourceRole {
    type SqlType = YourResourceRoleEnum;
}
----

**2. Add the SQL enum type** in `nexus/db-model/src/schema_versions.rs` (follow the pattern for existing role enums).

**3. Set `roles_allowed = true`** in your `authz_resource!` invocation:

[source,rust]
----
authz_resource! {
    name = "YourResource",
    parent = "Fleet",
    primary_key = Uuid,
    roles_allowed = true,
    polar_snippet = Custom,  // Usually need custom policy for resources with roles
}
----

**4. Implement `ApiResourceWithRolesType`:**

[source,rust]
----
impl ApiResourceWithRolesType for YourResource {
    type AllowedRoles = YourResourceRole;
}
----

**5. Define custom Polar policy** in `omicron.polar` that defines the roles and their permissions. See `Project` or `Silo` for examples.

== Authz at the HTTP, App, and Datastore Layers

=== HTTP Layer

This layer generally accepts raw identifiers (UUID or name) from the user:

[source,rust]
----
#[endpoint {
    method = GET,
    path = "/v1/disks/{disk}",
}]
async fn disk_view(
    rqctx: RequestContext<Arc<ServerContext>>,
    path_params: Path<params::DiskPath>,
) -> Result<HttpResponseOk<views::Disk>, HttpError> {
    // ...
}
----

=== App Layer

The details of authz at the app layer depend on the kind of resource.  See the section above.

In the end, though, you'll wind up having resolved the user-provided identifier to an `authz` object that can be used for doing authz checks.

=== Performing Authorization Checks

Once you have the authz type (from LookupPath, a global constant, or a hand-constructed object based on one of those), you can check authorization using something like:

[source,rust]
----
opctx.authorize(authz::Action::Read, &authz_disk).await?;
let disk = datastore.disk_fetch(&opctx, &authz_disk).await?;
----

Available actions include: `Read`, `Modify`, `Delete`, `ListChildren`, `CreateChild`.

Generally, authz checks should be performed as close as possible to the code that takes the action. This ensures that authz checks cannot be accidentally separated from the action they protect (leaving some code paths unchecked). For example, if you have a datastore function that modifies a resource, that function should do the authz check.  More in the next section.

=== Datastore Layer

Datastore functions accept authz types, not raw UUIDs. This provides the context needed to perform authz checks.

[source,rust]
----
impl DataStore {
    pub async fn disk_fetch(
        &self,
        opctx: &OpContext,
        authz_disk: &authz::Disk,
    ) -> Result<db::model::Disk, Error> {
        let disk_id = authz_disk.id();
        // ... query database ...
    }

    pub async fn disk_create(
        &self,
        opctx: &OpContext,
        authz_project: &authz::Project,  // Parent resource
        disk: db::model::Disk,
    ) -> Result<db::model::Disk, Error> {
        opctx.authorize(authz::Action::CreateChild, authz_project).await?;
        // ... insert into database ...
    }
}
----

== Primary Key Variants

=== Typed UUIDs (Recommended)

New code should use typed UUIDs for type safety:

[source,rust]
----
authz_resource! {
    name = "SiloUser",
    parent = "Silo",
    primary_key = { uuid_kind = SiloUserKind },
    roles_allowed = false,
    polar_snippet = Custom,
}
----

=== Plain UUID

For resources that haven't migrated to typed UUIDs yet:

[source,rust]
----
authz_resource! {
    name = "Disk",
    parent = "Project",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectLimited,
}
----

=== Other Key Types

For resources with non-UUID keys:

[source,rust]
----
authz_resource! {
    name = "DeviceAuthRequest",
    parent = "Fleet",
    primary_key = String,  // user_code
    roles_allowed = false,
    polar_snippet = FleetChild,
}
----

== Testing

After implementing authz:

**Run the policy test:**
[source,shell]
----
cargo nextest run -p nexus-db-queries test_policy
----

This verifies all authz types are registered and tests permissions exhaustively.

**Run integration tests** for your endpoints, verifying:
* Unauthorized users get 403/404 errors appropriately
* Authorized users can perform allowed operations
* Users can't exceed their permissions

== Key Files

* `nexus/auth/src/authz/mod.rs` - Overview of authz subsystem
* `nexus/auth/src/authz/api_resources.rs` - Authz type definitions
* `nexus/auth/src/authz/omicron.polar` - Polar policy rules
* `nexus/auth/src/authz/oso_generic.rs` - Oso initialization
* `nexus/authz-macros/src/lib.rs` - `authz_resource!` macro
* `nexus/db-queries/src/policy_test/resources.rs` - Policy test setup
* `nexus/db-queries/src/db/lookup.rs` - LookupPath implementation
* `nexus/types/src/external_api/shared.rs` - Role enum definitions

== Summary

To add authz for a new resource:

1. Identify which category your resource falls into (static or dynamic)
2. Follow the example for that category
3. For dynamic resources, choose the appropriate `polar_snippet` based on where the resource lives
4. Register with Oso in `oso_generic.rs`
5. Add to policy tests in `policy_test/resources.rs`
6. Integrate into request flow: HTTP → LookupPath → authorize → datastore
7. Test with `cargo nextest run -p nexus-db-queries test_policy`
