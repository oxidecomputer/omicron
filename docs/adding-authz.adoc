= Adding Authorization for Resources
:toc: left
:toclevels: 3

== Overview

This document explains how to add authorization (authz) support for new resources in Nexus. Authorization is based on role-based access control (RBAC) using the Oso policy engine.

== Principles

Before implementing authz for a new resource, read the module comments in `nexus/auth/src/authz/mod.rs` and `nexus/auth/src/authz/api_resources.rs` to understand the basic concepts.

The most important thing to know is that every authz check we have today boils down to asking:

* is this **actor** (a silo user or internal system user)
* allowed to perform this **action**
* on this **resource**

It usually looks like this:

```rust
opctx.authorize(authz::Action::Modify, &authz::INVENTORY)
```

Here:

- `opctx` is ubiquitous in Nexus.  Constructing it requires authenticating the user and it describes the actor for this check.
- `authz::Action` is an enum with just a handful of standard actions.
- `authz::Inventory` is the resource.  It's an **authz object**.

=== Avoid Baking Policy Into Authz Checks

This is important and non-obvious. It's tempting to take shortcuts like: "people can operate on my thing if they can operate on the Fleet." Instead, prefer creating a synthetic resource whose *policy* (in the Polar file) reflects that equivalence, while the authz check itself is almost a literal translation of the action you're taking: "I'm modifying the inventory, so I check if the user can perform the `modify` action on the `inventory` resource."

For example, rather than checking Fleet authorization when modifying inventory, we define an `Inventory` resource whose Polar policy says that Fleet admins have modify permissions on Inventory. The code just checks `authorize(Action::Modify, &INVENTORY)` without knowing anything about the Fleet.

This separation keeps policy decisions in the Polar file where they belong, making the system easier to understand and modify.

=== Authz Checks Should Be Close to the Action

Perform authorization checks as close as possible to the code that takes the action. This ensures that authz checks cannot be accidentally separated from the operation they protect. For example, if you have a datastore function that modifies a resource, that function should accept the authz type and perform the authorization check, rather than expecting the caller to have done it.


Resources fall into three categories, each with a different implementation pattern. This document provides complete examples for each category that you can adapt for your resource.

== Static Resources

Singleton resources representing system-wide concepts or synthetic collections. These are almost always synthetic resources that don't correspond to database entities.

**Static top-level examples:** `Fleet`, `Inventory`, `DnsConfig`, `BlueprintConfig`, `QuiesceState`, `AuditLog`, `IpPoolList`, `DeviceAuthRequestList`

**Static child examples:** `SiloCertificateList`, `SiloUserList`, `SiloGroupList`, `SiloIdentityProviderList`, `VpcList`

=== Example: Inventory (static top-level resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
/// Synthetic resource used for modeling access to low-level hardware inventory
/// data
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct Inventory;
pub const INVENTORY: Inventory = Inventory {};

impl oso::PolarClass for Inventory {
    fn get_polar_class_builder() -> oso::ClassBuilder<Self> {
        oso::Class::builder()
            .with_equality_check()
            .add_method(
                "has_role",
                |_: &Inventory, _actor: AuthenticatedActor, _role: String| {
                    false
                },
            )
            .add_attribute_getter("fleet", |_| FLEET)
    }
}

impl AuthorizedResource for Inventory {
    fn load_roles<'fut>(
        &'fut self,
        opctx: &'fut OpContext,
        authn: &'fut authn::Context,
        roleset: &'fut mut RoleSet,
    ) -> futures::future::BoxFuture<'fut, Result<(), Error>> {
        load_roles_for_resource_tree(&FLEET, opctx, authn, roleset).boxed()
    }

    fn on_unauthorized(
        &self,
        _: &Authz,
        error: Error,
        _: AnyActor,
        _: Action,
    ) -> Error {
        error
    }

    fn polar_class(&self) -> oso::Class {
        Self::get_polar_class()
    }
}
----

**In nexus/auth/src/authz/omicron.polar:**

[source,polar]
----
resource Inventory {
    permissions = [ "read", "modify" ];
    relations = { parent_fleet: Fleet };
    "read" if "viewer" on "parent_fleet";
    "modify" if "admin" on "parent_fleet";
}
has_relation(fleet: Fleet, "parent_fleet", inventory: Inventory)
    if inventory.fleet = fleet;
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `classes` array in `make_omicron_oso()`:

[source,rust]
----
let classes = [
    // ... existing classes ...
    Inventory::get_polar_class(),
    // ... more classes ...
];
----

**In nexus/db-queries/src/policy_test/resources.rs,** add to `make_resources()`:

[source,rust]
----
builder.new_resource(authz::INVENTORY);
----

=== Example: SiloCertificateList (static child resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
/// Synthetic resource describing the list of Certificates associated with a
/// Silo
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SiloCertificateList(Silo);

impl SiloCertificateList {
    pub fn new(silo: Silo) -> SiloCertificateList {
        SiloCertificateList(silo)
    }

    pub fn silo(&self) -> &Silo {
        &self.0
    }
}

impl oso::PolarClass for SiloCertificateList {
    fn get_polar_class_builder() -> oso::ClassBuilder<Self> {
        oso::Class::builder()
            .with_equality_check()
            .add_attribute_getter("silo", |list: &SiloCertificateList| {
                list.0.clone()
            })
    }
}

impl AuthorizedResource for SiloCertificateList {
    fn load_roles<'fut>(
        &'fut self,
        opctx: &'fut OpContext,
        authn: &'fut authn::Context,
        roleset: &'fut mut RoleSet,
    ) -> futures::future::BoxFuture<'fut, Result<(), Error>> {
        self.silo().load_roles(opctx, authn, roleset)
    }

    fn on_unauthorized(
        &self,
        _: &Authz,
        error: Error,
        _: AnyActor,
        _: Action,
    ) -> Error {
        error
    }

    fn polar_class(&self) -> oso::Class {
        Self::get_polar_class()
    }
}
----

**In nexus/auth/src/authz/omicron.polar:**

[source,polar]
----
resource SiloCertificateList {
    permissions = [ "list_children", "create_child" ];

    relations = { parent_silo: Silo, parent_fleet: Fleet };

    "list_children" if "admin" on "parent_silo";
    "list_children" if "admin" on "parent_fleet";
    "create_child" if "admin" on "parent_silo";
    "create_child" if "admin" on "parent_fleet";
}

has_relation(silo: Silo, "parent_silo", collection: SiloCertificateList)
    if collection.silo = silo;
has_relation(fleet: Fleet, "parent_fleet", collection: SiloCertificateList)
    if collection.silo.fleet = fleet;
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `classes` array in `make_omicron_oso()`:

[source,rust]
----
let classes = [
    // ... existing classes ...
    SiloCertificateList::get_polar_class(),
    // ... more classes ...
];
----

**In nexus/db-queries/src/policy_test/resources.rs,** instantiate in the parent's helper function:

[source,rust]
----
async fn make_silo(/* ... */) {
    let silo = authz::Silo::new(/* ... */);
    // ...
    builder.new_resource(authz::SiloCertificateList::new(silo.clone()));
}
----

=== App Layer Usage

For static top-level resources, use the global constant directly:

[source,rust]
----
// Authorize the action on the global resource
opctx.authorize(authz::Action::Modify, &authz::INVENTORY).await?;
----

For static child resources, construct the collection by hand after looking up the parent:

[source,rust]
----
use nexus_db_queries::db::lookup::LookupPath;

let (.., authz_silo) = LookupPath::new(&opctx, &datastore)
    .silo_id(silo_id)
    .fetch()
    .await?;

// Construct the collection resource manually
let authz_cert_list = authz::SiloCertificateList::new(authz_silo);

opctx.authorize(authz::Action::CreateChild, &authz_cert_list).await?;
----

== Dynamic Resources

Resources with multiple instances that correspond to database entities. This is the most common case.

All dynamic resources use the `authz_resource!` macro. The key difference is which `polar_snippet` you choose based on where the resource lives in the hierarchy.

**Examples by polar_snippet:**

* `FleetChild`: `IpPool`, `Rack`, `Sled`, `Blueprint`, `AddressLot`, `SwitchPort`, `Service`
* `InProjectLimited`: `Disk`, `Instance`, `Snapshot`, `ProjectImage`, `FloatingIp`, `AffinityGroup`
* `InProjectFull`: `Vpc`, `VpcSubnet`, `VpcRouter`, `RouterRoute`, `InternetGateway`, `ExternalSubnet`
* `InSilo`: `SiloImage`, `Image`
* `Custom`: `Silo`, `Project`, `SshKey`, `Certificate`, `SiloUser`, `IdentityProvider`, `MulticastGroup`

=== Example: IpPool (fleet-level resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "IpPool",
    parent = "Fleet",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = FleetChild,
}
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `generated_inits` array in `make_omicron_oso()`:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    IpPool::init(),
    // ... more resources ...
];

for init in generated_inits {
    oso_builder = oso_builder.register_class_with_snippet(init)?;
}
----

**In nexus/db-queries/src/policy_test/resources.rs,** add test instances.

=== Example: Disk (project compute resource)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "Disk",
    parent = "Project",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectLimited,
}
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `generated_inits` array:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    Disk::init(),
    // ... more resources ...
];

for init in generated_inits {
    oso_builder = oso_builder.register_class_with_snippet(init)?;
}
----

**In nexus/db-queries/src/policy_test/resources.rs,** add instances in the parent's helper:

[source,rust]
----
async fn make_project(/* ... */) {
    let project = authz::Project::new(/* ... */);
    // ...
    builder.new_resource(authz::Disk::new(
        project.clone(),
        Uuid::new_v4(),
        LookupType::ByName(format!("{}-disk1", project_name)),
    ));
}
----

=== Example: VpcSubnet (project networking resource, nested under Vpc)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "VpcSubnet",
    parent = "Vpc",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectFull,
}
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `generated_inits` array:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    VpcSubnet::init(),
    // ... more resources ...
];

for init in generated_inits {
    oso_builder = oso_builder.register_class_with_snippet(init)?;
}
----

**In nexus/db-queries/src/policy_test/resources.rs,** add instances in the parent's helper.

=== Choosing the Right Polar Snippet

The `polar_snippet` parameter controls what Polar policy is generated:

* `FleetChild`: For fleet-level resources. Grants `read` and `list_children` to `fleet.viewer`, and `modify` and `create_child` to `fleet.admin`.
* `InSilo`: For Silo-scoped resources. Grants permissions based on Silo roles.
* `InProjectLimited`: For Project compute resources (instances, disks, snapshots, images, floating IPs). Users with `limited-collaborator` can create and modify these.
* `InProjectFull`: For Project networking infrastructure (VPCs, subnets, routers, internet gateways). Requires full `collaborator` role.
* `Custom`: No generated policy. You write the entire Polar policy manually in `omicron.polar`. See `Silo`, `Project`, `SshKey`, or `Certificate` for examples.

The distinction between `InProjectLimited` and `InProjectFull` allows organizations to give users access to compute resources while restricting who can reconfigure networking.

=== App Layer Usage

For dynamic resources, use `LookupPath` to look up the resource:

[source,rust]
----
use nexus_db_queries::db::lookup::LookupPath;

// Top-level resource
let (.., authz_ip_pool) = LookupPath::new(&opctx, &datastore)
    .ip_pool_id(pool_id)
    .fetch()
    .await?;

opctx.authorize(authz::Action::Read, &authz_ip_pool).await?;

// Nested resource
let (.., authz_disk) = LookupPath::new(&opctx, &datastore)
    .disk_id(disk_id)
    .fetch()
    .await?;

opctx.authorize(authz::Action::Read, &authz_disk).await?;

// Multi-level nested resource
let (.., authz_subnet) = LookupPath::new(&opctx, &datastore)
    .project_id(project_id)
    .vpc_id(vpc_id)
    .vpc_subnet_id(subnet_id)
    .fetch()
    .await?;

opctx.authorize(authz::Action::Modify, &authz_subnet).await?;
----

== Supporting Role Assignments

Most resources do not support role assignments directly. Roles are typically assigned only to high-level resources like Fleet, Silo, and Project. If your resource needs to support role assignments:

=== Steps

**1. Define the roles enum** in `nexus/types/src/external_api/shared.rs`:

[source,rust]
----
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Display,
    EnumIter,
    Eq,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
)]
#[serde(rename_all = "snake_case")]
pub enum YourResourceRole {
    Admin,
    Collaborator,
    Viewer,
}

impl DatabaseString for YourResourceRole {
    type SqlType = YourResourceRoleEnum;
}
----

**2. Add the SQL enum type** in `nexus/db-model/src/schema_versions.rs` (follow the pattern for existing role enums).

**3. Set `roles_allowed = true`** in your `authz_resource!` invocation:

[source,rust]
----
authz_resource! {
    name = "YourResource",
    parent = "Fleet",
    primary_key = Uuid,
    roles_allowed = true,
    polar_snippet = Custom,  // Usually need custom policy for resources with roles
}
----

**4. Implement `ApiResourceWithRolesType`:**

[source,rust]
----
impl ApiResourceWithRolesType for YourResource {
    type AllowedRoles = YourResourceRole;
}
----

**5. Define custom Polar policy** in `omicron.polar` that defines the roles and their permissions. See `Project` or `Silo` for examples.

== HTTP and Datastore Integration

=== HTTP Layer

Accept raw identifiers (UUID or name) from the user:

[source,rust]
----
#[endpoint {
    method = GET,
    path = "/v1/disks/{disk}",
}]
async fn disk_view(
    rqctx: RequestContext<Arc<ServerContext>>,
    path_params: Path<params::DiskPath>,
) -> Result<HttpResponseOk<views::Disk>, HttpError> {
    // ...
}
----

=== Performing Authorization

Once you have the authz type (from LookupPath or a global constant), check authorization before proceeding:

[source,rust]
----
opctx.authorize(authz::Action::Read, &authz_disk).await?;
let disk = datastore.disk_fetch(&opctx, &authz_disk).await?;
----

Common actions: `Read`, `Modify`, `Delete`, `ListChildren`, `CreateChild`.

=== Datastore Layer

Datastore functions accept authz types, not raw UUIDs. This ensures the resource has been looked up and basic authz checks have been done:

[source,rust]
----
impl DataStore {
    pub async fn disk_fetch(
        &self,
        opctx: &OpContext,
        authz_disk: &authz::Disk,
    ) -> Result<db::model::Disk, Error> {
        let disk_id = authz_disk.id();
        // ... query database ...
    }

    pub async fn disk_create(
        &self,
        opctx: &OpContext,
        authz_project: &authz::Project,  // Parent resource
        disk: db::model::Disk,
    ) -> Result<db::model::Disk, Error> {
        opctx.authorize(authz::Action::CreateChild, authz_project).await?;
        // ... insert into database ...
    }
}
----

== Primary Key Variants

=== Typed UUIDs (Recommended)

New code should use typed UUIDs for type safety:

[source,rust]
----
authz_resource! {
    name = "SiloUser",
    parent = "Silo",
    primary_key = { uuid_kind = SiloUserKind },
    roles_allowed = false,
    polar_snippet = Custom,
}
----

=== Plain UUID

For resources that haven't migrated to typed UUIDs yet:

[source,rust]
----
authz_resource! {
    name = "Disk",
    parent = "Project",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectLimited,
}
----

=== Other Key Types

For resources with non-UUID keys:

[source,rust]
----
authz_resource! {
    name = "DeviceAuthRequest",
    parent = "Fleet",
    primary_key = String,  // user_code
    roles_allowed = false,
    polar_snippet = FleetChild,
}
----

== Testing

After implementing authz:

**Run the policy test:**
[source,shell]
----
cargo nextest run -p nexus-db-queries test_policy
----

This verifies all authz types are registered and tests permissions exhaustively.

**Run integration tests** for your endpoints, verifying:
* Unauthorized users get 403/404 errors appropriately
* Authorized users can perform allowed operations
* Users can't exceed their permissions

== Key Files

* `nexus/auth/src/authz/mod.rs` - Overview of authz subsystem
* `nexus/auth/src/authz/api_resources.rs` - Authz type definitions
* `nexus/auth/src/authz/omicron.polar` - Polar policy rules
* `nexus/auth/src/authz/oso_generic.rs` - Oso initialization
* `nexus/authz-macros/src/lib.rs` - `authz_resource!` macro
* `nexus/db-queries/src/policy_test/resources.rs` - Policy test setup
* `nexus/db-queries/src/db/lookup.rs` - LookupPath implementation
* `nexus/types/src/external_api/shared.rs` - Role enum definitions

== Summary

To add authz for a new resource:

1. Identify which category your resource falls into (static or dynamic)
2. Follow the example for that category
3. For dynamic resources, choose the appropriate `polar_snippet` based on where the resource lives
4. Register with Oso in `oso_generic.rs`
5. Add to policy tests in `policy_test/resources.rs`
6. Integrate into request flow: HTTP → LookupPath → authorize → datastore
7. Test with `cargo nextest run -p nexus-db-queries test_policy`
