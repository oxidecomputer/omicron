= Adding Authorization for Resources
:toc: left
:toclevels: 3

== Overview

This document explains how to add authorization (authz) support for new resources in Omicron. Authorization is based on role-based access control (RBAC) using the Oso policy engine.

Before implementing authz for a new resource, read the module comments in `nexus/auth/src/authz/mod.rs` and `nexus/auth/src/authz/api_resources.rs` to understand the basic concepts.

Resources fall into four categories, each with a different implementation pattern. This document provides complete examples for each category that you can adapt for your resource.

== Static Top-Level Resources

Singleton resources representing system-wide concepts. Examples: `Fleet`, `Inventory`, `DnsConfig`.

=== Example: Inventory

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
/// Synthetic resource used for modeling access to low-level hardware inventory
/// data
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct Inventory;
pub const INVENTORY: Inventory = Inventory {};

impl oso::PolarClass for Inventory {
    fn get_polar_class_builder() -> oso::ClassBuilder<Self> {
        oso::Class::builder()
            .with_equality_check()
            .add_method(
                "has_role",
                |_: &Inventory, _actor: AuthenticatedActor, _role: String| {
                    false
                },
            )
            .add_attribute_getter("fleet", |_| FLEET)
    }
}

impl AuthorizedResource for Inventory {
    fn load_roles<'fut>(
        &'fut self,
        opctx: &'fut OpContext,
        authn: &'fut authn::Context,
        roleset: &'fut mut RoleSet,
    ) -> futures::future::BoxFuture<'fut, Result<(), Error>> {
        load_roles_for_resource_tree(&FLEET, opctx, authn, roleset).boxed()
    }

    fn on_unauthorized(
        &self,
        _: &Authz,
        error: Error,
        _: AnyActor,
        _: Action,
    ) -> Error {
        error
    }

    fn polar_class(&self) -> oso::Class {
        Self::get_polar_class()
    }
}
----

**In nexus/auth/src/authz/omicron.polar:**

[source,polar]
----
resource Inventory {
    permissions = [ "read", "modify" ];
    relations = { parent_fleet: Fleet };
    "read" if "viewer" on "parent_fleet";
    "modify" if "admin" on "parent_fleet";
}
has_relation(fleet: Fleet, "parent_fleet", inventory: Inventory)
    if inventory.fleet = fleet;
----

**In nexus/auth/src/authz/oso_generic.rs,** add to the `classes` array in `make_omicron_oso()`:

[source,rust]
----
let classes = [
    // ... existing classes ...
    Inventory::get_polar_class(),
];
----

**In nexus/db-queries/src/policy_test/resources.rs,** add to `make_resources()`:

[source,rust]
----
builder.new_resource(authz::INVENTORY);
----

== Dynamic Top-Level Resources

Resources where multiple instances exist at the top level. Examples: `Silo`, `IpPool`.

=== Example: IpPool (using authz_resource! macro)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "IpPool",
    parent = "Fleet",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = FleetChild,
}
----

This generates the struct definition, `PolarClass` impl, and `ApiResource` impl. The `FleetChild` snippet generates Polar policy that grants `read` and `list_children` to `fleet.viewer`, and `modify` and `create_child` to `fleet.admin`.

**In nexus/auth/src/authz/oso_generic.rs,** add to the `generated_inits` array in `make_omicron_oso()`:

[source,rust]
----
let generated_inits = [
    // ... existing resources ...
    IpPool::init(),
];
----

**In nexus/db-queries/src/policy_test/resources.rs,** add instances to test (typically in a helper function or directly in `make_resources()`).

=== Polar Snippet Options

The `polar_snippet` parameter controls what Polar policy is generated:

* `FleetChild`: For fleet-level resources. Grants viewer/admin permissions based on Fleet roles.
* `InSilo`: For Silo-scoped resources. Grants permissions based on Silo roles.
* `InProjectLimited`: For Project resources accessible to `limited-collaborator` (compute resources like instances, disks).
* `InProjectFull`: For Project resources requiring full `collaborator` role (networking resources like VPCs, routers).
* `Custom`: No generated policy. You write the entire Polar policy manually in `omicron.polar`. See `Silo`, `Project`, `SshKey`, or `Certificate` for examples of custom policies.

== Static Child Resources

Synthetic collection resources that don't exist as separate database entities. Examples: `SiloCertificateList`, `VpcList`.

=== Example: SiloCertificateList

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
/// Synthetic resource describing the list of Certificates associated with a
/// Silo
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct SiloCertificateList(Silo);

impl SiloCertificateList {
    pub fn new(silo: Silo) -> SiloCertificateList {
        SiloCertificateList(silo)
    }

    pub fn silo(&self) -> &Silo {
        &self.0
    }
}

impl oso::PolarClass for SiloCertificateList {
    fn get_polar_class_builder() -> oso::ClassBuilder<Self> {
        oso::Class::builder()
            .with_equality_check()
            .add_attribute_getter("silo", |list: &SiloCertificateList| {
                list.0.clone()
            })
    }
}

impl AuthorizedResource for SiloCertificateList {
    fn load_roles<'fut>(
        &'fut self,
        opctx: &'fut OpContext,
        authn: &'fut authn::Context,
        roleset: &'fut mut RoleSet,
    ) -> futures::future::BoxFuture<'fut, Result<(), Error>> {
        self.silo().load_roles(opctx, authn, roleset)
    }

    fn on_unauthorized(
        &self,
        _: &Authz,
        error: Error,
        _: AnyActor,
        _: Action,
    ) -> Error {
        error
    }

    fn polar_class(&self) -> oso::Class {
        Self::get_polar_class()
    }
}
----

**In nexus/auth/src/authz/omicron.polar:**

[source,polar]
----
resource SiloCertificateList {
    permissions = [ "list_children", "create_child" ];

    relations = { parent_silo: Silo, parent_fleet: Fleet };

    "list_children" if "admin" on "parent_silo";
    "list_children" if "admin" on "parent_fleet";
    "create_child" if "admin" on "parent_silo";
    "create_child" if "admin" on "parent_fleet";
}

has_relation(silo: Silo, "parent_silo", collection: SiloCertificateList)
    if collection.silo = silo;
has_relation(fleet: Fleet, "parent_fleet", collection: SiloCertificateList)
    if collection.silo.fleet = fleet;
----

**In oso_generic.rs,** add to `classes` array.

**In policy_test/resources.rs,** instantiate in the parent's helper function:

[source,rust]
----
async fn make_silo(/* ... */) {
    let silo = authz::Silo::new(/* ... */);
    // ...
    builder.new_resource(authz::SiloCertificateList::new(silo.clone()));
}
----

== Dynamic Nested Resources

Resources with multiple instances nested under other resources. This is the most common case. Examples: `Disk` under `Project`, `VpcSubnet` under `Vpc`.

=== Example: Disk (under Project)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "Disk",
    parent = "Project",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectLimited,
}
----

The `InProjectLimited` snippet generates Polar policy granting permissions based on Project roles, where `limited-collaborator` is sufficient.

**In oso_generic.rs,** add to `generated_inits` array.

**In policy_test/resources.rs,** add instances in the parent's helper:

[source,rust]
----
async fn make_project(/* ... */) {
    let project = authz::Project::new(/* ... */);
    // ...
    builder.new_resource(authz::Disk::new(
        project.clone(),
        Uuid::new_v4(),
        LookupType::ByName(format!("{}-disk1", project_name)),
    ));
}
----

=== Example: VpcSubnet (under Vpc, two levels below Project)

**In nexus/auth/src/authz/api_resources.rs:**

[source,rust]
----
authz_resource! {
    name = "VpcSubnet",
    parent = "Vpc",
    primary_key = Uuid,
    roles_allowed = false,
    polar_snippet = InProjectFull,
}
----

The `InProjectFull` snippet generates Polar policy that traces back to the containing Project, requiring full `collaborator` role. The macro handles multi-level nesting automatically.

**Follow the same registration steps as Disk.**

=== Choosing InProjectLimited vs InProjectFull

* `InProjectLimited`: For compute resources (instances, disks, snapshots, images, floating IPs). Users with `limited-collaborator` can create and modify these.
* `InProjectFull`: For networking infrastructure (VPCs, subnets, routers, internet gateways). Requires full `collaborator` role.

This distinction allows organizations to give users access to compute resources while restricting who can reconfigure networking.

== Supporting Role Assignments

Most resources do not support role assignments directly. Roles are typically assigned only to high-level resources like Fleet, Silo, and Project. If your resource needs to support role assignments:

=== Steps

**1. Define the roles enum** in `nexus/types/src/external_api/shared.rs`:

[source,rust]
----
#[derive(
    Clone,
    Copy,
    Debug,
    Deserialize,
    Display,
    EnumIter,
    Eq,
    Ord,
    PartialEq,
    PartialOrd,
    Serialize,
)]
#[serde(rename_all = "snake_case")]
pub enum YourResourceRole {
    Admin,
    Collaborator,
    Viewer,
}

impl DatabaseString for YourResourceRole {
    type SqlType = YourResourceRoleEnum;
}
----

**2. Add the SQL enum type** in `nexus/db-model/src/schema_versions.rs` (follow the pattern for existing role enums).

**3. Set `roles_allowed = true`** in your `authz_resource!` invocation:

[source,rust]
----
authz_resource! {
    name = "YourResource",
    parent = "Fleet",
    primary_key = Uuid,
    roles_allowed = true,
    polar_snippet = Custom,  // Usually need custom policy for resources with roles
}
----

**4. Implement `ApiResourceWithRolesType`:**

[source,rust]
----
impl ApiResourceWithRolesType for YourResource {
    type AllowedRoles = YourResourceRole;
}
----

**5. Define custom Polar policy** in `omicron.polar` that defines the roles and their permissions. See `Project` or `Silo` for examples.

== HTTP, App, and Datastore Integration

=== HTTP Layer

Accept raw identifiers (UUID or name) from the user:

[source,rust]
----
#[endpoint {
    method = GET,
    path = "/v1/disks/{disk}",
}]
async fn disk_view(
    rqctx: RequestContext<Arc<ServerContext>>,
    path_params: Path<params::DiskPath>,
) -> Result<HttpResponseOk<views::Disk>, HttpError> {
    // ...
}
----

=== App Layer: LookupPath

Use `LookupPath` to convert raw identifiers into authz types:

[source,rust]
----
use nexus_db_queries::db::lookup::LookupPath;

// Simple lookup
let (.., authz_disk) = LookupPath::new(&opctx, &datastore)
    .disk_id(disk_id)
    .fetch()
    .await?;

// Nested resource lookup
let (.., authz_subnet) = LookupPath::new(&opctx, &datastore)
    .project_id(project_id)
    .vpc_id(vpc_id)
    .vpc_subnet_id(subnet_id)
    .fetch()
    .await?;

// Synthetic resource - construct manually
let (.., authz_silo) = LookupPath::new(&opctx, &datastore)
    .silo_id(silo_id)
    .fetch()
    .await?;
let authz_cert_list = authz::SiloCertificateList::new(authz_silo);
----

=== Performing Authorization

Once you have the authz type, check authorization before proceeding:

[source,rust]
----
opctx.authorize(authz::Action::Read, &authz_disk).await?;
let disk = datastore.disk_fetch(&opctx, &authz_disk).await?;
----

Common actions: `Read`, `Modify`, `Delete`, `ListChildren`, `CreateChild`.

=== Datastore Layer

Datastore functions accept authz types, not raw UUIDs. This ensures the resource has been looked up and basic authz checks have been done:

[source,rust]
----
impl DataStore {
    pub async fn disk_fetch(
        &self,
        opctx: &OpContext,
        authz_disk: &authz::Disk,
    ) -> Result<db::model::Disk, Error> {
        let disk_id = authz_disk.id();
        // ... query database ...
    }

    pub async fn disk_create(
        &self,
        opctx: &OpContext,
        authz_project: &authz::Project,  // Parent resource
        disk: db::model::Disk,
    ) -> Result<db::model::Disk, Error> {
        opctx.authorize(authz::Action::CreateChild, authz_project).await?;
        // ... insert into database ...
    }
}
----

== Primary Key Variants

Most resources use `Uuid` as their primary key. Some variations:

=== Typed UUIDs

Use typed UUIDs for type safety:

[source,rust]
----
authz_resource! {
    name = "SiloUser",
    parent = "Silo",
    primary_key = { uuid_kind = SiloUserKind },
    roles_allowed = false,
    polar_snippet = Custom,
}
----

=== Composite Keys

For resources with composite keys:

[source,rust]
----
authz_resource! {
    name = "DeviceAuthRequest",
    parent = "Fleet",
    primary_key = String,  // user_code
    roles_allowed = false,
    polar_snippet = FleetChild,
}
----

== Testing

After implementing authz:

**1. Run the policy test:**
[source,shell]
----
cargo nextest run -p omicron-nexus policy
----

This verifies all authz types are registered and tests permissions exhaustively.

**2. Run integration tests** for your endpoints, verifying:
* Unauthorized users get 403/404 errors appropriately
* Authorized users can perform allowed operations
* Users can't exceed their permissions

**3. Check with clippy:**
[source,shell]
----
cargo xtask clippy
----

== Key Files

* `nexus/auth/src/authz/mod.rs` - Overview of authz subsystem
* `nexus/auth/src/authz/api_resources.rs` - Authz type definitions
* `nexus/auth/src/authz/omicron.polar` - Polar policy rules
* `nexus/auth/src/authz/oso_generic.rs` - Oso initialization
* `nexus/authz-macros/src/lib.rs` - `authz_resource!` macro
* `nexus/db-queries/src/policy_test/resources.rs` - Policy test setup
* `nexus/db-queries/src/db/lookup.rs` - LookupPath implementation
* `nexus/types/src/external_api/shared.rs` - Role enum definitions

== Summary

To add authz for a new resource:

1. Identify which category your resource falls into
2. Follow the example for that category
3. Register with Oso in `oso_generic.rs`
4. Add to policy tests in `policy_test/resources.rs`
5. Integrate into request flow: HTTP → LookupPath → authorize → datastore
6. Test with `cargo nextest run -p omicron-nexus policy`
