// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! # Alerts
//!
//! ## Dramatis Personae
//!
//! There are two central entities in our alerting system:
//!
//! + **Alert receivers** represent an external entity to which alerts are
//!   delivered, and the configuration associated with that entity.  An alert
//!   receiver [subscribes](#alert-subscriptions) to a set of alert classes to
//!   configure which alerts should be delivered to that receiver.  With the
//!   exception of the [`Alert`]s themselves, most other resources in the alert
//!   API are children of the [`AlertReceiver`] API resource.
//!
//!   Various mechanisms for delivering alerts are represented by "subtypes" of
//!   alert receivers.  At present, [webhooks](super::webhook) are the only
//!   such subtype.  Different subtypes of alert receivers are created and
//!   modified by separate APIs for that particular type of receiver, as
//!   different configuration options exist based on the receiver type.
//!   However, some operations, such as listing receivers, viewing or
//!   deleting a receiver, adding and removing subscriptions, and resending an
//!   alert, are common to all receiver types.
//!
//! + **Alerts** represent events in the system for which an alert
//!   notifications are generated and sent to receivers.  The control plane
//!   calls the [`Nexus::alert_publish`] method to record a new event
//!   and publish it to receivers.
//!
//!   Alerts are categorized into [alert classes], as described in RFD
//!   538.  Receivers *subscribe* to these classes, indicating that they wish to
//!   when an event with a particular class occurs.
//!
//! Two background tasks implement the reliable persistent workflow of
//! determining what events should be sent to what receiver, and performing the
//! actual HTTP requests to send the alert to the receiver:
//!
//! + The `alert_dispatcher` task is responsible for *dispatching* alerts to
//!   receivers.  For each event that has not yet been dispatched, the task
//!   queries the database for alert receivers that have subscribed to that
//!   alert, and creates a *delivery record* in appropriate delivery table,
//!   indicating that the alert should be sent to that receiver.
//!
//! + The `webhook_deliverator`[^1] task reads webhook delivery records and
//!   sends HTTP requests to webhook receiver endpoint for each webhook
//!   delivery that is currently in flight.  The deliverator is responsible
//!   for recording the status of each *delivery attempt*.  Retries and retry
//!   backoff are the responsibility of the deliverator.
//!
//!   In the future, other delivery mechanisms may be implemented by their own
//!   deliverator background tasks, similarly to webhooks.  Each delivery
//!   mechanism will operate on its own delivery table, as different delivery
//!   mechanisms may need to record different state associated with a delivery.
//!
//! ## Alert Subscriptions
//!
//! A receiver's subscriptions take one of two forms:
//!
//! + **Exact** subscriptions are when a receiver subscribes to a specific alert
//!   class string.  These are represented by entries in the
//!   `alert_subscription` table in CockroachDB.
//!
//! + **Glob** subscriptions include wildcard segments that may match multiple
//!   values.  The globbing syntax is discussed in greater detail in RFD 538.
//!
//! We implement glob subscriptions by evaluating the glob against the list of
//! known alert classes when the glob is *created*, and creating corresponding
//! exact subscriptions for each event class that matches the glob.  This way,
//! we need not perform complex pattern matching in the database when
//! dispatching an alert, and can instead simply query for the existence of a
//! record in the `alert_subscription` table.  Each exact subscription entry
//! generated by a glob records which glob it came from, which is used when
//! a receiver's subscriptions change.
//!
//! Because the generation of exact subscriptions from globs occurs when the
//! subscription is created, globs must be *reprocessed* when new alert classes
//! are added to the system, generating new exact subscriptions for any
//! newly-added alert classes that match the glob, and potentially removing
//! subscriptions to any defunct alert classes  This could occur in any software
//! release where new kinds of events are implemented.  Therefore, when glob
//! subscriptions are created, we record the database schema version as part of
//! that glob subscription.  Because event classes are represented as a SQL
//! `enum` type,  we know that any change to the event classes should change the
//! database schema version as well.  This way, we can detect whether a glob's
//! list of subscriptions are up to date.  The `alert_dispatcher` background
//! task will query the database for any globs which were last reprocessed at
//! earlier database schema versions and reprocess those globs prior to
//! attempting to dispatch events to receivers.
//!
//! ## Deliveries, Delivery Attempts, and Liveness Probes
//!
//! A *delivery* represents state associated to sending an alert to a
//! particular receiver.
//!
//! At present, the only currently existing delivery type are *webhook
//! deliveries*, which represent the process of sending HTTP request(s)
//! representing an alert to a receiver.  Failed HTTP requests are retried up
//! to two times, so a delivery may consist of up to three *delivery attempts*.
//! Each time the `webhook_deliverator` background task is activated, it
//! searches for deliveries which have not yet succeeded or permanently failed,
//! which are not presently being delivered by another Nexus, and for which the
//! backoff period for any prior failed delivery attempts has elapsed.  It then
//! sends an HTTP request to the webhook receiver, and records the result,
//! creating a new `webhook_delivery_attempt` record and updating the
//! `webhook_delivery` record.
//!
//! Multiple Nexii use an advisory lease mechanism to avoid attempting to
//! deliver the same event simultaneously, by setting their UUID and a
//! timestamp on the `webhook_delivery` record.  Because webhook delivery is
//! at-least-once, this lease mechanism is NOT REQUIRED FOR CORRECTNESS IN ANY
//! WAY, Andrew. :) Instead, it serves only to reduce duplicate work.
//! Therefore, should a Nexus acquire a lease on a delivery and fail to either
//! complete the delivery attempt within a period of time, another Nexus is
//! permitted to clobber its lease.
//!
//! Deliveries are created either because an alert occurred and a webhook
//! receiver is subscribed to it, or because we were asked to resend a previous
//! delivery that failed permanently by exhausting its retry budget.  Initial
//! deliveries are created by activations of the webhook dispatcher background
//! task.  When creating a delivery, the data associated with the alert record
//! in the `alert` table is processed to produce the data payload that
//! will actually be sent to the receiver. Data which the receiver's service
//! account is not authorized to read is filtered out of the payload.[^2]
//!
//! Re-delivery of an event can be requested either via the alert resend API
//! endpoint, or by a *liveness probe* succeeding.  Liveness probes are
//! synthetic delivery requests sent to a webhook receiver to check whether it's
//! actually able to receive an event.  They are triggered via the
//! [`Nexus::webhook_receiver_probe`] API endpoint.  A probe may optionally
//! request that any events for which all past deliveries have failed be resent
//! if it succeeds.  Delivery records are also created to represent the outcome
//! of a probe.
//!
//! [RFD 538]: https://rfd.shared.oxide.computer/538
//! [alert classes]: https://rfd.shared.oxide.computer/rfd/538#_event_classes
//! [`AlertReceiver`]: nexus_db_queries::db::model::AlertReceiver
//!
//! [^1]: Read _Snow Crash_, if you haven't already.
//! [^2]: Presently, all alert receivers have the fleet.viewer role, so
//!     this "filtering" doesn't actually do anything. When webhook receivers
//!     with more restrictive permissions are implemented, please rememvber to
//!     delete this footnote.

use crate::Nexus;
use chrono::DateTime;
use chrono::Utc;
use nexus_db_lookup::LookupPath;
use nexus_db_lookup::lookup;
use nexus_db_queries::authz;
use nexus_db_queries::context::OpContext;
use nexus_db_queries::db::model::Alert as DbAlert;
use nexus_db_queries::db::model::AlertClass;
use nexus_db_queries::db::model::AlertDeliveryState;
use nexus_db_queries::db::model::AlertDeliveryTrigger;
use nexus_db_queries::db::model::WebhookDelivery;
use nexus_db_queries::db::model::WebhookReceiverConfig;
use nexus_types::external_api::params;
use nexus_types::external_api::shared;
use nexus_types::external_api::views;
use nexus_types::identity::Asset;
use omicron_common::api::external::CreateResult;
use omicron_common::api::external::DataPageParams;
use omicron_common::api::external::DeleteResult;
use omicron_common::api::external::Error;
use omicron_common::api::external::ListResultVec;
use omicron_common::api::external::LookupResult;
use omicron_common::api::external::NameOrId;
use omicron_common::api::external::http_pagination::PaginatedBy;
use omicron_uuid_kinds::AlertReceiverUuid;
use omicron_uuid_kinds::AlertUuid;
use omicron_uuid_kinds::GenericUuid;
use omicron_uuid_kinds::WebhookDeliveryUuid;
use uuid::Uuid;

pub use nexus_alerts::{Alert, AlertSchemaRegistry};

impl nexus_alerts::PublishAlert for Nexus {
    async fn publish_event<A: Alert>(
        &self,
        opctx: &OpContext,
        id: AlertUuid,
        alert: A,
    ) -> Result<DbAlert, Error> {
        self.alert_publish(opctx, id, alert).await
    }
}

pub(crate) fn schemas() -> AlertSchemaRegistry {
    let mut registry = AlertSchemaRegistry::new();

    #[cfg(debug_assertions)]
    nexus_alerts::alerts::test::register_all(&mut registry);

    // WHEN ADDING NEW ALERT CLASSES OR NEW SCHEMA VERSIONS, REMEMBER TO
    // REGISTER THEM HERE!

    registry
}

impl Nexus {
    /// Publish a new alert.
    ///
    /// The alert payload is represented by a type that implements the [`Event`]
    /// trait defined in this module. Publishing the alert converts it to a JSON
    /// object that's stored in the database.
    ///
    /// If this method returns `Ok`, the alert has been durably recorded in
    /// CockroachDB.  Once the new alert record is inserted into the database,
    /// the alert dispatcher background task is activated to dispatch the
    /// alert to receivers.  However, if (for whatever reason) this Nexus fails
    /// to do that, the alert remains durably in the database to be dispatched
    /// and delivered by someone else.
    pub async fn alert_publish<A: Alert>(
        &self,
        opctx: &OpContext,
        id: AlertUuid,
        alert: A,
    ) -> Result<DbAlert, Error> {
        #[cfg(debug_assertions)]
        {
            // In test builds, assert that this is a schema that we know about.
            let versions = match self
                .alert_schemas
                .schema_versions_for(A::CLASS)
            {
                Some(versions) => versions,
                None => panic!(
                    "You have attempted to publish an alert type whose class \
                     was not added to the alert schema registry in \
                     `nexus::app::alert::schemas()`! This means that the \
                     alert type's schema will not be included in the \
                     alert JSON schema. This is probably a mistake. Since I \
                     am a test build, I will now panic!\n    \
                         alert class: {}\n  \
                       alert version: {}",
                    A::CLASS,
                    A::VERSION,
                ),
            };

            if !versions.contains_key(&A::VERSION) {
                panic!(
                    "You have attempted to publish an alert type whose schema \
                     version is not present in the alert schema registry in \
                     `nexus::app::alert::schemas()`! This is probably a \
                     mistake. Since I am a test build, I will  now panic!\n    \
                         alert class: {}\n  \
                       alert version: {}",
                    A::CLASS,
                    A::VERSION,
                );
            }
        }

        let payload =
            serde_json::to_value(&alert).map_err(|e| Error::InternalError {
                internal_message: format!(
                    "failed to convert {} (class: {} v{}) to JSON: {e}",
                    std::any::type_name::<A>(),
                    A::CLASS,
                    A::VERSION,
                ),
            })?;

        let alert = self
            .datastore()
            .alert_create(opctx, id, A::CLASS, A::VERSION, payload)
            .await?;

        slog::debug!(
            &opctx.log,
            "published alert";
            "alert_id" => ?id,
            "alert_class" => %A::CLASS,
            "alert_version" => %A::VERSION,
            "time_created" => ?alert.identity.time_created,
        );

        // Once the alert has been inserted, activate the dispatcher task to
        // ensure its propagated to receivers.
        self.background_tasks.task_alert_dispatcher.activate();

        Ok(alert)
    }

    //
    // Lookups
    //

    pub fn alert_receiver_lookup<'a>(
        &'a self,
        opctx: &'a OpContext,
        rx_selector: params::AlertReceiverSelector,
    ) -> LookupResult<lookup::AlertReceiver<'a>> {
        match rx_selector.receiver {
            NameOrId::Id(id) => {
                let rx = LookupPath::new(opctx, &self.db_datastore)
                    .alert_receiver_id(AlertReceiverUuid::from_untyped_uuid(
                        id,
                    ));
                Ok(rx)
            }
            NameOrId::Name(name) => {
                let rx = LookupPath::new(opctx, &self.db_datastore)
                    .alert_receiver_name_owned(name.into());
                Ok(rx)
            }
        }
    }

    pub fn alert_lookup<'a>(
        &'a self,
        opctx: &'a OpContext,
        params::AlertSelector { alert_id }: params::AlertSelector,
    ) -> LookupResult<lookup::Alert<'a>> {
        let event = LookupPath::new(opctx, &self.db_datastore)
            .alert_id(AlertUuid::from_untyped_uuid(alert_id));
        Ok(event)
    }

    //
    // Alert class API
    //
    pub async fn alert_class_list(
        &self,
        opctx: &OpContext,
        filter: params::AlertClassFilter,
        pagparams: DataPageParams<'_, params::AlertClassPage>,
    ) -> ListResultVec<views::AlertClass> {
        opctx
            .authorize(authz::Action::ListChildren, &authz::ALERT_CLASS_LIST)
            .await?;
        Self::actually_list_alert_classes(filter, pagparams)
    }

    // This is factored out to avoid having to make a whole Nexus to test it.
    fn actually_list_alert_classes(
        params::AlertClassFilter { filter }: params::AlertClassFilter,
        pagparams: DataPageParams<'_, params::AlertClassPage>,
    ) -> ListResultVec<views::AlertClass> {
        use nexus_db_model::AlertSubscriptionKind;

        let regex = if let Some(filter) = filter {
            let sub = AlertSubscriptionKind::try_from(filter)?;
            let regex_string = match sub {
                AlertSubscriptionKind::Exact(class) => class.as_str(),
                AlertSubscriptionKind::Glob(ref glob) => glob.regex.as_str(),
            };
            let re = regex::Regex::new(regex_string).map_err(|e| {
                // This oughtn't happen, provided the code for producing the
                // regex for a glob is correct.
                Error::InternalError {
                    internal_message: format!(
                        "valid alert class globs ({sub:?}) should always \
                         produce a valid regex, and yet: {e:?}"
                    ),
                }
            })?;
            Some(re)
        } else {
            None
        };

        // If we're resuming a previous scan, figure out where to start.
        let start = if let Some(params::AlertClassPage { last_seen }) =
            pagparams.marker
        {
            let start = AlertClass::ALL_CLASSES.iter().enumerate().find_map(
                |(idx, class)| {
                    if class.as_str() == last_seen { Some(idx) } else { None }
                },
            );
            match start {
                Some(start) => start + 1,
                None => return Ok(Vec::new()),
            }
        } else {
            0
        };

        // This shouldn't ever happen, but...don't panic I guess.
        if start > AlertClass::ALL_CLASSES.len() {
            return Ok(Vec::new());
        }

        let result = AlertClass::ALL_CLASSES[start..]
            .iter()
            .filter_map(|&class| {
                // Skip test classes, as they should not be used in the public
                // API, except in test builds, where we need them
                // for, you know... testing...
                if !cfg!(test) && class.is_test() {
                    return None;
                }
                if let Some(ref regex) = regex {
                    if !regex.is_match(class.as_str()) {
                        return None;
                    }
                }
                Some(class.into())
            })
            .take(pagparams.limit.get() as usize)
            .collect::<Vec<_>>();
        Ok(result)
    }

    //
    // Receiver configuration API methods
    //

    pub async fn alert_receiver_list(
        &self,
        opctx: &OpContext,
        pagparams: &PaginatedBy<'_>,
    ) -> ListResultVec<WebhookReceiverConfig> {
        opctx.authorize(authz::Action::ListChildren, &authz::FLEET).await?;
        self.datastore().alert_rx_list(opctx, pagparams).await
    }

    pub async fn alert_receiver_config_fetch(
        &self,
        opctx: &OpContext,
        rx: lookup::AlertReceiver<'_>,
    ) -> LookupResult<WebhookReceiverConfig> {
        let (authz_rx, rx) = rx.fetch().await?;
        let (subscriptions, secrets) =
            self.datastore().webhook_rx_config_fetch(opctx, &authz_rx).await?;
        Ok(WebhookReceiverConfig { rx, secrets, subscriptions })
    }

    pub async fn alert_receiver_delivery_list(
        &self,
        opctx: &OpContext,
        rx: lookup::AlertReceiver<'_>,
        filter: params::AlertDeliveryStateFilter,
        pagparams: &DataPageParams<'_, (DateTime<Utc>, Uuid)>,
    ) -> ListResultVec<views::AlertDelivery> {
        let (authz_rx,) = rx.lookup_for(authz::Action::ListChildren).await?;
        let only_states = if filter.include_all() {
            Vec::new()
        } else {
            let mut states = Vec::with_capacity(3);
            if filter.include_failed() {
                states.push(AlertDeliveryState::Failed);
            }
            if filter.include_pending() {
                states.push(AlertDeliveryState::Pending);
            }
            if filter.include_delivered() {
                states.push(AlertDeliveryState::Delivered);
            }
            states
        };
        let deliveries = self
            .datastore()
            .webhook_rx_delivery_list(
                opctx,
                &authz_rx.id(),
                // No probes; they could have their own list endpoint later...
                &[AlertDeliveryTrigger::Alert, AlertDeliveryTrigger::Resend],
                only_states,
                pagparams,
            )
            .await?
            .into_iter()
            .map(|(delivery, class, attempts)| {
                delivery.to_api_delivery(class, &attempts)
            })
            .collect();
        Ok(deliveries)
    }

    //
    // Receiver subscription API methods
    //

    pub async fn alert_receiver_subscription_add(
        &self,
        opctx: &OpContext,
        rx: lookup::AlertReceiver<'_>,
        params::AlertSubscriptionCreate { subscription}: params::AlertSubscriptionCreate,
    ) -> CreateResult<views::AlertSubscriptionCreated> {
        let (authz_rx,) = rx.lookup_for(authz::Action::Modify).await?;
        let db_subscription = nexus_db_model::AlertSubscriptionKind::try_from(
            subscription.clone(),
        )?;
        let _ = self
            .datastore()
            .alert_subscription_add(opctx, &authz_rx, db_subscription)
            .await?;
        Ok(views::AlertSubscriptionCreated { subscription })
    }

    pub async fn alert_receiver_subscription_remove(
        &self,
        opctx: &OpContext,
        rx: lookup::AlertReceiver<'_>,
        subscription: shared::AlertSubscription,
    ) -> DeleteResult {
        let (authz_rx,) = rx.lookup_for(authz::Action::Modify).await?;
        let db_subscription =
            nexus_db_model::AlertSubscriptionKind::try_from(subscription)?;
        let _ = self
            .datastore()
            .alert_subscription_remove(opctx, &authz_rx, db_subscription)
            .await?;
        Ok(())
    }

    pub async fn alert_receiver_resend(
        &self,
        opctx: &OpContext,
        rx: lookup::AlertReceiver<'_>,
        event: lookup::Alert<'_>,
    ) -> CreateResult<WebhookDeliveryUuid> {
        let (authz_rx,) = rx.lookup_for(authz::Action::CreateChild).await?;
        let (authz_event, event) = event.fetch().await?;
        let datastore = self.datastore();

        let is_subscribed = datastore
            .alert_rx_is_subscribed_to_alert(opctx, &authz_rx, &authz_event)
            .await?;
        if !is_subscribed {
            return Err(Error::invalid_request(format!(
                "cannot resend alert: receiver is not subscribed to the '{}' \
                 alert class",
                event.class,
            )));
        }

        let delivery = WebhookDelivery::new(
            &event.id(),
            &authz_rx.id(),
            AlertDeliveryTrigger::Resend,
        );
        let delivery_id = delivery.id.into();

        if let Err(e) =
            datastore.webhook_delivery_create_batch(opctx, vec![delivery]).await
        {
            slog::error!(
                &opctx.log,
                "failed to create new delivery to resend webhook alert";
                "rx_id" => ?authz_rx.id(),
                "alert_id" => ?authz_event.id(),
                "alert_class" => %event.class,
                "delivery_id" => ?delivery_id,
                "error" => %e,
            );
            return Err(e);
        }

        slog::info!(
            &opctx.log,
            "resending webhook event";
            "rx_id" => ?authz_rx.id(),
            "alert_id" => ?authz_event.id(),
            "alert_class" => %event.class,
            "delivery_id" => ?delivery_id,
        );

        self.background_tasks.task_webhook_deliverator.activate();
        Ok(delivery_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Nexus;
    use std::num::NonZeroU32;

    #[test]
    fn test_alert_class_list() {
        #[track_caller]
        fn list(
            filter: Option<&str>,
            last_seen: Option<&str>,
            limit: u32,
        ) -> Vec<String> {
            let filter = params::AlertClassFilter {
                filter: dbg!(filter).map(|f| f.parse().unwrap()),
            };
            let marker = dbg!(last_seen).map(|last_seen| {
                params::AlertClassPage { last_seen: last_seen.to_string() }
            });
            let result = Nexus::actually_list_alert_classes(
                filter,
                DataPageParams {
                    marker: marker.as_ref(),
                    direction: dropshot::PaginationOrder::Ascending,
                    limit: NonZeroU32::new(dbg!(limit)).unwrap(),
                },
            );

            // Throw away the description fields
            dbg!(result)
                .unwrap()
                .into_iter()
                .map(|view| view.name)
                .collect::<Vec<_>>()
        }

        // Paginated class list, without a glob filter.
        let classes = list(None, None, 3);
        assert_eq!(classes, &["probe", "test.foo", "test.foo.bar"]);
        let classes = list(None, Some("test.foo.bar"), 3);
        assert_eq!(
            classes,
            &["test.foo.baz", "test.quux.bar", "test.quux.bar.baz"]
        );
        // Don't assert that a third list will return no more results, since
        // more events may be added in the future, and we don't have a filter.

        // Try a filter for only `test.**` events.
        let filter = Some("test.**");
        let classes = list(filter, None, 2);
        assert_eq!(classes, &["test.foo", "test.foo.bar"]);
        let classes = list(filter, Some("test.foo.bar"), 2);
        assert_eq!(classes, &["test.foo.baz", "test.quux.bar"]);
        let classes = list(filter, Some("test.quux.bar"), 2);
        assert_eq!(classes, &["test.quux.bar.baz"]);
        let classes = list(filter, Some("test.quux.bar.baz"), 2);
        assert_eq!(classes, Vec::<String>::new());
    }
}
