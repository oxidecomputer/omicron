// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Facilities for working with the Omicron database

pub(crate) mod alias;
// This is not intended to be public, but this is necessary to use it from
// doctests
pub mod collection_attach;
pub mod collection_detach;
pub mod collection_detach_many;
pub mod collection_insert;
mod config;
mod cte_utils;
// This is marked public for use by the integration tests
pub mod datastore;
mod error;
mod explain;
pub mod fixed_data;
pub mod lookup;
mod pagination;
mod pool;
// This is marked public because the error types are used elsewhere, e.g., in
// sagas.
pub(crate) mod queries;
mod saga_recovery;
mod sec_store;
pub(crate) mod subquery;
pub(crate) mod true_or_cast_error;
mod update_and_check;

#[cfg(test)]
mod test_utils;

pub use nexus_db_model as model;
use nexus_db_model::saga_types;
pub use nexus_db_model::schema;

#[cfg(test)]
pub use crate::db::error::TransactionError;
pub use config::Config;
pub use datastore::DataStore;
pub use pool::Pool;
pub use saga_recovery::{recover, RecoveryTask};
pub use saga_types::SecId;
pub use sec_store::CockroachDbSecStore;

pub use nexus_types::identity;

/// Does some basic smoke checks on an impl of `DatabaseString`
///
/// This tests:
///
/// - that for every variant, if we serialize it and deserialize the result, we
///   get back the original variant
/// - that if we attempt to deserialize some _other_ input, we get back an error
/// - that the serialized form for each variant matches what's found in
///   `expected_output_file`.  This output file is generated by this test using
///   expectorate.
///
/// This cannot completely test the correctness of the implementation, but it
/// can catch some basic copy/paste errors and accidental compatibility
/// breakage.
#[cfg(test)]
pub fn test_database_string_impl<T, P>(expected_output_file: P)
where
    T: std::fmt::Debug
        + PartialEq
        + nexus_db_model::DatabaseString
        + strum::IntoEnumIterator,
    P: std::convert::AsRef<std::path::Path>,
{
    let mut output = String::new();
    let mut maxlen: Option<usize> = None;

    for variant in T::iter() {
        // Serialize the variant.  Verify that we can deserialize the thing we
        // just got back.
        let serialized = variant.to_database_string();
        let deserialized =
            T::from_database_string(serialized).unwrap_or_else(|_| {
                panic!(
                    "failed to deserialize the string {:?}, which we \
                    got by serializing {:?}",
                    serialized, variant
                )
            });
        assert_eq!(variant, deserialized);

        // Put the serialized form into "output".  At the end, we'll compare
        // this to the expected output.  This will fail if somebody has
        // incompatibly changed things.
        output.push_str(&format!(
            "variant {:?}: serialized form = {}\n",
            variant, serialized
        ));

        // Keep track of the maximum length of the serialized strings.  We'll
        // use this to construct an input to `from_database_string()` that was
        // not emitted by any of the variants' `to_database_string()` functions.
        match (maxlen, serialized.len()) {
            (None, newlen) => maxlen = Some(newlen),
            (Some(oldlen), newlen) if newlen > oldlen => maxlen = Some(newlen),
            _ => (),
        }
    }

    // Check that `from_database_string()` fails when given input that doesn't
    // match any of the variants' serialized forms.  We construct this input by
    // providing a string that's longer than all strings emitted by
    // `to_database_string()`.
    if let Some(maxlen) = maxlen {
        let input = String::from_utf8(vec![b'-'; maxlen + 1]).unwrap();
        T::from_database_string(&input)
            .expect_err("expected failure to deserialize unknown string");
    }

    expectorate::assert_contents(expected_output_file, &output);
}
