// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! A store of successive reconfigurator states: the main entrypoint for
//! reconfigurator simulation.

use std::collections::HashMap;

use indexmap::IndexSet;
use omicron_uuid_kinds::{ReconfiguratorSimKind, ReconfiguratorSimUuid};
use typed_rng::TypedUuidRng;

use crate::{seed_from_entropy, SimState};

/// A store to track reconfigurator states: the main entrypoint for
/// reconfigurator simulation.
///
/// This is the main entry point for reconfigurator simulation. It provides
/// key-based storage for systems and their states, and allows for append-only
/// storage of new states.
///
/// # Implementation notes
///
/// We currently index by UUIDs, but we could index by the hash of the contents
/// and make it a Merkle tree just as well. (We'd have to hook up canonical
/// hashing etc; it's a bunch of work but not too difficult). If there's a
/// particular need that arises for content-addressing, we should do it.
#[derive(Debug)]
pub struct Simulator {
    log: slog::Logger,
    // In the future, it would be interesting to store a higher-level chain of
    // every set of heads over time. That would let us implement undo and
    // restore operations.
    heads: IndexSet<ReconfiguratorSimUuid>,
    states: HashMap<ReconfiguratorSimUuid, SimState>,
    // This state corresponds to `ROOT_ID`.
    root_state: SimState,
    // Top-level (unversioned) RNG.
    sim_uuid_rng: TypedUuidRng<ReconfiguratorSimKind>,
}

impl Simulator {
    /// The root ID of the store.
    ///
    /// This is always defined to be the nil UUID, and if queried will always
    /// have a state associated with it.
    pub const ROOT_ID: ReconfiguratorSimUuid = ReconfiguratorSimUuid::nil();

    /// Create a new simulator with the given initial seed.
    pub fn new(log: &slog::Logger, seed: Option<String>) -> Self {
        let seed = match seed {
            Some(seed) => seed,
            None => seed_from_entropy(),
        };
        Self::new_inner(log, seed)
    }

    fn new_inner(log: &slog::Logger, seed: String) -> Self {
        let log = log.new(slog::o!("component" => "SimStore"));
        let sim_uuid_rng =
            TypedUuidRng::from_seed(&seed, "ReconfiguratorSimUuid");
        let root_state = SimState::new_root(seed);
        Self {
            log,
            heads: IndexSet::new(),
            states: HashMap::new(),
            root_state,
            sim_uuid_rng,
        }
    }

    /// Get the initial RNG seed.
    ///
    /// Versioned configurations start with this seed, though they may choose
    /// to change it as they go along.
    pub fn initial_seed(&self) -> &str {
        &self.root_state.rng().seed()
    }

    /// Get the current heads of the store.
    #[inline]
    pub fn heads(&self) -> &IndexSet<ReconfiguratorSimUuid> {
        &self.heads
    }

    /// Get the state for the given UUID.
    pub fn get_state(&self, id: ReconfiguratorSimUuid) -> Option<&SimState> {
        if id == Self::ROOT_ID {
            return Some(&self.root_state);
        }
        self.states.get(&id)
    }

    #[inline]
    pub(crate) fn next_sim_uuid(&mut self) -> ReconfiguratorSimUuid {
        self.sim_uuid_rng.next()
    }

    // Invariant: the ID should be not present in the store, having been
    // generated by next_sim_uuid.
    pub(crate) fn add_state(&mut self, state: SimState) {
        let id = state.id();
        let parent = state.parent();
        if self.states.insert(id, state).is_some() {
            panic!("ID {id} should be unique and generated by the store");
        }

        // Remove the parent if it exists as a head, and in any case add the
        // new one. Unlike in source control we don't have a concept of
        // "merges" here, so there's exactly one parent that may need to be
        // removed.
        if let Some(parent) = parent {
            self.heads.shift_remove(&parent);
        }
        self.heads.insert(id);

        slog::debug!(
            self.log,
            "committed new state";
            "id" => %id,
            "parent" => ?parent,
        );
    }
}
